%------------------------------------------------------------------------------+
%                                                                              |
%     File: Reports/11-ClassicML/Classic-ML.tex                                |
%                                                                              |
%     Manual for Classic ML                                                    |
%                                                                              |
%     Author: Christoph Kreitz                                                 |
%     Date: 08/ 9/11                                                           |
%     Last Update: 08/10/11                                                    |
%                                                                              |
%------------------------------------------------------------------------------+
\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{hyperref}
\usepackage{colordvi}
\usepackage{amssymb}
%\usepackage{textcomp}
\usepackage{{../../tex/ML-macros}}
%\usepackage{ucs}
\usepackage[utf8x]{inputenc}


\pagestyle{plain}


\bibliographystyle{alpha}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This Manual is based on the Nuprl ML Manual. I have removed references to the
% Nuprl top loop and commented out features that are currently not supported or
% have been changed.
%
% MAJOR CHANGES SHOULD BE LISTED HERE
%
% - Product types are denoted by  ``S * T'' not by ``S \# T''.
% - No references.
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\title{\bf Introduction to Classic ML}
\author{Christoph Kreitz and Vincent Rahli
	\\[2mm]
	Department of Computer Science, Cornell-University \\
            	  Ithaca, NY 14853-7501, U.S.A.
	\\[2mm]
	\small
	%% \href{mailto:vr238@cornell.edu?subject=ML-Manual}
	%%     {\tt{vr238@cornell.edu}}
       	}
\date{~}


\maketitle

% ----------------------------------------------------------------------------
\section{The History of {\ML}}
\label{sec:ML-history}
% ----------------------------------------------------------------------------

Several versions of the programming language \ML\index{ML@\ML!versions of}\ have
appeared over the years, between the time it was first designed and implemented
by Milner\index{Milner, R.}, Morris\index{Morris, L.}  and
Wadsworth\index{Wadsworth, C.} at the University of Edinburgh in the early
1970's, and the time it was settled and standardized in the mid-1980's.  The
original \ML, the {\em meta-language\/} of the \NOTION{Edinburgh \LCF} system,
is defined in \cite{Gordon+Milner+Wadsworth:1979}\index{LCF@\LCF!Edinburgh}.

The \ML\ used in the {\Nuprl}~\cite{Constable+al:1986,Kreitz:02,Allen+al:2006}
system is fairly close to the original. It is derived from a early
version that Huet\index{Huet, G.} at {\small INRIA} and
Paulson\index{Paulson, L.}  at the University of Cambridge were
working on in 1981.  Todd Knoblock at Cornell made most of the
{\Nuprl} specific modifications in the mid-1980's.  {\Nuprl}'s {\ML}
hasn't changed since then and is not compatible with the {\ML}
versions that are widely used~today.\smallskip

The \ML\ of Huet and Paulson is described in the preface to `{\em The {\ML}
Handbook\/}'~\cite{mi:ml-handbook84a}.  Huet used this version in the Formel
project; and it subsequently evolved into a version of \ML\ called \NOTION{\sf
CAML}\index{ML@\ML!CAML version of@\verb+CAML+ version of}.  Paulson also used
it, as part of the first version of Cambridge \LCF, but switched to
\NOTION{Standard
  {\ML}}~\cite{Milner+Tofte+Harper:1990,Milner+Tofte+Harper+Macqueen:1997}
in the later versions of \NOTION{Cambridge
  {\LCF}}\index{LCF@\LCF!Cambridge}~\cite{bo:Paulson87a}.

The {\sf CAML} language~\cite{tr:CousineauHuet90a,tr:Weis+90a} is now rarely
used. But there is a scaled down version called \NOTION{\sf CAML-Light} which is
actively used in teaching programming to over 10,000 engineers a year in France.
Its object-oriented version \NOTION{\sf OCaml}~\cite{ma:Caml00a} have become
quite popular in recent years and has been used in the implementation of the
group communication toolkit~{\sf Ensemble}~\cite{Hayden:98a,Birman+al:2000a}.
It is also the implementation language of the
{\COQ}~\cite{Bertot+Casteran:2004} theorem prover.
{\sf OCaml} has directly influenced the design of the Microsoft
language {\FSHARP}~\cite{Syme+Granicz+Cisternino:2007}.
The Standard {\ML} language has also become increasingly popular for
implementing theorem provers such as {\HOL}~\cite{Gordon+Melham:93a} or {\sf
Isabelle}~\cite{inc:Paulson90a}.

The description of \ML\ that appears in the following Sections
% Sections~\ref{sec:ML-syntax} to \ref{sec:ML-prims}
is based very closely on `The {\ML} Handbook'
\cite{mi:ml-handbook84a}.  It was adapted for \Nuprl\ purposes from \LaTeX\
sources provided by the {\HOL} theorem proving group in Cambridge.  For
completeness (and historical interest), the preface to `{\em The {\ML}
Handbook\/}' and the preface to `{\em Edinburgh LCF: a Mechanised Logic of
Computation\/}' are reproduced~below.

% -------------------------------------------------
\subsection{Preface to `The {\ML} Handbook'}
% -------------------------------------------------

This handbook is a revised edition of Section~2 of `Edinburgh LCF', by
M.~Gordon, R.~Milner, and C.~Wadsworth, published in 1979 as Springer Verlag
Lecture Notes in Computer Science n$^{\underline{o}}$~78.  \ML\ was originally
the meta-language of the \LCF~system. The \ML\ system was adapted to Maclisp on
Multics by G\'erard Huet at {\small INRIA} in 1981, and a compiler was added.
Larry Paulson from the University of Cambridge completely redesigned the \LCF\
proving system, which stabilized in 1984 as Cambridge \LCF.  Guy Cousineau from
the University Paris VII added concrete types in the summer of 1984.  Philippe
Le~Chenadec from {\small INRIA} implemented an interface with the Yacc parser
generator system, for the versions of \ML\ running under Unix.  This permits the
user to associate a concrete syntax with a concrete type.

The \ML\ language is still under design.  An extended language was implemented
on the VAX by Luca Cardelli in 1981.  It was then decided to completely
re-design the language, in order to accommodate in particular the call by
pattern feature of the language HOPE designed by Rod Burstall and David
MacQueen.  A committee of researchers from the Universities of Edinburgh and
Cambridge, the Bell Laboratories and {\small INRIA}, headed by Robin Milner, is
currently working on the new extended language, called Standard \ML.  Progress
reports appear in the Polymorphism Newsletter, edited by Luca Cardelli and
David MacQueen from Bell Laboratories.  The design of a core language is now
frozen, and its description will appear in a forthcoming report of
the University of Edinburgh, as `The Standard \ML\ Core Language' by Robin Milner.

This handbook is a manual for \ML~version 6.1, released in December 1984.
The language is somewhere in between the original \ML\ from \LCF\ and standard
\ML, since Guy Cousineau added the constructors and call by 
patterns.  This is a LISP based implementation, compatible for Maclisp on
Multics, Franzlisp on VAX under Unix, Zetalisp on Symbolics 3600, and Le\_Lisp
on 68000, VAX, Multics, Perkin-Elmer, etc... Video interfaces have been
implemented by Philippe Le Chenadec on Multics, and by Maurice Migeon
on Symbolics 3600.  The \ML\ system is maintained and distributed jointly by
{\small INRIA} and the University of Cambridge.


% -------------------------------------------------
\subsection{Preface to `Edinburgh LCF'}
% -------------------------------------------------

\ML\ is a general purpose programming language.  It is derived in different
aspects from {\small ISWIM}, {\small POP2} and {\small GEDANKEN}, and contains
perhaps two new features. First, it has an escape and escape trapping mechanism,
well-adapted to programming strategies which may be (in fact usually are)
inapplicable to certain goals. Second, it has a polymorphic type discipline
which combines the flexibility of programming in a typeless language with the
security of compile-time type checking (as in other languages, you may also
define your own types, which may be abstract and/or recursive).

For those primarily interested in the design of programming languages, a few
remarks here may be helpful both about \ML\ as a candidate for comparison with
other recently designed languages, and about the description of \ML\ which we
provide. On the first point, although we did not set out with programming
language design as a primary aim, we believe that \ML\ does contain features
worthy of serious consideration; these are the escape mechanism and the
polymorphic type discipline mentioned above, and also the attempt to make
programming with functions---including those of higher type---as easy and
natural as possible.  We are less happy about the imperative aspects of the
language, and would wish to give them further thought if we were mainly
concerned with language design. In particular, the constructs for controlling
iteration both by boolean conditions and by escape-trapping (which we included
partly for experiment) are perhaps too complex taken together, and we are
sensitive to the criticism that escape (or failure, as we call it) reports
information only in the form of a string. This latter constraint results mainly
from our type discipline; we do not know how best to relax the constraint while
maintaining the discipline.

Concerning the description of \ML, we have tried both to initiate users by
examples of programming and to give a precise definition.





% ------------------------------------------------------------------------------
\section{Introduction and Examples}
\label{sec:ML-intro}
% ------------------------------------------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \ML\ is an interactive language. At top-level\index{ML@\ML!top level
% of}\index{top level, of ML@top level, of \ML} one can:
%
% \begin{itemize}\setlength{\itemsep}{0mm}\vspace*{-2mm}
%   \item evaluate expressions
%   \item perform declarations
% \end{itemize}\vspace*{-2mm}
%
% To give a first impression of the system, we reproduce below a session at a
% terminal in which simple uses of various \ML\ constructs are illustrated.  To
% make the session easier to follow, it is split into a sequence of sub-sessions.
% A complete description of the syntax and semantics of \ML\ is given in
% Section~\ref{sec:ML-syntax} and Section~\ref{sec:ML-semantics} respectively.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% --------------------------------------
\subsection {Classic \ML\ versus \EML}
% --------------------------------------

The \EML\ language has emerged from mixing \CML\ with a logic called
\emph{Logic of
  Events}~\cite{Bickford:2009,Bickford+Constable:2008,Bickford+Constable+Guaspari:2011a}.
This document presents the \ML\ part of the \EML\ language and makes
explicit when \EML's syntax varies from \CML.


% --------------------------------------
\subsection {Sessions}
% --------------------------------------

When writing \ML\ pieces of code, typically users write global (or
top-level) declarations (see Section~\ref{sec:declarations} below) in
a file and evaluate expressions (see Section~\ref{sec:expressions}
below) in a \ML\ session.  The fact that global declarations can only
be written in a file and not in a session comes from using
\EML\ sessions which do not allow global declarations.  Note that
there are \ML\ sessions other than \EML\ sessions that allow such
global declarations (such as the ones used in \Nuprl).

Each example presented below follows the same schema: it is split into
two boxes, the left box being a \ML\ session running on the file
partially displayed in the right box.  Also, each example is
self-contained in the sense that each time an example makes use of a
global declaration, this declaration is in the right part of the
example.

\EML\ provides ways to use functions defined in a library file
(extracted from \Nuprl) that is distributed with \EML.  One way is to
use \TTD{import} declaration.  Many functions can be imported such as
functions to deal with lists (see, e.g., Section~\ref{sec:lists}).
\EML\ comes with an \Emacs~UI that provides a feature to display the
available functions (the provided library can also be consulted in any
other text editor).


% --------------------------------------
\subsection {Expressions}
\label{sec:expressions}
% --------------------------------------

In this tutorial, the \ML\ prompt\index{prompt, in ML@prompt, in
\ML}\index{ML@\ML!prompt character of} is \Em{\tt\#}\index{ prompt, in
ML@{\small\verb+#+} (prompt, in \ML)} (the \EML\ prompt is \Em{\tt
  EventML\#}), so lines beginning with this contain the
user's contribution; all other lines are output by the system.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The {\Nuprl} {\ML} prompt is different; usually {\tt ML>} is used for the
% first line of user input, and {\tt >} is used for continuation lines.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{session}
\emlsession
\begin{verbatim}
# 2 + 3;;
5 : Int
\end{verbatim}
%
% # it;;
% 5 : int
%\end{verbatim}
\emlfile
\emlend
\end{session}

\ML\ prompted with \Em{\tt\#}, the user then typed \ttq{2 + 3;;} followed by a
carriage return {\RET}; \ML\ then responded with \ttq{5 :~int}
\index{int@\ml{int}}\index{type constraint!in ML@in \ML}, a new line, and then
prompted again.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The user then typed \ttq{it;;{\RET}} and the system responded
% by typing \ttq{5 :~int} again.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In general to evaluate an expression $e$ one
types $e$\index{terminator, of {\ML} expressions@terminator, of \ML\
expressions}\index{ terminator, of {\ML} expressions@{\tt;;} (terminator, of
\ML\ expressions)}\index{expressions, in ML@expressions, in \ML!terminator
for}\index{top level terminator, in ML@top level terminator, in
\ML}\index{ML@\ML!top level expression terminator in} followed by a carriage
return\index{carriage return!after {\ML} expressions@after \ML\
expressions}\index{expressions, in ML@expressions, in \ML!carriage return
after}; the system then prints $e$'s value and type (the type prefaced by a
colon).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% The {\em value of the last expression\/} evaluated at top level is
% remembered in the identifier~\TTD{it}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% --------------------------------------
\subsection {Declarations}
\label{sec:declarations}
% --------------------------------------

\index{let in@\ml{let} $\ldots$ \ml{in} $\ldots$|(}
The declaration \TTD{let $x$ = $e$}\index{let, in ML@\ml{let}, in \ML}
evaluates $e$ and binds\index{bindings, in ML@bindings, in \ML!in
declarations|(} the  resulting value to $x$.

\begin{session}
\emlsession
\begin{verbatim}
# x;;
6 : Int
\end{verbatim}
\emlfile
\begin{verbatim}
let x = 2 * 3;;
\end{verbatim}
\emlend
\end{session}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Notice that declarations\index{declarations, in ML@declarations, in \ML!effect
% on it@effect on \ml{it}} do not affect the identifier
% \ttQ{it}\index{it@\ml{it}}.  To bind the variables $x_1,\ldots,x_n$
% simultaneously\index{bindings, in ML@bindings, in \ML!simultaneous} to the
% values of the expressions $e_1,\ldots,e_n$ one can perform either the
% declaration \TTD{let $x_1$=$e_1$ and $x_2$=$e_2$ \ldots and $x_n$=$e_n$} \ or \
% \TTD{let $x_1$,$x_2$,\ldots,$x_n$ = $e_1$,$e_2$\ldots,$e_n$}.  \ These two
% declarations are equivalent.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To bind the variables $x_1,\ldots,x_n$
simultaneously\index{bindings, in ML@bindings, in \ML!simultaneous} to the
values of the expressions $e_1,\ldots,e_n$ one can perform the declaration
\TTD{let ($x_1$,$x_2$,\ldots,$x_n$) = ($e_1$,$e_2$\ldots,$e_n$)}.

\begin{session}
\emlsession
\begin{verbatim}
# x;;
10 : Int
# y;;
6 : Int
\end{verbatim}
\emlfile
\begin{verbatim}
let x = 2 * 3;;
let y = 10;;
let (x, y) = (y, x);;
\end{verbatim}
\emlend
\end{session}

%% \begin{session}
%% % # let y=10 and z=x;;
%% % y = 10 : int
%% % z = 6 : int
%% %
%% \begin{verbatim}
%% # let x,y = y,x;;
%% x = 10 : int
%% y = 6 : int
%% \end{verbatim}
%% \end{session}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% A declaration $d$ can be made {\em local\/}\index{declarations, in
% ML@declarations, in \ML!local} to the evaluation of an expression $e$ by
% evaluating the expression \TTD{$d$ in $e$}.  The expression \TTD{$e$ where
% $b$}\index{where@{\small\verb+where+}} (where $b$ is a {\it binding\/} such as
% \ttQ{x=2}) is equivalent to \ttQ{let $b$ in $e$}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A declaration $d$ can be made {\em local\/}\index{declarations, in
ML@declarations, in \ML!local} to the evaluation of an expression $e$ by
evaluating the expression \TTD{let $d$ in $e$} (or equivalently
\TTD{$e$ where $d$}).

\begin{session}
\emlsession
\begin{verbatim}
# let x = 2 in x * y;;
12 : Int
# (x * y) where x = 2;;
12 : Int
\end{verbatim}
%
% # x*y where x=2;;
% 12 : int
\emlfile
\begin{verbatim}
let x = 2 * 3;;
let y = 10;;
let (x, y) = (y, x);;
\end{verbatim}
\emlend
\end{session}

%% \begin{session}
%% \begin{verbatim}
%% # let x = 2 in x * y;;
%% 12 : int

%% # x;;
%% 10 : int
%% \end{verbatim}
%% %
%% % # x*y where x=2;;
%% % 12 : int
%% \end{session}

\index{bindings, in ML@bindings, in \ML!in declarations|)}
\index{let in@\ml{let} $\ldots$ \ml{in} $\ldots$|)}


%% % --------------------------------------
%% \subsection{Assignment}
%% % --------------------------------------

%% Identifiers can be declared {\em assignable\/} \index{variables, in
%% ML@variables, in \ML!assignable}\index{assignable variables, in ML@assignable
%% variables, in \ML} using \TTD{letref}\index{letref in@\ml{letref} $\ldots$
%% \ml{in} $\ldots$} instead of \ttQ{let}.  Values bound to such identifiers can be
%% changed with the assignment expression $x${\small\verb%:=%}$e$\index{
%% assignment, in ML@{\small\verb+:=+} (assignment, in \ML)}, which changes the
%% value bound to $x$ to be the value of $e$.  Attempts to assign to non-assignable
%% variables are detected by the type checker.

%% \begin{session}
%% \begin{verbatim}
%% # x:=1;;

%% unbound or non-assignable variable x
%% 1 error in typing
%% typecheck failed

%% # letref x=1 and y=2;;
%% x = 1 : int
%% y = 2 : int

%% # x:=6;;
%% 6 : int

%% # x;;
%% 6 : int
%% \end{verbatim}
%% \end{session}

%% The value of an assignment \TTD{$x$:=$e$} is the value of $e$ (hence the value
%% of \ttQ{y:=6} is \ttQ{6}).  Simultaneous assignments\index{assignments, in
%% ML@assignments, in \ML!simultaneous} can also be done:

%% \begin{session}
%% \begin{verbatim}
%% # x,y := y,x;;
%% (2,6) : (int # int)

%% # x,y;;
%% (2,6) : (int # int)
%% \end{verbatim}
%% \end{session}

%% \noindent
%% The type
%% \TTD{(int \# int)}\index{ product type operator, in ML@{\small\verb+# +}
%% (product type operator, in \ML)} is the type of pairs\index{pairs, in
%% ML@pairs, in \ML} of integers.


% --------------------------------------
\subsection {Functions}
% --------------------------------------

To define a function $f$ with formal parameter $x$ and body $e$ one performs the
declaration
% ------------------------------
\linebreak
% ------------------------------
\TTD{let $f$ $x$ = $e$}.  To apply\index{function application, in
ML@function application, in \ML} the function $f$ to an actual parameter $e$ one
evaluates the expression~\TTD{$f$ $e$}.

\begin{session}
\emlsession
\begin{verbatim}
# f;;
- : Int -> Int
# f 4;;
8 : Int
\end{verbatim}
\emlfile
\begin{verbatim}
let f x = 2 * x;;
\end{verbatim}
\emlend
\end{session}


Functions are printed as a dash, \TTD{-}\index{non-printable values in
ML@non-printable values in \ML}\index{printing, of ML@printing, of \ML!of
functions}\index{functions in {\ML}, printing of@functions in \ML, printing
of}\index{ non-printable symbol, in ML@{\small\verb+-+} (`non-printable' symbol,
in \ML)}, followed by their type, since a function as such is not printable.
Application \index{function application, in ML@function application, in
\ML!precedence of} \index{precedence, in ML@precedence, in \ML!of function
application in ML@of function application in \ML} binds more tightly than
anything else in the language; thus, for example, \ttQ{$f$ 3 + 4} means
\ttQ{($f$ 3) + 4} not \ttQ{$f$ (3 + 4)}. Functions of several arguments can be
defined:

\begin{session}
\emlsession
\begin{verbatim}
# plus 3 4;;
7 : Int

# f 4;;
7 : Int
\end{verbatim}
\emlfile
\begin{verbatim}
let plus x y = x + y;;

let f = plus 3;;
\end{verbatim}
\emlend
\end{session}


Application\index{function application, in ML@function application, in
\ML!associativity of} associates\index{associativity, of constructs in
ML@associativity, of constructs in \ML} to the left so \ttQ{plus 3 4} means
\ttQ{(plus 3) 4}.  In the expression \ttQ{plus 3}, the function \ttQ{plus} is
partially applied\index{function application, in ML@function application, in
\ML!partial}\index{partial function application, in ML@partial function
application, in \ML} to \ttQ{3}; the resulting value is the function of type
\ttQ{int -> int} which adds \ttQ{3} to its argument.  Thus \ttQ{plus} takes its
arguments one at a time. We could have made \ttQ{plus} take a single argument of
the cartesian product type \ttQ{(int * int)}:

\begin{session}
\emlsession
\begin{verbatim}
# plus(3,4);;
7 : Int

# let z = (3,4) in plus z;;
7 : Int

# plus 3;;
[ERROR]
kind:
type constructor clash between Int and *
slice:
⟨..let plus (⟨..⟩, ⟨..⟩) = ⟨..⟩;;
 ..plus 3;;
 ..⟩

Untypable.
\end{verbatim}
\emlfile
\begin{verbatim}
let plus(x,y) = x + y;;
\end{verbatim}
\emlend
\end{session}

\noindent
As well as taking structured arguments (e.g.~\ttQ{(3,4)}) functions may also
return structured results.

\begin{session}
\emlsession
\begin{verbatim}
# sumdiff(3,4);;
(7, ~1) : Int * Int
\end{verbatim}
\emlfile
\begin{verbatim}
let sumdiff(x,y) =
   (x + y, x - y)
;;
\end{verbatim}
\emlend
\end{session}


% ----------------------------------------
\subsection {Recursion}
% ----------------------------------------

The following is an attempt to define the factorial function:

\begin{session}
\emlsession
\emlfile
\begin{verbatim}
let fact n =
  if n=0
  then 1
  else n*fact(n-1);;
\end{verbatim}
\emlend
\end{session}

Given this piece of code the type checker returns the following error
message:
\begin{emlerror}
\begin{verbatim}
[ERROR]
kind:  fact is a free identifier
slice: ⟨..fact;;..⟩
\end{verbatim}
\end{emlerror}



\noindent
The problem is that any free variables\index{free variables, in ML@free
variables, in \ML!in function definitions} in the body of a function have the
bindings\index{bindings, in ML@bindings, in \ML!in function definitions} they
had just before the function was declared; \ttQ{fact} is such a free variable in
the body of the declaration above, and since it is not defined before its own
declaration, an error results.  To make things clear~consider:

\begin{session}
\emlsession
\begin{verbatim}
# f 3;;
9 : Int
\end{verbatim}
\emlfile
\begin{verbatim}
let f n = n + 1;;

let f n =
  if n = 0
  then 1
  else n * f(n - 1);;
\end{verbatim}
\emlend
\end{session}


Here \ttQ{f 3} results in the evaluation of \ttQ{3 * f(2)}, but now
the first \ttQ{f} is used so \ttQ{f(2)} evaluates to \ttQ{2 + 1 = 3},
hence the expression \ttQ{f 3} results in \ttQ{3 * 3 = 9}.  To make a
function declaration hold within its own body,
\TTD{letrec}\index{letrec in@\ml{letrec} $\ldots$ \ml{in} $\ldots$}
instead of \ttQ{let} must be used.  The correct recursive definition
of the factorial function is thus:

\begin{session}
\emlsession
\begin{verbatim}
# fact 3;;
6 : Int
\end{verbatim}
\emlfile
\begin{verbatim}
letrec fact n =
  if n = 0
  then 1
  else n * fact(n - 1);;
\end{verbatim}
\emlend
\end{session}

%% % ----------------------------------------
%% \subsection {Iteration}
%% % ----------------------------------------

%% \index{conditional loop construct, in ML@conditional/loop construct, in \ML|(}

%% The construct \TTD{if $e_1$ then $e_2$ loop $e_3$} \index{if then loop@{\small
%% if $\cdots$ then $\cdots$ loop $\cdots$}|(} is the same as \TTD{if $e_1$ then
%% $e_2$ else $e_3$} \index{if then else@{\small if $\cdots$ then $\cdots$ else
%% $\cdots$}|(} in the true case; when $e_1$ evaluates to false, $e_3$ is evaluated
%% and control loops back to the front of the construct again.  As an illustration,
%% here is an iterative definition of \ttQ{fact} using two local assignable
%% variables:\index{assignable variables, in ML@assignable variables, in \ML}
%% \ttQ{count} and \ttQ{result}.

%% \begin{session}
%% \begin{verbatim}
%% # let fact n =
%% #     letref count=n and result=1
%% #     in     if count=0
%% #            then result
%% #            loop count,result := count-1,count*result;;
%% fact = - : (int -> int)

%% # fact 4;;
%% 24 : int
%% \end{verbatim}
%% \end{session}

%% Replacing the \ttQ{then} in \ttQ{if $e_1$ then $e_2$ else $e_3$}\index{if then
%% else@{\small if $\cdots$ then $\cdots$ else $\cdots$}} by \ttQ{loop} causes
%% iteration when $e_1$ evaluates to true: e.g., \TTD{if $e_1$ loop $e_2$ else
%% $e_3$}\index{if loop else@{\small if $\cdots$ loop $\cdots$ else $\cdots$}} is
%% equivalent to \ttQ{if not($e_1$) then $e_3$ loop $e_2$}.  The
%% conditional/loop\index{conditional loop construct, in ML@conditional/loop
%% construct, in \ML|)} construct can have a number of conditions, each preceded by
%% \ttQ{if}. The expression guarded by each condition may be preceded by
%% \ttQ{then}, or by \ttQ{loop} when the whole construct is to be re-evaluated
%% after evaluating the guarded expression:
%% \index{if then else@{\small if $\cdots$ then $\cdots$ else $\cdots$}|)}
%% \index{if then loop@{\small if $\cdots$ then $\cdots$ loop $\cdots$}|)}

%% \begin{session}
%% \begin{verbatim}
%% # let gcd(x,y) =
%% #     letref x,y = x,y
%% #     in     if x>y loop x:=x-y
%% #            if x<y loop y:=y-x
%% #            else x;;
%% gcd = - : ((int #  int) -> int)

%% # gcd(12,20);;
%% 4 : int
%% \end{verbatim}
%% \end{session}

% ----------------------------------------
\subsection {Lists}
\label{sec:lists}
% ----------------------------------------

If $e_1,\ldots,e_n$ all have type $ty$ then the \ML\ expression
\TTD{[$e_1$;$\ldots$;$e_n$]}\index{ lists, in ML@{\small\ml{[} $\cdots$ \ml{;}
$\cdots$ \ml{]}} (lists, in \ML)} has type \TTD{($ty$ List)}.  The standard
functions on lists are \TTD{hd} (head)\index{hd@\ml{hd}},
\TTD{tl}\index{tl@\ml{tl}} (tail), \TTD{null}\index{null@\ml{null}} (which
tests whether a list is empty -- i.e.\ is equal to \TTD{[]}), and the infixed
operators \TTD{.} (cons)\index{list constructor, in ML@list constructor, in \ML}
and \TTD{++}\index{list concatenation, in ML@list concatenation, in \ML} (append,
or concatenation).  The functions \ttQ{hd}, \ttQ{tl}, and \ttQ{null}
need to be imported to be usable.

\begin{session}
\emlsession
\begin{verbatim}
# m;;
m = [1; 2; 3; 4] : Int List

# (hd m , tl m);;
(1, [2; 3; 4]) : Int * (Int List)

# (null m , null []);;
(false, true) : Bool * Bool

# 0.m;;
[0; 1; 2; 3; 4] : Int List

# [1; 2] ++ [3; 4; 5; 6];;
[1; 2; 3; 4; 5; 6] : Int List

# [1;true;2];;
[ERROR]
kind:  type constructor clash between
       Int and Bool
slice: ⟨..[1; true; ⟨..⟩];;..⟩

[ERROR]
kind:  type constructor clash between
       Bool and Int
slice: ⟨..[⟨..⟩; true; 2];;..⟩

Untypable.
\end{verbatim}
\emlfile
\begin{verbatim}
import tl hd null;;
let m = [1;2;(2 + 1);4];;
\end{verbatim}
\emlend
\end{session}


All the members of a list must have the same type (although this type could
be a sum, or disjoint union type---see Section~\ref{sec:ML-types}).

% ----------------------------------------
\subsection {Atom}
% ----------------------------------------


A non-empty sequence of characters enclosed between token backquotes ({\verb%`%} -- i.e. ascii
96)\index{ string markers@{\small\verb+`+ $\cdots$ \verb+`+} (string markers, in
\ML)} is an {\em atom\/} (also called a {\em token\/}).

\begin{session}
\emlsession
\begin{verbatim}
# t;;
`an atom` : Atom

# ts;;
[`an`; `atom`; `list`] : Atom List

# ts = ``an atom`` ++ [`list`];;
true : Bool
\end{verbatim}
\emlfile
\begin{verbatim}
let t  = `an atom`;;
let ts = ``an atom list``;;
\end{verbatim}
\emlend
\end{session}

\noindent
The expression
\TTD{``atom{\subone}\,atom{\subtwo}{\ldots}atom{\subn}$\!$``} is an
alternative syntax
for \ttQ{[`atom{\subone}$\!$`;`atom{\subtwo}$\!$`;\ldots;`atom{\subn}$\!$`]}.

%% % ----------------------------------------
%% \subsection {Strings}
%% % ----------------------------------------

%% A sequence of characters enclosed between string quotes ({\verb%"%} --
%% i.e. ascii 34) is a {\em string\/}.

%% \begin{session}
%% \emlsession
%% \begin{verbatim}
%% # "this is a string";;
%% "this is a string" : string

%% # "";;
%% "" : string
%% \end{verbatim}
%% \emlfile
%% \emlend
%% \end{session}

%% Although similar, strings and tokens are implemented differently in Lisp;
%% strings are implemented as character arrays, and tokens as symbols.  The
%% implementation affects the efficiency of such operations as comparison and
%% concatenation; Tokens are much slower to concatenate, but faster to compare.


% ----------------------------------------
\subsection {Polymorphism}
% ----------------------------------------

\index{polymorphism, in ML@polymorphism, in \ML|(}
The list processing functions \ttQ{hd}\index{hd@\ml{hd}},
\ttQ{tl}\index{tl@\ml{tl}} etc.\ can be used on all types of lists.

\begin{session}
\emlsession
\begin{verbatim}
# hd [1;2;3];;
1 : Int

# hd [true;false;true];;
true : Bool

# hd [(1,2);(3,4)];;
(1, 2) : Int * Int
\end{verbatim}
\emlfile
\begin{verbatim}
import hd;;
\end{verbatim}
\emlend
\end{session}


\noindent
Thus \ttQ{hd} has several types; for example, it is used above with types
\ttQ{(Int List) -> Int},
\linebreak
\ttQ{(Bool List) -> Bool}, and \ttQ{(Int * Int) List -> (Int * Int)}.  In fact
if $ty$ is {\it any} type then \ttQ{hd} has the type \ttQ{($ty$ List) -> $ty$}.
Functions, like \ttQ{hd}, with many types are called {\em polymorphic\/}, and
\ML\ uses type variables\index{type variables, in ML@type variables, in \ML}
\TTD{'a}\index{ type variables, in ML@{\small\verb+*+, \verb+**+,$\ldots$} (type
variables, in \ML)}, \TTD{'b}, \TTD{'c} etc.\ to represent their
types\footnote{\EML, \SML\ and other such \ML-like programming
  languages use \ttQ{'a}, \ttQ{'b}, \ttQ{'c}, etc.\ to represent type
  variables, while \CML\ uses \TTD{*}, \TTD{**}, \TTD{***} etc.}.

\begin{session}
\emlsession
\begin{verbatim}
# hd;;
- : 'a List -> 'a

# map;;
- : ('a -> 'b) -> ('a List) -> 'b List

# map fact [1;2;3;4];;
[1; 2; 6; 24] : Int List
\end{verbatim}
\emlfile
\begin{verbatim}
import null;;

letrec fact n =
  if n = 0
  then 1
  else n * fact(n - 1);;

letrec map f l =
  if null l
  then []
  else f(hd l).map f (tl l);;
\end{verbatim}
\emlend
\end{session}

The \ML\ function \TTD{map}\index{map@\ml{map}} takes a function $f$
(with argument type \ttQ{'a} and result type \ttQ{'b}), and a list $l$
(of elements of type \ttQ{'a}), and returns the list obtained by
applying $f$ to each element of $l$ (which is a list of elements of
type \ttQ{'b}).  The function \ttQ{map} can be used at any instance of
its type: above, both \ttQ{'a} and \ttQ{'b} were instantiated to
\ttQ{Int}; below, \ttQ{'a} is instantiated to \ttQ{(Int List)} and
\ttQ{'b} to \ttQ{Bool}.  Notice that the instance need not be
specified; it is determined by the type checker\index{type checking,
  in ML@type checking, in \ML!inference involved in}.

\begin{session}
\emlsession
\begin{verbatim}
# map null [[1;2]; []; [3]; []];;
[false; true; false; true] : Bool List
\end{verbatim}
\emlfile
\begin{verbatim}
import null map;;
\end{verbatim}
\emlend
\end{session}
\index{polymorphism, in ML@polymorphism, in \ML|)}

% ----------------------------------------
\subsection {Lambda-expressions}
% ----------------------------------------

\index{lambda expressions, in ML@lambda expressions, in \ML|(}

The expression \TTD{{\bs}$x$.$e$}\index{ function abstraction binder, in
ML@{\small\verb+\+} (function abstraction binder, in \ML)} evaluates to a
function with formal parameter $x$ and body $e$. Thus the declaration \ttQ{let
$f$ $x$ = $e$} is equivalent to \ttQ{let $f$ = {\bs}$x$.$e$}.  Similarly \ttQ{let
$f$($x$,$y$) $z$ = $e$}\index{declarations, in ML@declarations, in \ML!relation
to function abstraction}\index{function abstraction, in ML@function abstraction,
in \ML!relation to declarations} is equivalent to \ttQ{let $f$ =
{\bs}($x$,$y$).{\bs}$z$.$e$}.
%% Repeated {\bs}'s, as in \ttQ {{\bs}($x$,$y$).{\bs}$z$.$e$} may be
%% abbreviated by \ttQ {{\bs}($x$,$y$) $z$.$e$}. The character {\bs} is our \ttQ{{\bs}$x$.$e$}
%% and \ttQ {{\bs}($x$,$y$) $z$.$e$} are called lambda-expressions.
The character {\bs} is our notation for a lambda.  The expressions
\ttQ{{\bs}$x$.$e$}
and \ttQ {{\bs}($x$,$y$).{\bs}$z$.$e$} are called lambda-expressions.
Lambda-expressions bind less tightly than anything else in the language.  For
example, \ttQ{\bs$x$.\ (\bs$y$.\ $y$) 1} means
\ttQ{\bs$x$.\ ((\bs$y$.\ $y$) 1)} not
\ttQ{(\bs$x$.\ (\bs$y$.\ $y$)) 1}

\begin{session}
\emlsession
\begin{verbatim}
# plus1;;
- : Int -> Int

# plus1 3;;
4 : Int

# map (\x.x * x) [1;2;3;4];;
[1; 4; 9; 16] : Int List

# doubleup;;
- : ('a List List) -> 'a List List

# doubleup [ [1]; [2;3] ];;
[[1; 1]; [2; 3; 2; 3]] : Int List List

# doubleup [];;
[] : 'a List List
\end{verbatim}
\emlfile
\begin{verbatim}
import map;;

let plus1 = \x. x + 1;;

let doubleup = map (\x.x ++ x)
;;
\end{verbatim}
\emlend
\end{session}
\index{lambda expressions, in ML@lambda expressions, in \ML|)}


%% % ----------------------------------------
%% \subsection {Failure}
%% % ----------------------------------------


%% Some standard functions {\em fail\/}\index{failure, in ML@failure, in \ML|(} at
%% run-time on certain arguments, yielding a string\index{strings, in ML@strings,
%% in \ML!to identify failures}\index{failure strings, in ML@failure strings, in
%% \ML|(} (which is usually the function name) to identify the sort of failure.  A
%% failure with token \ttQ{`$t$`} may also be generated explicitly by evaluating
%% the expression \TTD{failwith `$t$`} \index{failwith@\ttQ{failwith}} (or more
%% generally \ttQ{failwith $e$} where $e$ has type \ttQ{tok}).

%% \begin{session}
%% \begin{verbatim}
%% # hd(tl[2]);;
%% evaluation failed     hd

%% # 1/0;;
%% evaluation failed     div

%% # (1/0)+1000;;
%% evaluation failed     div

%% # failwith (hd [`a`;`b`]);;
%% evaluation failed     a
%% \end{verbatim}
%% \end{session}


%% A failure can be {\em trapped\/}\index{failure, in ML@failure, in \ML!trapping
%% of} by \TTD{?};\index{failure, in ML@failure, in \ML}\index{ failure trap, in
%% ML@{\small\verb+?+} (failure trap, in \ML)} the value of the expression
%% \TTD{$e_1$ ? $e_2$} is that of $e_1$, unless $e_1$ causes a failure, in which
%% case it is the value of $e_2$.

%% \begin{session}
%% \begin{verbatim}
%% # hd(tl[2]) ? 0;;
%% 0 : int

%% # (1/0)?1000;;
%% 1000 : int

%% # let half n =
%% #     if n=0 then failwith `zero`
%% #            else let m=n/2
%% #                 in  if n=2*m then m else failwith`odd`;;
%% half = - : (int -> int)
%% \end{verbatim}
%% \end{session}


%% The function \ttQ{half} only succeeds on non-zero even numbers; on \ttQ{0} it
%% fails with \ttQ{`zero`}, and on odd numbers it fails with \ttQ{`odd`}.

%% \begin{session}
%% \begin{verbatim}
%% # half 4;;
%% 2 : int

%% # half 0;;
%% evaluation failed zero

%% # half 3;;
%% evaluation failed odd

%% # half 3 ? 1000;;
%% 1000 : int
%% \end{verbatim}
%% \end{session}


%% Failures may be{\em trapped selectively\/}\index{failure, in ML@failure, in
%% \ML!selective trapping of} (on string) by \TTD{??};\index{ failure trap,
%% selective, in ML@{\small\verb+??+} (failure trap, selective, in \ML)} if $e_1$
%% fails with token $t$, then the value of \TTD{$e_1$ ??  [$t_1$;\ldots;$t_n$]
%% $e_2$} is the value of $e_2$ if $t$ is one of $t_1$,\ldots,$t_n$; otherwise the
%% expression fails with the value of $t$.

%% \begin{session}
%% \begin{verbatim}
%% # half(0) ?? [`zero`;`plonk`] 1000;;
%% 1000 : int

%% # half(1) ?? [`zero`;`plonk`] 1000;;
%% evaluation failed     odd
%% \end{verbatim}
%% \end{session}

%% \noindent
%% One may add several \ttQ{??} traps to an expression, and one may add a \ttQ{?}
%% trap at the end as~a~catch-all\index{failure, in ML@failure, in \ML!catch-all
%% trap for}.

%% \begin{session}
%% \begin{verbatim}
%% # half(1)
%% #   ??[`zero`] 1000
%% #   ??[`odd`]  2000;;
%% 2000 : int

%% # hd(tl[half(4)])
%% #   ??[`zero`] 1000
%% #   ??[`odd`]  2000
%% #   ? 3000;;
%% 3000 : int
%% \end{verbatim}
%% \end{session}


%% One may use \TTD{!}\index{ failure trap, iterative, in ML@{\small\verb+"!+}
%% (failure trap, iterative, in \ML)}\index{failure, in ML@failure, in
%% \ML!iterative trapping of} or \TTD{!!}\index{ failure trap, iterative selective,
%% in ML@{\small\verb+"!"!+} (failure trap, iterative selective, in
%% \ML)}\index{failure, in ML@failure, in \ML!iterative selective trapping of} in
%% place of \ttQ{?}  or \ttQ{??}  to cause re-iteration of the whole construct,
%% analogously to using \ttQ{loop} in place of \ttQ{then}.

%% \begin{session}
%% \begin{verbatim}
%% # let same(x,y) =
%% #     if x>y then failwith `greater`
%% #     if x<y then failwith `less`
%% #            else x;;
%% same = - : ((int #  int) -> int)

%% # let gcd(x,y) =
%% #     letref x,y = x,y
%% #     in  same(x,y)
%% #           !![`greater`] x:=x-y
%% #           !![`less`]    y:=y-x;;
%% gcd = - : ((int #  int) -> int)

%% # gcd(12,20);;
%% 4 : int
%% \end{verbatim}
%% \end{session}
%% \index{failure strings, in ML@failure strings, in \ML|)}
%% \index{failure, in ML@failure, in \ML|)}

%% % ----------------------------------------
%% \subsection {Type abbreviations}
%% % ----------------------------------------

%% Types can be given names:

%% \begin{session}
%% \index{lettype@{\small\verb+lettype+}}
%% \emlsession
%% \begin{verbatim}
%% # (12,20) : intpair;;
%% (12, 20) : Int * Int
%% \end{verbatim}
%% \emlfile
%% type intpair = Int * Int;;
%% \emlend
%% \end{session}


%% \noindent The new name is simply an abbreviation\index{type abbreviations!in
%% ML@in \ML}\index{types, in ML@types, in \ML!abbreviation of}\index{abbreviation
%% of types, in ML@abbreviation of types, in \ML}; for example, \ttQ{intpair} and
%% \ttQ{int \# int} are completely equivalent. The system always uses the most
%% recently defined name when printing types.

%% \begin{session}
%% \begin{verbatim}
%% # gcd;;
%% - : (intpair -> int)

%% # gcd p;;
%% 4 : int
%% \end{verbatim}
%% \end{session}


%% % ----------------------------------------
%% \subsection{Abstract types}
%% % ----------------------------------------

%% \index{types, in ML@types, in \ML!abstract|(}
%% \index{bindings, in ML@bindings, in \ML!abstract type|(}
%% \index{abstype with@\ttQ{abstype}$\ldots$\ttQ{with}$\ldots$|(}
%% \index{abstract types, in ML@abstract types, in \ML|(}

%% New types can also be defined by abstraction.  For example, to define a type
%% \ttQ{time} we could use the construct \TTD{abstype}:

%% \begin{session}
%% \begin{verbatim}
%% # abstype time = int #  int
%% #  with maketime(hrs,mins) = if  hrs<0 or 23<hrs or
%% #                               mins<0 or 59<mins
%% #                            then fail
%% #                            else abs_time(hrs,mins)
%% #  and hours t = fst(rep_time t)
%% #  and minutes t = snd(rep_time t);;
%% maketime = - : (intpair -> time)
%% hours = - : (time -> int)
%% minutes = - : (time -> int)
%% \end{verbatim}
%% \end{session}


%% This defines an abstract type \ttQ{time} and three primitive functions:
%% \ttQ{maketime}, \ttQ{hours} and \ttQ{minutes}.  In general, an abstract type
%% declaration has the form \TTD{abstype $ty$ = $ty'$ with $b$} where $b$ is a
%% binding, i.e.\ the kind of phrase that can follow \ttQ{let} or \ttQ{letrec}.
%% Such a declaration introduces a new type $ty$ which is represented by $ty'$.
%% Only within $b$ can one use the (automatically declared) functions
%% \TTD{abs\_$ty$}\index{abs_@{\small\verb+abs_+$\ldots$}} (of type \ttQ{$ty'$ ->
%% $ty$}) and \TTD{rep\_$ty$}\index{rep_@{\small\verb+rep_+$\ldots$}} (of type
%% \ttQ{$ty$ -> $ty'$}), which map between a type and its representation.  In the
%% example above \ttQ{abs\_time} and \ttQ{rep\_time} are only available in the
%% definitions of \ttQ{maketime}, \ttQ{hours} and \ttQ{minutes}; these latter three
%% functions, on the other hand, are defined throughout the scope of the
%% declaration. Thus an abstract type declaration simultaneously declares a new
%% type together with primitive functions for the type. The representation of the
%% type (i.e.\ $ty'$), and of the primitives (i.e.\ the right hand sides of the
%% definitions in $b$), is not accessible outside the \ttQ{with}-part of the
%% declaration.

%% \begin{session}
%% \begin{verbatim}
%% # let t = maketime(8,30);;
%% t = - : time

%% # hours t , minutes t;;
%% (8, 30) : intpair
%% \end{verbatim}
%% \end{session}


%% \noindent Notice that values of an abstract type are printed as
%% \ttQ{-}\index{non-printable values in ML@non-printable values in \ML}, like
%% functions.
%% \index{non-printable symbol, in ML@{\small\verb+-+} (`non-printable' symbol, in
%%         \ML)}
%% \index{printing, of ML@printing, of \ML!of abstract-typed values}
%% \index{abstract-typed values, in ML@abstract-typed values, in \ML!printing of}
%% \index{abstract types, in ML@abstract types, in \ML|)}
%% \index{abstype with@\ttq{abstype}$\ldots$\ttq{with}$\ldots$|)}
%% \index{bindings, in ML@bindings, in \ML!abstract type|)}
%% \index{types, in ML@types, in \ML!abstract|)}

% ----------------------------------------
\subsection {Type constructors}
% ----------------------------------------


Both \ttQ{List} and \ttQ{*} are examples of type constructors\index{type
constructors!in ML@in \ML|(}; \ttQ{List} has one argument (hence \ttQ{'a List})
whereas \ttQ{*} has two (hence \ttQ{'a * 'b}).  Each type constructor has
various primitive operations associated with it, for example \ttQ{List} has
\ttQ{null}, \ttQ{hd}, \ttQ{tl}, \ldots\ etc, and \ttQ{*} has \ttQ{fst},
\ttQ{snd}.
%% and the infix \ttQ{,}.

\begin{session}
\emlsession
\begin{verbatim}
# z;;
(8, 30) : Int * Int

# fst z;;
8 : Int

# snd z;;
30 : Int
\end{verbatim}
\emlfile
\begin{verbatim}
let z = (8,30);;
\end{verbatim}
\emlend
\end{session}


Another standard constructor of two arguments is \TTD{+}\index{ disjoint union
type operator, in ML@{\small\verb:+:} (disjoint union type operator, in \ML)};
\ttQ{'a + 'b} is the disjoint union\index{disjoint union, in ML@disjoint union,
in \ML} of types \ttQ{'a} and \ttQ{'b}, and associated with it are the following
primitives:

\index{isl@\ttq{isl}}
\index{inl@\ttq{inl}}
\index{isr@\ttq{isr}}
\index{inr@\ttq{inr}}
\index{outl@\ttq{outl}}
\index{outr@\ttq{outr}}
\bt\normalsize\tt
\e   isl  : ('a + 'b) -> bool    {\rm  tests membership of left summand}
\e   inl  : 'a -> ('a + 'b)      {\rm  injects into left summand}
\e   inr  : 'a -> ('b + 'a)      {\rm  injects into right summand}
\e   outl : ('a + 'b) -> 'a      {\rm  projects out of left summand}
\e   outr : ('a + 'b) -> 'b      {\rm  projects out of right summand}
\et

\noindent These are illustrated by:

\begin{session}
\emlsession
\begin{verbatim}
# x;;
inl(1) : Int + 'a

# y;;
inr(2) : 'a + Int

# isl x;;
true : Bool

# isl y;;
false : Bool

# outl x;;
1 : Int

# outl y;;
evaluation failed.

# outr x;;
evaluation failed.

# outr y;;
2 : Int
\end{verbatim}
\emlfile
\begin{verbatim}
let x = inl 1;;
let y = inr 2;;
\end{verbatim}
\emlend
\end{session}


%% Abstract types such as \ttQ{time} defined above can be thought of as type
%% constructors with no arguments (i.e.\ nullary constructors). The
%% \ttQ{abstype...with...} construct may also be used to define non-nullary type
%% constructors (with \TTD{absrectype} in place of \ttQ{abstype} if these are
%% recursive).  For example, trees analogous to LISP S-expressions could be defined
%% by:

%% \begin{session}
%% \begin{verbatim}
%% #  absrectype * sexp = * + (* sexp) #  (* sexp)
%% #    with cons(s1,s2) = abs_sexp (inr (s1,s2))
%% #    and car s = fst (outr(rep_sexp s))
%% #    and cdr s = snd (outr(rep_sexp s))
%% #    and atom s = isl(rep_sexp s)
%% #    and makeatom a = abs_sexp(inl a);;
%% cons = - : ((* sexp #  * sexp) -> * sexp)
%% car = - : (* sexp -> * sexp)
%% cdr = - : (* sexp -> * sexp)
%% atom = - : (* sexp -> bool)
%% makeatom = - : (* -> * sexp)
%% \end{verbatim}
%% \end{session}\index{type constructors!in ML@in \ML|)}
%%


\bigskip


% ------------------------------------------------------------------------------
\section{Syntax of \ML}
\label{sec:ML-syntax}
% ------------------------------------------------------------------------------

We shall use variables to range over the various constructs of \ML\ as
follows:

\begin{center}
\begin{tabular}{|l|l|}
  \hline
  Variable & Ranges over\\
  \hline
  $var$, $id$ & variables\\
  $con$       & constructors\\
  $ce$        & constant expressions\\
  $ty$        & types\\
% $tab$       & type abbreviation bindings (see~\ref{sec:ML-typeabbrev})\\
% $cb$        & concrete type bindings (see~\ref{sec:ML-concrete-types})\\
% $ab$        & abstract type bindings (see~\ref{sec:ML-abstract-types})\\
  $d$         & declarations\\
  $b$         & bindings\\
  $p$         & patterns\\
  $e$         & expressions\\
  \hline
\end{tabular}
\end{center}

Variables and constructors are both represented by identifiers but they are
different syntax classes.  Identifiers and constant expressions are described in
Section~\ref{sec:ML-ident} below.  Types and type-bindings are explained in
Section~\ref{sec:ML-types}.  Declarations, bindings, patterns and expressions
are defined by the following BNF-like\index{BNF syntax, explanation of} syntax
equations\index{syntax of ML@syntax of \ML!explanation of} in which:

\begin{enumerate}\vspace*{-2mm}\setlength{\itemsep}{0mm}

  \item Each variable ranges over constructs as above.

  \item The numbers following the various variables are there merely to
      	distinguish between different occurrences.
        %% ---this will be convenient when
      	%% we describe the semantics in Section~\ref{sec:ML-semantics}.

  \item \{$C$\} denotes an optional occurrence of $C$, and for $n{>}1$
      	\{{\tt$C_1$|$C_2$\ldots|$C_n$}\} denotes a choice of exactly one of
      	$C_1$,$C_2$,\ldots,$C_n$.

  \item The constructs are listed in order of decreasing binding
	power\index{precedence, in ML@precedence, in \ML}.

  \item `L' or `R' following a construct means that it
	associates\index{associativity, of constructs in ML@associativity, of
	constructs in \ML} to the left (L) or right (R) when juxtaposed with
	itself (where this is syntactically admissible).

  \item Certain constructs are equivalent to others and this is indicated by
	`equiv.'\index{equiv.} followed by the equivalent construct.
\end{enumerate}

% ----------------------------------------
\subsection{Syntax equations for ML}
% ----------------------------------------

Table~\ref{tab:ml-declarations} describes {\ML} declarations,
Table~\ref{tab:ml-bindings} bindings, Table~\ref{tab:ml-patterns} patterns, and
Table~\ref{tab:ml-expressions} on page~\pageref{tab:ml-expressions}
describes expressions.\\\smallskip

%---------------------------------------------------------------------
\begin{table}[h]
\centering\narrowlines\normalsize
\begin{tabular}{|rcp{50mm}p{5mm}p{52mm}|}
\hline
{\it d} &::= & {\tt let} {\it b}     & &  ordinary variables \\
% & $|$  & {\tt letref}  {\it b}     & &  assignable variables \\
  & $|$  & {\tt letrec}  {\it b}     & &  recursive functions \\[-0.8em]
  &      &                           & & \\
  & $|$  & {\tt infix} \{\{0$\mid$1$\mid$2$\mid$3$\mid$4$\mid$5$\mid$6$\mid$7\}\}   {\it id}
                                     & &  left associative infix directive \\
  & $|$  & {\tt infixr} \{\{0$\mid$1$\mid$2$\mid$3$\mid$4$\mid$5$\mid$6$\mid$7\}\}  {\it id}
                                     & &  right associative infix directive \\[-0.8em]
  &      &                           & & \\
  & $|$  & {\tt import}  $id_1$\ \ldots\ $id_n$
                                     & &  declaration import \\
% & $|$  & {\tt lettype} {\it tab}   & &  concrete types \\
% & $|$  & {\tt rectype} {\it cb}    & &  recursive concrete types \\[-0.8em]
% &      &                           & & \\
% & $|$  & {\tt abstype} {\it ab}    & & abstract types \\
% & $|$  & {\tt absrectype} {\it ab} & & recursive abstract types \\
\hline
\end{tabular}

\index{type variables, in ML@type variables, in \ML|(}
\index{variables, in ML@variables, in \ML!syntax of|(}
\index{ML@\ML!syntax of declarations in}
\index{declarations, in ML@declarations, in \ML!syntax of}
\index{type constraint!in ML@in \ML}
\index{let in@\ttQ{let} $\ldots$ \ttQ{in} $\ldots$!syntax of}
%% \index{letref in@\ttQ{letref} $\ldots$ \ttQ{in} $\ldots$!syntax of}
\index{letrec in@\ttQ{letrec} $\ldots$ \ttQ{in} $\ldots$!syntax of}
%% \index{rectype@\ttQ{rectype}}\index{types, in ML@types, in \ML!concrete}
\index{types, in ML@types, in \ML!abstract}
%% \index{absrectype@{\small\verb+absrectype+}$\ldots${\small\verb+with+}$\ldots$}

\caption{Declarations}
\label{tab:ml-declarations}
\end{table}
%---------------------------------------------------------------------

%---------------------------------------------------------------------
\begin{table}[h]
\centering\narrowlines\normalsize
\begin{tabular}{|rcp{50mm}p{5mm}p{52mm}|}  \hline
{\it b} & ::= & {\it p{\tt =}e}       	& & simple binding \\
  &  $|$  & {\it id\/} $p_{1}\ p_{2}\ \ldots\ p_{n}$
            \{{\tt :}{\it ty}\} {\tt =} {\it e}
                                     	& & function definition \\
%%  &  $|$  & {\tt $b_{1}$ and $b_{2}\ \ldots\ $and $b_{n}$}
%%					& & multiple binding \\
\hline
\end{tabular}
\index{ML@\ML!syntax of bindings in}
\index{bindings, in ML@bindings, in \ML!syntax of}
\index{ binding operator, in ML@{\small\verb+=+} (binding operator, in \ML)}
%%\index{and@{\small\verb+and+}}
\caption{Bindings}
\label{tab:ml-bindings}
\end{table}
%---------------------------------------------------------------------

%---------------------------------------------------------------------
\begin{table}[h]
\centering\narrowlines\normalsize
\begin{tabular}{|rcp{50mm}p{5mm}p{52mm}|}  \hline
{\it p} & ::= & {\tt ()}               &  &  unit \\
    & $|$ &  {\tt \_}                  &  &  empty pattern (widcard) \\
    & $|$ &  {\it id\/}                &  &  variable \\
    & $|$ &  {\it p{\tt :}ty}          &  &  type constraint \\
%%    & $|$ &  $p_{1}${\tt .}$p_{2}$     & R&  list cons \\
    & $|$ &  {\tt (}$p_{1}${\tt ,}$p_{2}${\tt )}     & R&  pairing \\[-0.8em]
    &     &                            &  & \\
%%    & $|$ &  {\tt []}                  &  &  empty list \\
%    & $|$ &  {\tt [$p_{1}$;$p_{2}\ \ldots\ $;$p_{n}$]}
%% %                                      &  &  list of $n$ elements \\[-0.8em]
%%    &     &                            &  & \\
    & $|$ &  {\tt ({\it p})}           &  &  equivalent to $p$ \\
    \hline
\end{tabular}
\index{ML@\ML!syntax of patterns in}
\index{patterns, in ML@patterns, in \ML!syntax of}
\index{wildcard, in ML@wildcard, in \ML}
\index{wildcard, in ML@{\small\verb+_+} (wildcard, in \ML)}
\index{type constraint!in ML@in \ML}
\index{type constraint, in ML@{\small\verb+:+} (type constraint, in \ML)}
%\index{list constructor, in ML@{\small\verb+.+}}
\index{pair constructor, in ML@{\small\verb+,+} (pair constructor, in \ML)}
\index{pairs, in ML@pairs, in \ML!syntax of}
%\index{list constructor, in ML@list constructor, in \ML!syntax of}
%\index{lists, in ML@lists, in \ML!syntax of}
\index{ brackets, in ML@{\small\verb+(+$\cdots$\verb+)+} (brackets, in \ML)}
\caption{Patterns}
\label{tab:ml-patterns}
\end{table}
%---------------------------------------------------------------------




In the syntax equations constructs are listed in order of decreasing binding
power\index{binding power, in ML@binding power, in \ML}.  For example, since
\ttQ{$e_1 e_2$} is listed before \ttQ{$e_1$\ +\ $e_2$} function
application binds
more tightly than addition and thus \ttQ{$e_1 e_2$\ +\ $e_3$} parses as
\ttQ{($e_1 e_2$)\ +\ $e_3$}.  This convention determines only the relative binding
power of different constructs.  The left or right
association\index{associativity, of constructs in ML@associativity, of
constructs in \ML} of a construct is indicated explicitly by `L' for left and
`R' for right.  For example, as application associates to the left, the
expression \ttQ{$e_1 e_2 e_3$} parses as \ttQ{($e_1 e_2$) $e_3$}.
%% , and since
%% \ttQ{$e_1$ => $e_2$ | $e_3$} associates to the right, the expression \ttQ{$e_1$
%% => $e_2$ | $e_3$ => $e_4$ | $e_5$} \index{case of@{\small\ttQ{case} $\cdots$
%% \ttQ{of} $\cdots$ \ttQ{"|} $\cdots$}!relation to abstraction} parses as
%% \ttQ{$e_1$ => $e_2$ | ($e_3$ => $e_4$ | $e_5$)}.
\smallskip

Only functions can be defined with \ttQ{letrec}. For example, \ttQ{letrec x =
2\ -\ x} would cause a syntax error.
\smallskip

All the variables occurring in a pattern must be distinct.  On the other hand, a
pattern can contain multiple occurrences of the unit pattern \ttQ{()}
or of the wildcard\index{wildcard, in
ML@wildcard, in \ML} \ttQ{\_}.
\smallskip

%---------------------------------------------------------------------
\begin{table}[p]
\centering\tightlines\normalsize
\begin{tabular}{|rcp{54mm}p{5mm}p{68mm}|}  \hline
{\it e} &  ::= & {\it ce}                &  & constant \\[-0.6em]
    &     &                              &  & \\
    & $|$ &  {\it var}                   &  & variable \\[-0.6em]
    &     &                              &  & \\
    & $|$ &  $e_{1}\ e_{2}$               &L & function application \\[-0.6em]
    &     &                              &  & \\
    & $|$ &  {\it e{\tt :}ty}            &  & type constraint \\[-0.6em]
    &     &                              &  & \\
    & $|$ &  {\tt !}{\it e}             &  & negation \\
    & $|$ &  {\tt $\sim$}{\it e}         &  & unary minus \\[-0.6em]
    &     &                              &  & \\
    & $|$ &  $e_{1}${\tt\ *\ }$e_{2}$     &L & multiplication \\
    & $|$ &  $e_{1}${\tt\ /\ }$e_{2}$     &L & division \\
    & $|$ &  $e_{1}${\tt\ +\ }$e_{2}$     &L & addition \\
    & $|$ &  $e_{1}${\tt\ -\ }$e_{2}$     &L & subtraction \\
    & $|$ &  $e_{1}${\tt\ .\ }$e_{2}$     &R & list cons \\
    & $|$ &  $e_{1}${\tt\ ++\ }$e_{2}$    &R & list append \\
    & $|$ &  $e_{1}${\tt\ =\ }$e_{2}$     &L & equality \\
    & $|$ &  $e_{1}${\tt\ <\ }$e_{2}$     &  & less than \\
    & $|$ &  $e_{1}${\tt\ >\ }$e_{2}$     &  & greater than \\
    & $|$ &  $e_{1}${\tt\ <=\ }$e_{2}$    &  & less or equal to \\
    & $|$ &  $e_{1}${\tt\ >=\ }$e_{2}$    &  & greater or equal to \\ [-0.6em]
    &     &                              &  & \\
    & $|$ &  $e_{1}${\tt\ \&\ }$e_{2}$    &R & conjunction \\
    & $|$ &  $e_{1}${\tt\ or\ }$e_{2}$    &R & disjunction \\[-0.6em]
    &     &                              &  & \\
    & $|$ &  $e_{1}${\it\ user-infix\ }$e_{2}$
                                         &L & user declared infix identifier \\[-0.6em]
    &     &                              &  & \\
    %% & $|$ &  $e_{1}${\tt =>}$e_{2}|e_{3}$ & R & equivalent to \ttQ{if $e_{1}$ then $e_{2}$ else $e_{3}$} \\[-0.6em]
    %% &     &                            &  & \\
    %% & $|$ &  {\tt do} {\it e}          &  &evaluate {\it e} for side effects \\[-0.6em]
    %% &     &                            &  & \\
    & $|$ &  {\tt (}$e_{1}${\tt ,}$e_{2}${\tt )}     &R & pairing \\[-0.6em]
    &     &                            &  & \\
    %% & $|$ &  $p${\tt :=}$e$            &  & assignment \\[-0.6em]
    %% &     &                            &  & \\
    %% & $|$ &  {\tt fail}                &  & equivalent to \ttQ{failwith 'fail'}\\
    %% & $|$ &  {\tt failwith e}          &  & failure with explicit token \\[-0.6em]
    %% &     &                            &  & \\
    %% & $|$\ & \begin{tabular}[t]{ll}
    %%            & {\tt if $e_{1}$ $\{$then$|$loop$\}$ $e_{1}'$} \\
    %%         \{ & {\tt if $e_{2}$ $\{$then$|$loop$\}$ $e_{2}'$} \\[-0.3em]
    %%            & \multicolumn{1}{c}{$\vdots$}  \\[-0.3em]
    %%            & {\tt if $e_{n}$ $\{$then$|$loop$\}$ $e_{n}'$} $\}$\\
    %%         \{ & \hspace*{10.5mm} $\{${\tt else$|$loop$\}$ $e_{n}''$} $\}$
    %%         \end{tabular}
    %%                                    &  & conditional and loop \\[-0.6em]
    %% &     &                            &  & \\
    %% & $|$ & \begin{tabular}[t]{ll}
    %%         {\it e} & {\tt $\{$??$|$!!$\}$ $e_{1}$ $e_{1}'$} \\
    %%             \{  & {\tt $\{$??$|$!!$\}$ $e_{2}$ $e_{2}'$} \\[-0.3em]
    %%                 & \multicolumn{1}{c}{$\vdots$}  \\[-0.3em]
    %%                 & {\tt $\{$??$|$!!$\}$ $e_{n}$ $e_{n}'$} \}\\
    %%             \{  & \{{\tt ?$|$!$|$?{\bs}$id|$!{\bs}$id$}\} $e_{n}''$ \}
    %%         \end{tabular}
    %%                                    &  & failure trap and loop \\[-0.6em]
    %% &     &                            &  & \\
    %% & $|$ &  {\tt $e_{1}$;$e_{2}\ \ldots\ $;$e_{n}$}
    %%                                    &  & sequencing \\[-0.6em]
    %% &     &                            &  & \\
    & $|$ &  {\tt if\ $e_{1}$\ then\ $e_{2}$\ else\ $e_{3}$}
                                       &  & conditional \\[-0.6em]
    &     &                            &  & \\
    & $|$ &  {\tt []}                  &  & empty list \\
    & $|$ &  {\tt [$e_{1}$;$e_{2}\ \ldots\ $;$e_{n}$]}
                                       &  & list of $n$ elements \\[-0.6em]
    &     &                            &  & \\
    & $|$ &  {\it e {\tt where} b}     &R &
                    equivalent to \ttQ{let {\it b} in {\it e}} \\[-0.6em]
    %% & $|$ &  {\it e {\tt whereref} b}     &R &
    %%                 equivalent to \ttQ{letref {\it b} in {\it e}} \\
    %% & $|$ &  {\it e {\tt whererec} b}     &R &
    %%                 equivalent to \ttQ{letrec {\it b} in {\it e}} \\
    %% & $|$ &  {\it e {\tt wheretype} db}    &  &
    %%                 equivalent to \ttQ{lettype {\it db} in {\it e}} \\
    %% & $|$ &  {\it e {\tt whereabstype} ab} &  &
    %%                 equivalent to \ttQ{abstype {\it ab} in {\it e}} \\
    %% & $|$ &  {\it e {\tt whereabsrectype} ab} &  &
    %%                 equivalent to \ttQ{absrectype {\it ab} in {\it e}} \\[-0.6em]
    &     &                            &  & \\
    %% & $|$ &  {\it d {\tt in} e}        &  & local declaration \\[-0.6em]
    & $|$ &  {\tt let\ $d$\ in\ $e$}   &  & local declaration \\[-0.6em]
    &     &                            &  & \\
    & $|$ &  $\backslash$ $p${\tt .}{\it e}
                                       &  & abstraction \\[-0.6em]
    &     &                            &  & \\
    & $|$ &  {\tt ($e$)}               &  & equivalent to \ttQ{\it e} \\
    \hline
\end{tabular}
\index{ML@\ML!syntax of expressions in|(}
\index{expressions, in ML@expressions, in \ML!syntax of}
\index{type variables, in ML@type variables, in \ML|)}
\index{variables, in ML@variables, in \ML!syntax of|)}
\index{function application, in ML@function application, in \ML!syntax of}
\index{type constraint!in ML@in \ML}
\index{ type constraint, in ML@{\small\verb+:+}}
\index{ minus, in ML@{\small\verb+-+} (minus, in \ML)}
\index{ multiplication, in ML@{\small\verb+*+} (multiplication, in \ML)}
\index{ division, in ML@{\small\verb+/+} (division, in \ML)}
\index{ addition, in ML@{\small\verb7+7} (addition, in \ML)}
\index{ subtraction, in ML@{\small\verb+-+} (subtraction, in \ML)}
\index{ less than, in ML@{\small\verb+<+} (less than, in \ML)}
\index{ greater than, in ML@{\small\verb+>+} (greater than, in \ML)}
\index{list constructor, in ML@list constructor, in \ML!syntax of}
\index{ list constructor, in ML@{\small\verb+.+} (list constructor, in \ML)}
\index{list concatenation, in ML@{\small\verb+"@+} (list concatenation, in \ML)}
\index{concatenation, of lists!in ML@in \ML}
\index{ equality, in ML@{\small\verb+=+} (equality, in \ML)}
\index{equality, in ML@equality, in \ML!syntax of}
\index{not@\ttQ{not}}
\index{conjunction, in ML@conjunction, in \ML}
\index{ conjunction, in ML@{\small\verb+&+}}
\index{or@\ttQ{or}}
\index{disjunction, in ML@disjunction, in \ML}
\index{do@\ttQ{do}}
\index{ pair constructor, in ML@{\small\verb+,+} (pair constructor, in \ML)}
\index{pairs, in ML@pairs, in \ML!syntax of}
\index{ assignment, in ML@{\small\verb+:=+} (assignment, in \ML)}
\index{assignments, in ML@assignments, in \ML!syntax of}
\index{fail@{\small\verb+fail+}}
\index{failwith@\ttQ{failwith}}
\index{if then else@{\small if $\cdots$ then $\cdots$ else $\cdots$}}
\index{if loop loop@{\small if $\cdots$ loop $\cdots$ loop $\cdots$}}
\index{if then loop@{\small if $\cdots$ then $\cdots$ loop $\cdots$}}
\index{if loop else@{\small if $\cdots$ loop $\cdots$ else $\cdots$}!syntax of}
\index{conditional loop construct, in ML@conditional/loop construct, in
	\ML!syntax of}
\index{conditional loop construct, in ML@conditional/loop construct, in \ML}
\index{failure, in ML@failure, in \ML!iterative selective trapping of}
\index{failure, in ML@failure, in \ML!iterative trapping of}
\index{failure, in ML@failure, in \ML!selective trapping of}
\index{failure, in ML@failure, in \ML!trapping of}
\index{ failure trap, selective, in ML@{\small\verb+??+} (failure trap,
	selective, in \ML)}
\index{ failure trap, iterative selective, in ML@{\small\verb+"!"!+} (failure trap, iterative selective, in \ML)}
\index{ failure trap, in ML@{\small\verb+?+} (failure trap, in \ML)}
\index{ failure trap, iterative, in ML@{\small\verb+"!+} (failure trap,
	iterative, in \ML)}
\index{ sequencing, in ML@{\small\verb+;+} (sequencing, in \ML)}
\index{sequencing!of {\ML} expressions@of \ML\ expressions}
\index{ lists, in ML@{\small\ttQ{[} $\cdots$ \ttQ{;} $\cdots$ \ttQ{]}} (lists,
	in \ML)}
\index{lists, in ML@lists, in \ML!syntax of}
\index{where@{\small\verb+where+}}
\index{whereref@{\small\verb+whereref+}}
\index{whererec@{\small\verb+whererec+}}
\index{whereabstype@{\small\verb+whereabstype+}}
\index{whereabsrectype@{\small\verb+whereabsrectype+}}
\index{in@{\small\verb+in+}}
\index{declarations, in ML@declarations, in \ML!local}
\index{let in@\ttQ{let} $\ldots$ \ttQ{in} $\ldots$!syntax of}
\index{letref in@\ttQ{letref} $\ldots$ \ttQ{in} $\ldots$!syntax of}
\index{letrec in@\ttQ{letrec} $\ldots$ \ttQ{in} $\ldots$!syntax of}
\index{ function abstraction binder, in ML@{\small\verb+\+} (function
	abstraction binder, in \ML)}
\index{function abstraction, in ML@function abstraction, in \ML!syntax of}
\index{function (pattern) selection abstraction, in ML@function (pattern)
	selection abstraction, in \ML}
\index{ brackets, in ML@{\small\verb+(+$\cdots$\verb+)+} (brackets, in \ML)}
\caption{Expressions}
\label{tab:ml-expressions}
\end{table}
%---------------------------------------------------------------------


Spaces\index{spaces!in {\ML} expressions@in \ML\ expressions} ({\small ASCII}
32)\index{ASCII@{\small ASCII}}, carriage returns\index{carriage return!in {\ML}
expressions@in \ML\ expressions} ({\small ASCII} 13), line feeds\index{line
feed!in {\ML} expressions@in \ML\ expressions} ({\small ASCII} 10) form
feeds\index{form feed!in {\ML} expressions@in \ML\ expressions} ({\verb%^L%},
{\small ASCII} 12) and tabs\index{tab!in {\ML} expressions@in \ML\ expressions}
({\verb%^I%}, {\small ASCII} 9) can be inserted and deleted arbitrarily without
affecting the meaning (as long as obvious ambiguities are not introduced).  For
example, the space in \ttQ{{\tt $\sim$} $x$} but not in
\ttQ{$x${\tt\ or\ }$y$} can be omitted.  {\em Comments\/}\index{comments, in
  ML@comments, in \ML}, which are arbitrary sequences of characters
surrounded by \TTD{(*} and \TTD{*)}\index{ comment markers, in ML@\per $\cdots$
  \per\ (comment markers, in \ML)}, can be inserted anywhere a space
is allowed.  Comments can be nested.

% --------------------------------------------------
\subsection{Identifiers and other lexical matters}
\label{sec:ML-ident}
% --------------------------------------------------

In this section the lexical structure of \ML\ is defined.

% --------------------------------
\subsubsection{Identifiers}
% --------------------------------

\index{alphanumerics, in ML@alphanumerics, in \ML|(}

A variable ({\em var\/}) or {\em identifier\/} is a sequence of
alphanumerics starting with a letter, where an alphanumeric is either
a letter, a digit, a prime ({\tt'}), a dash ({\tt-}) or an underbar
({\sl\_}).  \ML\ is case-sensitive: upper and lower case letters are
considered to be different.

% --------------------------------
\subsubsection{Constant expressions}
\label{MLconexp}
% --------------------------------

The \ML\ constant expressions ($ce$'s) used in Table \ref{tab:ml-expressions}
are:\index{constant expressions, in ML@constant expressions, in
\ML}\index{ML@\ML!constant expressions in}

\begin{enumerate}\setlength{\itemsep}{0mm}\vspace*{-2mm}

  \item Integers, i.e.\ sequences of digits {\tt 0,1...,9}\index{integers, in
	  ML@integers, in \ML}.

  \item Truth values {\tt true}\index{true in ML@\ttQ{true} in \ML} and
	{\tt false}\index{false@\ttQ{false}}.\index{truth values, in ML@truth
	values, in \ML}

  \item Tokens and token-lists:

        \begin{enumerate}\setlength{\itemsep}{0mm}\vspace*{-3mm}
          \item Tokens consist of any non-empty sequence of characters
            surrounded by token backquotes ({\tt `}), e.g.\
       	  {\tt `This is a single token`}.
          \item Token-lists consist of any sequence (possible empty)
            of tokens (separated by spaces, returns, line-feed or
            tabs) surrounded by double backquotes ({\tt ``}). e.g.\\
       	  {\tt ``this is a token-list containing 7 members``}.\\
          The token list
       	  {\tt `` tok1 tok2 ... tokn``} is equivalent to
       	  {\tt [`tok1`; `tok2`; ...; `tokn`]}.
        \end{enumerate}\vspace*{-2mm}

%% 	In any token or token-list, the occurrence of {\small\verb%\%}$x$ has
%% 	the following meanings for different $x$'s:
%% 	\smallskip

%% \setlength{\tabcolsep}{1.5mm}
%% \begin{tabular}{rcl}
%% {\verb%\0%} & = & ten spaces\index{spaces!in {\ML} strings@in \ML\ strings}\\
%% {\verb%\n%} & = & {\small\verb%n%} spaces (0$<${\small\verb%n%}$<$10)\\
%% {\verb%\S%} & = & one space\\
%% {\verb%\R%} & = & return\index{carriage return!in {\ML} strings@in \ML\ strings}\\
%% {\verb%\L%} & = & line-feed\index{line feed!in {\ML} strings@in \ML\ strings}\\
%% {\verb%\T%} & = & tab\index{tab!in {\ML} strings@in \ML\ strings}\\
%% {\verb%\x%} & = & {\small\verb%x%} taken literally otherwise
%% 		  (e.g.\ {\small\verb+\`+} to include token quotes in a token or
%% 		  token-list)\\
%% \end{tabular}

  %% \item Strings\index{strings, in ML@strings, in \ML}, consisting of any
  %%       sequence of characters surrounded by string quotes ({\verb%"%}),
  %%       e.g.\\ {\verb%"This is a single string"%}.\index{ string
  %%       markers@{\small\verb+"+ $\cdots$ \verb+"+} (string markers, in \ML)} Any
  %%       {\verb%"%} characters within a string must be preceded by
  %%       {\verb%\%}. The escape sequence {\verb%\%}$x$\index{ escape,
  %%       in {\ML} strings@{\small\verb+\+} (escape, in \ML\ strings)} for any
  %%       other character means always to insert the character $x$.

  \item The expression {\tt()}, called {\it unit\/}, which evaluates to the
        unique object of \ML\ type \ttQ{Unit}.
\end{enumerate}



% --------------------------------
\subsubsection{Prefixes and infixes}
% --------------------------------

\index{list constructor, in ML@list constructor, in \ML}
\index{not@\ttQ{not}}\index{do@\ttQ{do}}
\index{or@\ttQ{or}!not a dollared infix}
\index{ minus, in ML@{\small\verb+-+} (minus, in \ML)}
\index{ conjunction, in ML@{\small\verb+&+} (conjunction, in \ML)}
\index{ multiplication, in ML@{\small\verb+*+} (multiplication, in \ML)}
\index{ division, in ML@{\small\verb+/+} (division, in \ML)}
\index{ addition, in ML@{\small\verb7+7} (addition, in \ML)}
\index{ subtraction, in ML@{\small\verb+-+} (subtraction, in \ML)}
\index{ list concatenation, in ML@{\small\verb+"@+} (list concatenation, in \ML)|(}
\index{concatenation, of lists!in ML@in \ML}
\index{ list constructor, in ML@{\small\verb+.+} (list constructor, in \ML)}
\index{ equality, in ML@{\small\verb+=+} (equality, in \ML)}
\index{ less than, in ML@{\small\verb+<+} (less than, in \ML)}
\index{ greater than, in ML@{\small\verb+>+} (greater than, in \ML)}
\index{ pair constructor, in ML@{\small\verb+,+} (pair constructor, in \ML)}

Each infix operator has a precedence rated from 0 to 7 (a infix
operator with precedence $i$ binds tighter than an operator with
precedence $j$ if $j<i$), and is either left or right associative.

\index{prefixes, in ML@prefixes, in \ML|(}
The \ML\ {\it prefixes\/}\index{prefixes, in ML@prefixes, in \ML} $px$ and
{\it infixes\/}\index{infixes, in ML@infixes, in \ML} $ix$ are given by:

\begin{quote}\tt
  \begin{tabular}{rcl@{\hspace*{1.0in}}l}
   $px$ & ::= & !\ | $\sim$          & \\
   $ix$ & ::= & * | /               & (L, 7)\\
        & |   & + | -               & (L, 6)\\
        & |   & .\ | ++             & (R, 5)\\
        & |   & = | < | > | <= | >= & (L, 4)\\
        & |   & \& | or             & (R, 0)\\
  \end{tabular}
\end{quote}

In addition, any identifier (and certain single characters) can be made into an
infix.
%% Such user-defined infixes bind more tightly than
%% {\tt ...=>...|...} but more weakly than {\tt or}.
%% All of them
%% have the same power binding\index{precedence, in ML@precedence, in \ML!of
%% infixes, in ML@of infixes, in \ML}\index{precedence, in ML@precedence, in \ML!of
%% prefixes, in ML@of prefixes, in \ML} and associate\index{associativity, of
%% constructs in ML@associativity, of constructs in \ML!of infixes} to the left.

Except for {\tt\&} and {\tt or}, each
% infix $ix$ (or prefix $px$) has correlated
prefix $px$ has correlated
with it a special identifier \NOTION{\tt op $px$}
% (or {\tt\$$px$})
which is bound
to the associated function. For example, the identifier {\tt op +} is bound to the
addition function, and {\tt op ++} to the list-append function.
% (see Section~\ref{sec:ML-prims} for the meaning of dollared infixes).
This is useful
for passing functions as arguments; for example,
$f${\tt(op ++)}\index{concatenation, of lists!in ML@in \ML}\index{ list
concatenation, in ML@{\small\verb+"@+} (list concatenation, in \ML)|)} applies
$f$ to the append~function\index{ML@\ML!identifiers in|)}.

%% See the descriptions of the functions \ttQ{ml\_paired\_infix} and
%% \ttQ{ml\_curried\_infix} in Section~\ref{sec:ML-infixfns} for details of how to give
%% an identifier infix status.

\index{prefixes, in ML@prefixes, in \ML|)}


%% % ------------------------------------------------------------------------------
%% \section {Semantics of ML}
%% \label{sec:ML-semantics}
%% % ------------------------------------------------------------------------------

%% The evaluation\index{evaluation, of {\ML} constructs@evaluation, of \ML\
%% constructs} of all \ML\ constructs takes place in the context of an {\it
%% environment\/}\index{environments, in {\ML} evaluations@environments, in \ML\
%% evaluations} and a {\it store\/}\index{stores}.  The environment specifies what
%% the variables and constructors in use denote.  Variables\index{variables, in
%% ML@variables, in \ML} may be bound either to {\it values\/}\index{values, of
%% {\ML} variables@values, of \ML\ variables} or to {\it
%% locations\/}\index{locations}.  The contents of locations---which must be
%% values---are specified in the {\it store\/}.  If a variable is bound to a
%% location then (and only then) is it {\it assignable\/}\index{assignable
%% variables, in ML@assignable variables, in \ML}\index{variables, in ML@variables,
%% in \ML!assignable}.  Thus bindings are held in the environment, whereas location
%% contents are held in the store.  Constructors may only be bound to values
%% (constructor constants or constructor functions) and this binding occurs when
%% they are declared in a concrete type definition.
%% \smallskip

%% \noindent
%% The evaluation of \ML\ constructs may either {\it succeed\/} or {\it fail\/}.
%% In the case of success:

%% \begin{enumerate}\setlength{\itemsep}{0mm}\vspace*{-3mm}

%%   \item The evaluation of a declaration, $d$ say, changes the
%% 	bindings\index{scope!of bindings}\index{bindings, in ML@bindings, in
%% 	\ML!effect of declarations on} in the environment of the identifiers
%% 	declared in $d$.  If $d$ is at top-level\index{declarations, in
%% 	ML@declarations, in \ML!at top level}\index{top level, of ML@top level,
%% 	of \ML!declarations at}\index{ML@\ML!top level of}, then the
%% 	scope\index{bindings, in ML@bindings, in \ML!scope of} of the binding is
%% 	everything following $d$.  In \ttQ{$d$ in $e$} the scope of $d$
%% 	is the evaluation of $e$, and so when this is finished the environment
%% 	reverts to its original state (see Section~\ref{sec:ML-declarations}).

%%   \item The evaluation of an expression yields a value: the value of the
%% 	expression (see Section~\ref{sec:ML-expressions}).
%% \end{enumerate}\vspace*{-3mm}

%% \noindent
%% If an assignment is done during an evaluation, then the store will be
%% changed --- we shall refer to these changes as {\it side effects\/}\index{side
%% effects, in ML@side effects, in \ML} of the evaluation.

%% \index{failure, in ML@failure, in \ML|(} If the evaluation of a construct fails,
%% then failure is signalled, and a string is passed to the context which invoked
%% the evaluation.  This string is called the {\it failure string\/}, and it
%% normally indicates the cause of the failure.  During evaluation, failures may be
%% generated either {\it implicitly\/}\index{failure, in ML@failure, in
%% \ML!implicit} by certain error conditions, or {\it explicitly\/}\index{failure,
%% in ML@failure, in \ML!explicit} by the construct \ttQ{failwith
%% $e$}\index{failwith@\ttQ{failwith}} (which fails with $e$'s value as failure
%% string).  For example, the evaluation of the expression \ttQ{1/0} fails
%% implicitly with failure string \ttQ{`div`}, while that of \ttQ{failwith
%% `$str$`} fails explicitly with failure string \ttQ{`$str$`}.  We shall say two
%% evaluations fail {\it similarly\/}\index{failure, in ML@failure, in \ML!similar}
%% if they both fail with the same failure string.  For example, the evaluation of
%% \ttQ{1/0} and \ttQ{failwith `div`} fail similarly.  Side effects are not undone
%% by failures.

%% If during the evaluation of a construct a failure is generated, then unless the
%% construct is a failure trap (i.e.\ an expression built from \ttQ{?}  and/or
%% \ttQ{!}) the evaluation of the construct itself fails similarly.  Thus failures
%% propagate up until trapped, or reaching top level. For example, when evaluating
%% \ttQ{(1/0)+1000}, the expression \ttQ{1/0} is first evaluated, and the failure
%% which this evaluation generates causes the evaluation of the whole expression
%% (viz.\ \ttQ{(1/0)+1000}) to fail with \ttQ{`div`}.  On the other hand, the
%% evaluation of \ttQ{(1/0)?1000} traps the failure generated by the evaluation of
%% \ttQ{1/0}, and succeeds with value \ttQ{1000}. (In general, the evaluation of
%% \ttQ{$e_1$?$e_2$} proceeds by first evaluating $e_1$, and if this succeeds with
%% value $E$, then $E$ is returned as the value of \ttQ{$e_1$?$e_2$}; however, if
%% $e_1$ fails, then the result of evaluating \ttQ{$e_1$?$e_2$} is determined by
%% evaluating $e_2$).  \index{failure, in ML@failure, in \ML|)}

%% In describing evaluations\index{evaluation, of {\ML} constructs@evaluation, of
%% \ML\ constructs!control flow in}, when we say that we {\it pass control\/} to a
%% construct, we mean that the outcome of the evaluation is to be the outcome of
%% evaluating the construct.  For example, if when evaluating $e_1$\ttQ{?}$e_2$ the
%% evaluation of $e_1$ fails, then we pass control to $e_2$.

%% Expressions and patterns can be optionally decorated with types by writing
%% {\tt :$ty$}\index{ type constraint, in ML@{\small\verb+:+} (type
%% constraint, in \ML)} after them (e.g.\ \ttQ{[]:int list}).  The effect
%% of this is to force the type checker\index{type checking, in ML@type checking,
%% in \ML}\index{ML@\ML!type checking of} to assign an instance of the asserted
%% type to the construct; this is useful as a way of constraining types more than
%% the type checker would otherwise (i.e.\ more than context demands), and it can
%% also serve as helpful documentation.  Details of types and type checking are
%% given in Section~\ref{sec:ML-types}, and will be ignored in describing the
%% evaluation of \ML\ constructs in the rest of this section.

%% If we omit types, precedence information and those constructs which are
%% equivalent to others, then the syntax\index{syntax of ML@syntax of \ML!short
%% form}\index{ML@\ML!short form of syntax of} of \ML\ can be summarized by:

%% % --------------------------------------------------------------------
%% \begin{center}
%% \narrowlines\normalsize
%% \begin{tt}
%% \begin{tabular}{rcl} 
%% $d$ & ::= & let $b\ |\ $letref $b\ |\ $letrec $b$ \\
%%     &     & \\[-2mm]
%% $b$ & ::= & $p$=$e\ |\ {\it var}\  p_{l}\ p_{2}\ldots p_{n}$ = $e\ |\ 
%%             b_{l}$ and $b_{2} \ldots$ and $b_{n}$ \\
%%     &     & \\[-2mm] 
%% $p$ & ::= & () $\ |{\it var}\ |\ p_{l}$.$p_{2}\ |\ p_{l},p_{2}\ |\ $[]$\ |\ 
%%             $[$p_{l}$;$p_{2}\ldots$ ;$p_{n}$] \\
%%     &     & \\[-2mm]
%% $e$ & ::= & ${\it ce}\ |\ {\it var}\ |\ e_{1}\ e_{2}$ \\[-0.8em]
%%     &     & \\
%%     & $|$ & {\it px}$\ e\ |\ e_{1}\ {\it ix}\ e_{2}\ |\ v$:=$e\ |\ $
%%              failwith $e$ \\[-0.8em]
%%     &     & \\
%%     & $|$ & \begin{tabular}[t]{ll}
%%                & {\tt if $e_{1}$ $\{$then$|$loop$\}$ $e_{1}'$} \\
%%              \{& {\tt if $e_{2}$ $\{$then$|$loop$\}$ $e_{2}'$} \\[-0.3em]
%%                & \hspace*{10mm}\vdots  \\[-0.3em]
%%                & {\tt if $e_{n}$ $\{$then$|$loop$\}$ $e_{n}'$} \}\\
%% 	     \{& \hspace*{9.8mm} \{{\tt else$|$loop\} $e_{n}''$} \} 
%%             \end{tabular}  
%%             \\[-0.8em]
%%     &     & \\
%%     & $|$ & \begin{tabular}[t]{ll}
%%             {\it e} & {\tt $\{$??$|$!!$\}$ $e_{1}$ $e_{1}'$} \\
%%                \{   & {\tt $\{$??$|$!!$\}$ $e_{2}$ $e_{2}'$} \\[-0.3em]
%%                     & \hspace*{10mm}\vdots  \\[-0.3em]
%%                     & {\tt $\{$??$|$!!$\}$ $e_{n}$ $e_{n}'$} \}\\
%% 	       \{   & \{{\tt ?$|$!$|$?{\bs}$id|$!{\bs}$id$}\}  $e_{n}''$ \} 
%%             \end{tabular}  
%%             \\[-0.8em]
%%     &     & \\
%%     & $|$ & $e_{l}$;$e_{2}\ldots$;$e_{n}\ |\ $[] 
%%            $\ |\ $[$e_{l}$;$e_{2}\ldots$;$e_{n}$]$\ |\ d$ in $e$ \\[-0.8em]
%%     &     & \\
%%     & $|$ & {\bs}$p_1 p_2 \ldots p_n$.$e$\\
%% %s ::= begin {sn} I end {sn}
%% \end{tabular}
%% \end{tt}
%% \end{center}
%% % --------------------------------------------------------------------


%% \subsection{Declarations}\label{sec:ML-declarations}

%% Any declaration must be one of the three kinds: {\tt let $b$}, {\tt letref $b$}
%% or {\tt letrec $b$}, where $b$ is a binding.  Each such declaration is evaluated
%% by first evaluating the binding $b$ to produce a (possibly empty) set of
%% variable-value pairs, and then extending the environment (in a manner determined
%% by the kind of declaration) so that each variable in this set of pairs denotes
%% its corresponding value.  The evaluation of bindings is described below in
%% Section~\ref{sub:ML-eval-bindings}.

%% \begin {enumerate}\setlength{\itemsep}{0mm}\vspace*{-1mm}

%%   \item Evaluating {\tt let $b$}\index{let in@\ttQ{let} $\ldots$ %\ttQ{in}
%%         $\ldots$!evaluation of} declares the variables specified in $b$ to be an
%%         ordinary\index{ordinary variables, in ML@ordinary variables, in \ML}
%%         (i.e.\ non assignable) variable, and binds (in the environment) each one
%%         to the corresponding value produced by evaluating $b$.  To understand
%%         what are the variables defined in a declaration may require some
%%         knowledge about the environment.  For example, a declaration \ttQ{let
%%         $f$ $x$ = $e$} declares $x$ if $f$ is a constructor and declares $f$ as
%%         the function \ttQ{{\bs}$x$.$e$} otherwise.

%%   \item Evaluating {\tt letref $b$}\index{letref in@\ttQ{letref}
%% 	$\ldots$ \ttQ{in} $\ldots$!evaluation of} declares the variables
%% 	specified in $b$ to be assignable\index{assignable variables, in
%% 	ML@assignable variables, in \ML} and thus binds (in the environment)
%% 	each one to a new location, whose contents (in the store) is set to the
%% 	corresponding value.  The effect of subsequent assignments to the
%% 	variables will be to change the contents of the locations they are bound
%% 	to.  Bindings (in the environment) of variables to locations can only be
%% 	changed by evaluating another declaration to supersede the original~one.

%%   \item Evaluating {\tt letrec $b$}\index{letrec in@\ttQ{letrec} $\ldots$
%% 	\ttQ{in} $\ldots$!evaluation of} is similar to evaluating {\tt let $b$}
%% 	except that:

%%         \begin{enumerate}\setlength{\itemsep}{0mm}\vspace*{-2mm}
%%           \item The binding $b$ in {\tt letrec $b$} must consist only
%%         	of function definitions.
%%           \item These functions are made mutually recursive.
%%         \end{enumerate}\vspace*{-2mm}

%%         For example, consider:

%%         \begin{enumerate}\setlength{\itemsep}{0mm}\vspace*{-2mm}
%%           \item \ttQ{let f n = if n=0 then 1 else n*f(n-1)}
%%           \item \ttQ{letrec f n = if n=0 then 1 else n*f(n-1)}
%%         \end{enumerate}\vspace*{-2mm}

%%         The meaning of {\tt f} defined by the first case depends on whatever
%%         {\tt f} is bound\index{bindings, in ML@bindings, in \ML!in function
%%         definitions|(} before the declaration is evaluated, while the meaning
%%         of {\tt f} defined by the second case is independent of this (and is the
%%         factorial function).
%% \end{enumerate}
  
%% % ----------------------------------------
%% \subsubsection {The evaluation of bindings}
%% \label{sub:ML-eval-bindings}
%% % ----------------------------------------

%% \index{bindings, in ML@bindings, in \ML!evaluation of|(}

%% There are three kinds of variable binding each of which, when evaluated,
%% produces a set of variable-value pairs (or fails):
%% \index{bindings, in ML@bindings, in \ML!kinds of|(}

%% \begin {enumerate}\setlength{\itemsep}{0mm}\vspace*{-2mm}

%%   \item {\it Simple bindings}, \index{bindings, in ML@bindings, in \ML!simple}
%% 	\index{simple bindings, in ML@simple bindings, in \ML} which have the
%% 	form {\tt $p$=$e$} where $p$ is a pattern and $e$ an
%% 	expression\index{constant expressions, in ML@constant expressions, in
%% 	\ML}.

%%   \item {\it Function definitions}, \index{bindings, in ML@bindings, in
%% 	\ML!multiple} \index{multiple bindings, in ML@multiple bindings, in
%% 	\ML} which have the form {\tt $id$ $p_1 \ldots p_n$ = $e$}.
%% 	This is just an abbreviation for the simple binding {\tt $id$ =
%% 	{\bs}$p_1 \ldots p_n$.$e$}.

%%   \item {\it Multiple bindings}, which have the form {\tt $b_1$ and $b_2 \ldots$
%% 	and $b_n$} where $b_1,b_2 \ldots,b_n$ are simple bindings or function
%% 	definitions.  As a function definition is just an abbreviation for a
%% 	certain simple binding, each $b_i$ ($0{<}i{<}n{+}1$) either is, or is an
%% 	abbreviation for, some simple binding {\tt$p_i$=$e_i$}.  The multiple
%% 	binding {\tt $b_1$and $b_2 \ldots$ and $b_n$} then abbreviates {\tt
%% 	$p_1$,$p_2 \ldots$,$p_n$ = $e_1$, $e_2 \ldots e_n$}, which is a simple
%% 	binding.
%% \end {enumerate}\vspace*{-2mm}
%% \index{bindings, in ML@bindings, in \ML!kinds of|)}
%% \index{bindings, in ML@bindings, in \ML!evaluation of}

%% As function definitions and multiple bindings are abbreviations for simple
%% bindings we need only describe the evaluation of the latter.

%% A simple binding {\tt $p$=$e$} is evaluated by first evaluating $e$ to obtain a
%% value $E$ (if the evaluation fails then the evaluation of {\tt $p$=$e$} fails
%% similarly). Next the pattern $p$ is {\it matched\/}\index{matching, of patterns,
%% in ML@matching, of patterns, in \ML|(} with $E$ to see if they have the same
%% form (precise details are given in Section~\ref{matching-patterns}).  If so,
%% then to each identifier\index{variables, in ML@variables, in \ML!in expression
%% evaluation} in $p$ there is a corresponding component of $E$.  The evaluation of
%% {\tt $p$=$e$} then returns the set of each identifier paired with its
%% corresponding component.  If $p$ and $E$ do not match then the evaluation of
%% {\tt $p$=$e$} fails with failure token {\tt `MATCH`}.\index{bindings,
%% in ML@bindings, in \ML!in function definitions|)}\index{bindings, in
%% ML@bindings, in \ML!evaluation of|)}

%% % ----------------------------------------
%% \subsubsection {Matching patterns and expression values}
%% \label{matching-patterns}
%% % ----------------------------------------


%% \index{patterns, in ML@patterns, in \ML!matching with values|(}
%% \index{pattern matching, in {\ML} evaluations@pattern matching, in \ML\
%% evaluations|(}

%% When a pattern $p$ is matched with a value $E$, either the match succeeds and a
%% set of identifier-value pairs is returned (each identifier in $p$ being paired
%% with the corresponding component of $E$), or the match fails.  We describe, by
%% cases on $p$, the conditions for $p$ to match $E$ and the sets of
%% pairs~returned:

%% \begin{description}\setlength{\itemsep}{0mm}\vspace*{-2mm}

%%   \item [\ttQ{()}: ]
%% 	\index{wildcard, in ML@wildcard, in \ML}
%% 	\index{wildcard, in ML@{\small\verb+()+} (wildcard, in \ML)}

%% 	Always matches $E$. The empty set of pairs is returned.

%%   \item [\ttQ{$var$}: ]
%% 	\index{identifiers, in ML@identifiers, in \ML!in expression evaluation}
%% 	\index{type variables, in ML@type variables, in \ML}

%% 	Always matches $E$.  The set consisting of $var$ paired with $E$ is
%% 	returned. 

%%   \item [\ttQ{$p_1$.$p_2$}: ] 

%% 	$E$ must be a non-empty list {\tt$E_1$.$E_2$} such that $p_1$ matches
%% 	$E_1$ and $p_2$ matches $E_2$.  The union of the sets of pairs returned
%% 	from matching $p_1$ with $E_1$ and $p_2$ with $E_2$ is returned.

%%   \item [\ttQ{$p_1$,$p_2$}: ]
%% 	\index{pairs, in ML@pairs, in \ML!in expression evaluation} 

%% 	$E$ must be a pair {\tt$E_1$,$E_2$} such that $p_1$ matches $E_1$ and
%% 	$p_2$ matches $E_2$.  The union of the sets of pairs returned from
%% 	matching $p_1$ with $E_1$ and $p_2$ with $E_2$ is returned.

%%   \item [\ttQ{[$p_1$;$p_2 \ldots$;$p_n$]}: ]
%% 	\index{lists, in ML@lists, in \ML!in expression evaluation}
%% 	\index{list constructor, in ML@list constructor, in \ML!in expression
%% 	evaluation}

%% 	 $E$ must be a list {\tt[$E_1$;$E_2 \ldots$;$E_n$]} of length $n$ such
%% 	that for each $i$ $p_i$ matches $E_i$. The union of the sets of pairs
%% 	returned by matching $p_i$ with $E_i$ is produced.
%% \end {description}

%% Thus if $p$ matches $E$, then $p$ and $E$ have a similar `shape', and each
%% identifier in $p$ corresponds to some component of $E$ (namely that component
%% paired with the identifier in the set returned by the match).  Here are some
%% examples:

%% \begin{enumerate}\setlength{\itemsep}{0mm}\vspace*{-2mm}

%%   \item \ttQ{[$x$;$y$;$z$]} matches \ttQ{[1;2;3]} with $x$, $y$ and
%% 	$z$ corresponding to \ttQ{1}, \ttQ{2}, and \ttQ{3} respectively.

%%   \item \ttQ{[$x$;$y$;$z$]} does not match \ttQ{[1;2]} or \ttQ{[1;2;3;4]}.

%%   \item \ttQ{$x$.$y$} matches \ttQ{[1;2;3]} with $x$ and $y$ corresponding to 
%% 	\ttQ{1} and \ttQ{[2;3]} respectively, because
%% 	\ttQ{$E_1$.[$E_2$;$E_3$\ldots;$E_n$]} =
%% 	\ttQ{[$E_1$;$E_2$;$E_3$\ldots;$E_n$]}. 

%%   \item \ttQ{$x$.$y$}  does not match \ttQ{[]} or \ttQ{1,2}.

%%   \item \ttQ{$x$,$y$} matches \ttQ{1,2} with $x$ and $y$ corresponding to
%% 	\ttQ{1} and \ttQ{2}  respectively.

%%   \item \ttQ{$x$,$y$}  does not match \ttQ{[1;2]} .

%%   \item \ttQ{($x$,$y$),[($z$.$w$);()]} matches \ttQ{(1,2),[[3;4;5];[6;7]]}
%% 	with $x$, $y$, $z$ and $w$ corresponding to  \ttQ{1}, \ttQ{2}, \ttQ{3},
%% 	and \ttQ{[4;5]} respectively.
%% \end{enumerate}

%% \index{matching, of patterns, in ML@matching, of patterns, in \ML|)}
%% \index{pattern matching, in {\ML} evaluations@pattern matching, in \ML\
%% 	evaluations|)} 
%% \index{patterns, in ML@patterns, in \ML!matching with values|)}

%% % ----------------------------------------
%% \subsection {Expressions}
%% \label{sec:ML-expressions}
%% % ----------------------------------------

%% \index{expressions, in ML@expressions, in \ML!evaluation of|(}

%% If the evaluation of an expression terminates\index{evaluation, of {\ML}
%% constructs@evaluation, of \ML\ constructs!termination of}, then either it
%% succeeds with some value, or it fails\index{failure, in ML@failure, in
%% \ML}\index{failure, in ML@failure, in \ML!side effects of}; in either case
%% assignments performed during the evaluation may cause side effects\index{side
%% effects, in ML@side effects, in \ML}.  If the evaluation succeeds with some
%% value we shall say that value is {\it returned\/}.

%% We shall describe the evaluation of expressions by considering the various
%% cases, in the order in which they are listed in the syntax equations.


%% \begin{description}\setlength{\itemsep}{0mm}\vspace*{-2mm}

%%   \item [\ttQ{$ce$}: ] 
%% 	\index{constant expressions, in ML@constant expressions, in \ML} 

%% 	The appropriate constant value is returned. 

%%   \item [\ttQ{$var$}: ] 
%% 	\index{identifiers, in ML@identifiers, in \ML!evaluation of}
%% 	\index{type variables, in ML@type variables, in \ML}        
%% 	\index{variables, in ML@variables, in \ML!evaluation of}    
%% 	\index{variables, in ML@variables, in \ML!ordinary}         
%% 	\index{ordinary variables, in ML@ordinary variables, in \ML}

%% 	The value associated with $var$ is returned.  If $var$ is ordinary, then
%% 	the value returned is the value bound to $var$ in the
%% 	environment\index{environments, in {\ML} evaluations@environments, in
%% 	\ML\ evaluations|(}.  If $var$ is assignable, then the value returned is
%% 	the contents of the location to which $var$ is bound.

%%   \item [\ttQ{$e_1$ $e_2$}: ]
%% 	\index{combinations, in ML@combinations, in \ML}
%% 	\index{function application, in ML@function application, in
%% 	\ML!evaluation of}

%% 	$e_1$ and $e_2$ are evaluated and the result of applying the value of
%% 	$e_1$ (which must be a function) to that of $e_2$ is returned. Due to
%% 	optimizations in the \ML\ compiler, the order of evaluation may vary.

%%   \item [\ttQ{$px$ $e$}: ]
%% 	\index{prefixes, in ML@prefixes, in \ML}

%% 	$e$ is evaluated and then the result of applying $px$ to the value of
%% 	$e$ is returned.  \ttQ{-$e$} and \ttQ{not $e$} have the obvious
%% 	meanings; \ttQ{do $e$} evaluates $e$ for its side effects\index{side
%% 	effects, in ML@side effects, in \ML} and then returns \ttQ{()}.

%%   \item [\ttQ{$e_1$ $ix$ $e_2$}: ]
%% 	\index{infixes, in ML@infixes, in \ML}

%% 	\index{conjunction, in ML@conjunction, in %\ML}
%% 	\index{ conjunction, in ML@{\small\verb+&+} %(conjunction, in \ML)}

%% 	\ttQ{$e_1$ \& $e_2$} is equivalent to \ttQ{if $e_1$ then $e_2$ else
%% 	false}, so sometimes only $e_1$ needs be evaluated to evaluate
%% 	\ttQ{$e_1$ \& $e_2$}.
%% 	\
%% 	\index{disjunction, in ML@disjunction, in \ML}
%% 	\index{or@\ttQ{or}}
%% 	\
%% 	\ttQ{$e_1$ or $e_2$} is equivalent to \ttQ{if $e_1$ then true else
%% 	$e_2$}, so sometimes only $e_1$ needs to be evaluated to evaluate
%% 	\ttQ{$e_1$ or $e_2$}.

%% 	In all other cases $e_1$ and $e_2$ are evaluated (in that order) and the
%% 	result of applying $ix$ to their two values is returned.
%% 	\
%% 	\index{pairs, in ML@pairs, in \ML!evaluation of}
%% 	\index{pair constructor, in ML@{\small\verb+,+} (pair constructor, in
%% 			\ML)}
%% 	\
%% 	\ttQ{$e_1$,$e_2$} returns a pair whose first component is the value of
%% 	$e_1$, and whose second component is the value of $e_2$. The meaning of
%% 	the other infixes are given in Section~\ref{sec:ML-prims}.

%%   \item [\ttQ{$p$:=$e$}: ]
%% 	\index{assignments, in ML@assignments, in \ML!evaluation of}
%% 	\index{ assignment, in ML@{\small\verb+:=+} (assignment, in \ML)}

%% 	Every variable in $p$ must be assignable\index{assignable variables, in
%% 	ML@assignable variables, in \ML}\index{variables, in ML@variables, in
%% 	\ML!assignable} and bound to some location\index{locations} in the
%% 	environment.  The effect of the assignment is to update the contents of
%% 	these locations (in the store)\index{stores} with the values
%% 	corresponding to the variables produced by evaluating the binding {\tt
%% 	$p$=$e$} (see Section~\ref{sub:ML-eval-bindings}).  If the evaluation of $e$
%% 	fails, then no updating of locations occurs, and the assignment fails
%% 	similarly.  If the matching to $p$ fails, then the assignment fails with
%% 	{\tt `MATCH`}. The value of \ttQ{$p$:=$e$} is the value of $e$.

%%   \item [\ttQ{failwith $e$}: ]
%% 	\index{failure, in ML@failure, in \ML|(}
%% 	\index{failure, in ML@failure, in \ML!constructs for|(}
%% 	\index{failwith@\ttQ{failwith}}

%% 	$e$ is evaluated and then a failure with $e$'s value (which must be a
%%  	token) is generated.



%%   \item [\parbox{43mm}{\tt
%% 	 if $e_1$ $\{$then|loop$\}$ $e_{1}'$\\
%%          \hspace*{-2mm}$\{$if $e_2$ \{then|loop$\}$ $e_{2}'$\\[-0.3em]
%%          \hspace*{5mm} \vdots			\\[-0.3em]
%%          if $e_n$ \{then|loop$\}$ $e_{n}'$\,$\}$\\
%%          \hspace*{8mm}$\{$ \{else|loop\} $e'$ $\}$}: ]

%% 	\index{evaluation, of {\ML} constructs@evaluation, of \ML\
%% 		constructs!control flow in|(}
%% 	\index{if loop else@{\small if $\cdots$ loop $\cdots$ else
%% 		$\cdots$}!evaluation of|(}
%% 	\index{if loop loop@{\small if $\cdots$ loop $\cdots$ loop $\cdots$}|(}
%% 	\index{if then else@{\small if $\cdots$ then $\cdots$ else $\cdots$}}
%% 	\index{if then loop@{\small if $\cdots$ then $\cdots$ loop $\cdots$}}
%% 	\index{conditional loop construct, in ML@conditional/loop construct, in
%% 		\ML!evaluation of}
%% 	\hfill
%% 	\begin{minipage}{115mm}
%% 	  $e_1$, $e_2$,\ldots,$e_n$ are evaluated in turn until one of them, say
%% 	  $e_m$, returns \ttQ{true} (each $e_i$ must be a boolean expression).
%% 	  When the phrase following $e_m$ is \ttQ{then $e_{m}'$} control is
%% 	  passed to $e_{m}'$. However, when the phrase is \ttQ{loop $e_{m}'$}
%% 	  then $e_{m}'$ is evaluated for its side effects, and then control is
%% 	  passed back to the beginning of the whole expression again (i.e.\ to
%% 	  the beginning of \ttQ{if $e_1 \ldots$}).
%% 	\end{minipage}

%% 	In the case that all of $e_1$,$e_2 \ldots$,$e_n$ return \ttQ{false} and
%% 	there is a phrase following $e_{n}'$, then if this is \ttQ{else $e'$}
%% 	control is passed to $e'$, while if it is \ttQ{loop $e'$} then $e'$ is
%% 	evaluated for its side effects and control is then passed back to the
%% 	beginning of the whole expression again.

%% 	In the case that all of $e_1$,$e_2 \ldots$,$e_n$ return \ttQ{false}, but
%% 	no phrase follows $e_{n}'$ then \ttQ{()}, the unique value of type
%% 	\ttQ{void}  is returned.
%% 	\index{void@\ttQ{void}}
%% 	\index{if loop else@{\small if $\cdots$ loop $\cdots$ else
%% 		$\cdots$}!evaluation of|)}
%% 	\index{if loop loop@{\small if $\cdots$ loop $\cdots$ loop $\cdots$}|)}
%% 	\medskip

%%   \item [\parbox{38mm}{\tt
%% 	  $e$ \{??|!!\} $e_{1} e_{1}'$	\\
%% 	  \e$\{$ \{??|!!\} $e_2 e_{2}'$	\\[-0.3em]
%%           \hspace*{5mm} \vdots		\\[-0.3em]
%% 	  \hspace*{2mm} \{??|!!\} $e_n e_{n}'$  $\}$  \\
%% 	  \e$\{$ \{?|!|?{\bs}$id$|{\bs}$id$\} $e'$\,$\}$}: ]

%% 	\hfill
%% 	\begin{minipage}{122mm}
%% 	  $e$ is evaluated and if this succeeds its value is returned.
%% 	  \
%% 	  \index{strings, in ML@strings, in \ML!to identify failures}
%% 	  \index{failure, in ML@failure, in \ML!iterative selective trapping of}
%% 	  \index{failure, in ML@failure, in \ML!iterative trapping of}
%% 	  \index{failure, in ML@failure, in \ML!selective trapping of}
%% 	  \index{failure, in ML@failure, in \ML!trapping of}
%% 	  %
%% 	  If $e$ fails with failure token $tok$, then each of
%% 	  $e_1$,$e_2 \ldots$,$e_n$ are evaluated in turn until one of them, say
%% 	  $e_m$, returns a token list containing $tok$ (each $e_i$ must be a
%% 	  token).  If \ttQ{??}  immediately precedes $e_m$, then control is
%% 	  passed to $e_{m}'$. If \ttQ{!!}  precedes it, then $e_{m}'$
%% 	  is evaluated and control is passed back to the beginning of the
%% 	  whole expression \ttQ{$e$ \{??|!!\} \ldots}.
%% 	\end{minipage}

%% 	If none of $e_1$,$e_2 \ldots,e_n$ produces a token list containing
%% 	$tok$, and \ttQ{?{\bs}$e'$} follows $e_{n}'$, then control is
%% 	passed to $e'$.  But if \ttQ{!{\bs}$e'$} follows $e_{n}'$, then
%% 	$e'$ is evaluated, and control is passed back to the beginning of the
%% 	whole expression.

%% 	If \ttQ{?{\bs}$id$ $e'$} or \ttQ{?{\bs}$id$ $e'$} follows $e_{n}'$, then $e'$
%% 	is evaluated in an environment in which $id$ is bound to the failure
%% 	string $tok$ (i.e.\ an evaluation equivalent to \ttQ{let $id$=$tok$ in
%% 	$e'$} is done), and then depending on whether a \ttQ{?} of a \ttQ{!}
%% 	occurred, the value of $e'$ is returned or control is passed back to the
%% 	beginning of the whole expression respectively.

%% 	\index{evaluation, of {\ML} constructs@evaluation, of \ML\
%% 		constructs!control flow in|)}
%% 	\index{failure, in ML@failure, in \ML!constructs for|)}
%% 	\index{failure, in ML@failure, in \ML|)}


%% 	If none of $e_1$,$e_2 \ldots$,$e_n$ returns a token list containing
%% 	$tok$ and nothing follows $e_{n}'$, then the whole expressions fails
%% 	with $tok$.

%%   \item [\ttQ{$e_1$;$e_2 \ldots$;$e_n$}: ]
%% 	\index{sequences, in ML@sequences, in \ML}
%% 	\index{sequencing!of {\ML} expressions@of \ML\ expressions}

%% 	$e_1$,$e_2 \ldots$,$e_n$ are evaluated in that order, and the value of
%% 	$e_n$ is returned.

%%   \item [\ttQ{[$e_1$;$e_2 \ldots$;$e_n$]}: ]
%% 	\index{lists, in ML@lists, in \ML!evaluation of}

%% 	$e_1,e_2, \ldots ,e_n$ are evaluated in that order and the list of their
%% 	values returned.  \ttQ{[]} evaluates to the empty list.

%%   \item [\ttQ{$d$ in $e$}: ]
%% 	\index{let in@\ttQ{let} $\ldots$ \ttQ{in} $\ldots$!evaluation of}
%% 	\index{letref in@\ttQ{letref} $\ldots$ \ttQ{in} $\ldots$!evaluation of}
%% 	\index{letrec in@\ttQ{letrec} $\ldots$ \ttQ{in} $\ldots$!evaluation of}
%% 	\index{declarations, in ML@declarations, in \ML!evaluation of}
%% 	\index{declarations, in ML@declarations, in \ML!local}

%% 	$d$ is evaluated and then $e$ is evaluated in the extended environment
%% 	and its value returned.  The declaration $d$ is local to $e$, so that
%% 	after the evaluation of $e$, the former environment is restored.

%%   \item [\ttQ{{\bs}$p_1 p_2 \ldots p_n$.$e$}: ]
%% 	\index{function abstraction, in ML@function abstraction, in
%% 		\ML!evaluation of}
%% 	\index{function abstraction binder, in ML@{\small\verb+\+} (function
%% 		abstraction binder, in \ML)}

%% 	The evaluation of lambda-expressions always succeeds and yields a
%% 	function value.  The environment in which the evaluation occurs (i.e.\
%% 	in which the function value is created) is called the {\it definition
%% 	environment\/}.

%% 	\begin{enumerate}\vspace*{-2.5mm}
%% 	  \item {\em Simple lambda-expressions\/}: \ttQ{{\bs}$p$.$e$}
%% 		evaluates to that function which, when applied to some argument
%% 		yields the result of evaluating $e$ in the current (i.e.\
%% 		application time) store, and in the environment obtained from
%% 		the definition environment by binding any variables in $p$ to
%% 		the corresponding components of the argument (see
%% 		Section~\ref{sub:ML-eval-bindings}).

%% 	  \item {\em Compound lambda-expressions\/}:
%% 		A lambda-expression with more than one parameter is curried,
%% 		\index{currying, in ML@currying, in \ML}
%% 		i.e.\ \ttQ{{\bs}$p_1 p_2 \ldots p_n$.$e$} is
%% 		equivalent to \ttQ{{\bs}$p_1$. ({\bs}$p_2$.\ldots {\bs}$p_n$.$e$)\ldots}.
%% 	\end{enumerate}\vspace*{-2.5mm}
%% 	\index{free variables, in ML@free variables, in \ML!binding of}

%% 	Thus the free variables in a function keep the same binding they had in
%% 	the definition environment.  So if a free variable is non-assignable in
%% 	that environment, then its value is fixed to the value it has there.  On
%% 	the other hand, if a free variable is assignable in the definition
%% 	environment, then it will be bound to a location. Although that binding
%% 	is fixed, the contents of the location in the store is not, and can be
%% 	subsequently changed with assignments.
%% \end{description}

%% \index{expressions, in ML@expressions, in \ML!evaluation of|)}
%% \index{environments, in {\ML} evaluations@environments, in \ML\ evaluations|)}


% ------------------------------------------------------------------------------
\section{{\ML} Types}
\label{sec:ML-types}
% ------------------------------------------------------------------------------


So far, little mention has been made of types.  For \ML\ in its original role as
the meta-language for proof in \LCF, the importance of strict type
checking\index{type checking, in ML@type checking, in \ML!reasons for} was
principally to ensure that every computed value of the type representing
theorems was indeed a theorem.

The same effect could probably have been achieved by run-time type checking, but
compile-time type checking was adopted instead, in the design of \ML.  This was
partly for the considerable debugging aid that it provides; partly for efficient
execution; and partly to explore the possibility of combining polymorphism with
type checking.  This last reason is of general interest in programming languages
and has nothing to do specifically with proof; the problem is that there are
many operations (list mapping functions, functional composition, etc.) which
work at an infinity of types, and therefore their types should somehow be
parameterized -- but it is rather inconvenient to have to mention the particular
type intended at each of their uses.

The \ML\ type checking system is implemented in such a way that, although the
user may occasionally (either for documentation or as a constraint) ascribe a
type to an \ML\ expression or pattern, it is hardly ever necessary to do so.
The user of \ML\ will almost always be content with the types ascribed and
presented by the type checker, which checks every top-level phrase before it is
evaluated.  (The type checker may sometimes find a more general type assignment
than expected.)

% ----------------------------------------
\subsection {Types and objects}
% ----------------------------------------

\index{polymorphism, in ML@polymorphism, in \ML}

Every data object in \ML\ possesses a type. Such an object may possess
many types, in which case it is said to be {\it polymorphic\/} and
possesses a {\it polytype\/} -- i.e.\ a type containing type variables
% (for which we use a sequence of asterisks possibly followed by an identifier or integer)
(for which we use an identifier followed by at least one quote)
-- and moreover it possesses all types which are {\it instances\/} of
its polytype, formed by substituting types for zero or more type
variables in the polytype. A type containing no type variables is a
{\it monotype.}

We saw several examples of types in Section~\ref{sec:ML-intro}.  To
understand the following syntax, note that \ttQ{List} is a postfixed
unary (one-argument) type constructor (thereafter abbreviated to
$tycon$).  The user may introduce new $n$-argument type constructors.
A binary type operator {\tt directory}, for example, can be
introduced.  The following type expressions will then be types of
different kinds of {\tt directory}:

\begin{itemize}\tt\setlength{\itemsep}{0mm}\vspace*{-2mm}
  \item (Atom, Int) directory
  \item (Int, Int -> Int) directory
\end{itemize}\vspace*{-2mm}

\noindent
The user may even deal with lists of directories, with the type
{\tt (Int, Bool) directory List}


% ----------------------------------------
\subsubsection{The syntax of types}
% ----------------------------------------

\index{type constructors!in ML@in \ML|(}
\index{type abbreviations!in ML@in \ML}
\index{types, in ML@types, in \ML!abbreviation of}

% ------------------------------------------------------------
\begin{table}[htbp]
\Narrowlines\normalsize
\centering
\begin{tt}
\begin{tabular}{|llclll|}
	\hline

{\bf Types}	     & $ty$  & ::= & $sty$
				   &     & \rm Standard (non-infix) type\\
		     &       & |   & $ty$ * $ty$
				   &\rm R& \rm Cartesian product\\
		     &       & |   & $ty$ +  $ty$
				   &\rm R& \rm Disjoint sum	\\
		     &       & |   & $ty$ -> $ty$
				   &\rm R& \rm Function type	\\[-0.8em]
		     &       &     &
				   & &		\\
{\bf Standard Types} & $sty$ & ::= & Unit | Int
				   & &	\\
		     &       & |   & Bool | Atom
				   & &\rm Basic types	\\
		     &       & |   & $vty$
				   & &\rm Type variable	\\
		     %% &       & |   & $tycon$
		     %%    	   & &\rm Type abbreviation
		     %%    		 (see Section~\ref{sec:ML-typeabbrev})\\
		     %% &       & |   & $tycon$
		     %%    	   & &\rm Nullary abstract type\\
		     %% &       & |   & $tyarg$ $tycon$&
		     %%    	   \rm L&\rm Abstract type
		     %%    	     (see Section~\ref{sec:ML-abstract-types})\\
		     &       & |   & ($ty$)
				   & &	   \\[-0.8em]
		     &       &     &
				   & &		\\
{\bf Type arguments} &$tyarg$& ::= & $sty$
				    & & \rm Single type argument\\
		     &       & |   & ($ty$,\ldots,$ty$)
				   & &\rm  One or more type arguments\\[-0.8em]
		     &       &     &
				   & &		\\
{\bf Type variables} & $vty$ & ::= & {\tt '}$id$ &&\\
\hline
\end{tabular}
% -------------------------------------------------
\end{tt}
\caption{{\ML} Type Syntax}
\label{tab:ml-type-syntax}
\index{abbreviation of types, in ML@abbreviation of types, in \ML}
\index{ product type operator, in ML@{\small\verb+# +} (product type operator,
	in \ML)}
\index{ disjoint union type operator, in ML@{\small\verb:+:} (disjoint union
	type operator, in \ML)}
\index{disjoint union, in ML@disjoint union, in \ML}
\index{ function type operator, in ML@{\small\verb+->+} (function type operator,
	in \ML)}
\index{function types, in ML@function types, in \ML}
\index{unit@\ttQ{unit}}
\index{int@\ttQ{int}}
\index{bool, the type in ML@\ttQ{bool}, the type in \ML}
\index{tok@\ttQ{tok}}
\index{string@\ttQ{string}}
\index{product types!in ML@in \ML}
\index{ type variables, in ML@{\small\verb+*+, \verb+**+,$\ldots$} (type
	variables, in \ML)}
\end{table}
% ------------------------------------------------------------


The syntax of \ML\ types is summarized in Table~\ref{tab:ml-type-syntax}.
%
%% Type abbreviations are  introduced  by  a \ttQ{type}
%% \index{lettype@{\small\verb+lettype+}}
%% declaration (see Section~\ref{sec:ML-typeabbrev} below) which allows an
%% identifier to abbreviate an arbitrary monotype.
%
%% An abstract type
%% \index{abstract types, in ML@abstract types, in \ML}
%% \index{types, in ML@types, in \ML!concrete}
%% likewise consists of an identifier (introduced by an \ttQ{abstype} or
%% \ttQ{absrectype} declaration; see Section~\ref{sec:ML-abstract-types}) postfixed
%% to zero or more type arguments.
Two or more arguments must be separated by
commas and enclosed by parentheses.  The type operator \ttQ{List}
\index{list, the type operator in ML@\ttQ{list}, the type operator in \ML}
is a predeclared unary type operator; and \ttQ{*}, \ttQ{+} and \ttQ{->} may be
regarded as infix forms of three predeclared binary type operators.

For an object to possess%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\footnote{We shall talk of objects {\it possessing\/} types and phrases {\it
	  having\/} types, to emphasize the distinction.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
a type means the following: For basic types, all integers possess \ttQ{Int},
both booleans (\ttQ{true} and \ttQ{false}) possess \ttQ{Bool}
\index{bool, the type in ML@\ttQ{bool}, the type in \ML},
%% all strings possess \ttQ{String},
etc.\ The only object possessing
%%\ttQ{void} (or \ttQ{unit})\index{void@\ttQ{void}}
\ttQ{Unit} is that denoted by \ttQ{()} in
\ML.  For a type abbreviation $tycon$, an object possesses $tycon$ (during
execution of phrases in the scope of the declaration of $tycon$) if and only if
it possesses the type which $tycon$ abbreviates.
\
For compound monotypes
\index{compound monotypes, in ML@compound monotypes, in \ML},

\begin{enumerate}\vspace*{-2mm}\setlength{\itemsep}{0mm}

  \item The type \ttQ{$ty$ List} is possessed by any list of objects, all of
	which possess type $ty$ (so that the empty list possesses type \ttQ{$ty$
	List} for every $ty$).

  \item The type \ttQ{$ty_1$ * $ty_2$} is possessed by any pair of objects
	possessing the types $ty_1$ and $ty_2$, respectively.

  \item The type \ttQ{$ty_1$ + $ty_2$} is possessed by the left-injection of any
	object possessing $ty_1$, and by the right-injection of any object
	possessing $ty_2$.  These injections are denoted by the \ML\ function
	identifiers {\tt \ttQ{inl} :\ 'a -> 'a + 'b} and {\tt\ttQ{inr} :\ 'b -> 'a +
	'b}.% (see Section~\ref{sec:ML-prims}).

  \item A function possesses type \ttQ{$ty_1$ -> $ty_2$} if, whenever its
	argument possesses type $ty_1$, its result (if defined) possesses type
	$ty_2$. (This is not an exact description; for example, a function
	defined in \ML\ with non-local variables may possess this type even
	though some assumption about the types of the values of these non-local
	variables is necessary for the above condition to hold.  The constraints
	on programs listed below ensure that the non-locals will always have the
	right types).

  %% \item An object possesses the abstract type $tyarg$ $id$ if and only if it is
  %%       represented (via the abstract type representation) by an object
  %%       possessing the $tyarg$ instance of the right-hand side of the
  %%       declaration of $id$.
\end{enumerate}\vspace*{-2mm}

Finally, an object possesses a polytype $ty$ if and only if it possesses all
monotypes which are substitution instances of $ty$\index{type constructors!in
ML@in \ML|)}.


% ----------------------------------------
\subsection{Typing of {\ML} phrases}
% ----------------------------------------

\index{type checking, in ML@type checking, in \ML!inference involved in|(}
\index{type checking, in ML@type checking, in \ML|(}
\index{has type vs possesses type@has type {\it vs} possesses type|(}

We now explain the constraints used by the type checker in ascribing types to
\ML\ expressions, patterns and declarations.

The significance of expression $e$ having type\index{type constraint!in ML@in
\ML} $ty$ is that the value of $e$ (if evaluation terminates successfully)
possesses type $ty$.  \index{has type vs possesses type@has type {\it vs}
possesses type|)} As consequences of the well-typing constraints listed below,
it is impossible for example to apply a non-function to an argument, or to form
a list of objects of different types, or (as mentioned earlier) to compute an
object of the type corresponding to theorems which is not a theorem.

The type \index{ML@\ML!type checking of|(} ascribed to a phrase depends in
general on the entire surrounding \ML\ program.  In the case of
top-level\index{ML@\ML!top level of}\index{top level, of ML@top level, of
\ML!declarations at}\index{top level, of ML@top level, of \ML!expressions at}
expressions and declarations, however, the type ascribed depends only on
preceding top-level phrases.  Thus you know that types ascribed at top-level are
not subject to further constraint.

Before each top-level phrase is executed, types are ascribed to all its
sub-expressions, sub-declarations and sub-patterns according to the following
rules.  Most of the rules are fairly natural; those which are less so are
discussed later.  You are only presented with the types of top-level phrases;
the types of sub-phrases will hardly ever concern you.

Before giving the list of constraints, let us discuss an example which
illustrates some important points.  To map a function over a list we may define
the polymorphic function \ttQ{map} recursively as follows (where we have used an
explicit abstraction, rather than \ttQ{letrec map f l = ...}, to make the typing
clearer):

\begin{verbatim}
   letrec map = \f.\l. null l => [] | f(hd l).map f(tl l) ;;
\end{verbatim}

\noindent From this declaration the type checker will infer a {\it
generic\/}\index{generic types, in ML@generic types, in \ML} type for \ttQ{map}.
By `generic' we mean that each later occurrence of \ttQ{map} will be ascribed a
type which is a substitution instance of the generic type.

Now the free identifiers in this declaration are \ttQ{null}, \ttQ{hd},
\ttQ{tl} and
\ttQ{op .}, which are \ML\ primitives whose {\it generic\/} (poly)types are
\ttQ{'a List -> Bool}, \ttQ{'a List -> 'a}, \ttQ{'a List -> 'a List}, and
\ttQ{'a * 'a List -> 'a List}
respectively.  The first constraint used by the type checker is that the
occurrences of these identifiers in the declaration are ascribed instances of
their generic types.  Other constraints which the type checker will use to
determine the type of \ttQ{map} are:

\begin{itemize}\vspace*{-2mm}\setlength{\itemsep}{0mm}
  \item All occurrences of a lambda-bound variable receive the same type.

  \item Each arm of a conditional receives the same type, and the condition
	receives type \ttQ{Bool}.

  \item In each application \ttQ{$e$ = ($e_1 e_2$)}, if $e_2$ receives $ty$ and
	$e$ receives $ty'$ then $e_1$ receives \ttQ{$ty$ -> $ty'$}.

  \item In each abstraction \ttQ{$e$ = {\bs}$v$.$e_1$}, if $v$ receives
	$ty$ and $e_1$ receives $ty'$ then $e$ receives \ttQ{$ty$ -> $ty'$}.

  \item In a {\tt letrec} declaration, all free occurrences of the
	declared variable receive the same type.
\end{itemize}


Now the type checker will ascribe the type
\ttQ{('a -> 'b) -> 'a List -> 'b List} to
\ttQ{map}.  This is in fact the most general type consistent with the
constraints mentioned.  Moreover, it can be shown that any instance of this type
also allows the constraints to be satisfied; this is what allows us to claim
that the declaration is indeed polymorphic\index{type checking, in ML@type
checking, in \ML!inference involved in|)}.

In the following constraint list, we say $p$ has $ty$ to indicate that the
phrase $p$ is ascribed a type $ty$ which satisfies the stated conditions.  We
use $x$, $p$, $e$, $d$ to stand for variables, patterns, expressions and
declarations respectively.

\begin{description}\vspace*{-2mm}\setlength{\itemsep}{0mm}

  \item [Constants: ]~
	\index{constant expressions, in ML@constant expressions, in \ML}

      \begin{enumerate}\vspace*{-2mm}
        \item \ttQ{()} has type \ttQ{Unit}
		\index{void@\ttQ{void}}
        \item \ttQ{0} has  type \ttQ{Int}
		\index{integers, in ML@integers, in \ML},
	        \ttQ{1} has  type \ttQ{Int}, ...
        \item \ttQ{true}  has  type \ttQ{Bool},
		\index{true in ML@\ttQ{true} in \ML}
        	\ttQ{false} has  type \ttQ{Bool}
		\index{false@\ttQ{false}}
        \item \ttQ{`...`} has  type \ttQ{Atom}
%        \item {\verb%"..."%} has  type \ttQ{string}
      \end{enumerate}


  \item [Variables and constructors:]
	\index{type variables, in ML@type variables, in \ML}
        \index{identifiers, in ML@identifiers, in \ML!type checking of}
	\index{variables, in ML@variables, in \ML!type checking of}
	\index{constructors, in ML@constructors, in \ML!type checking of}

        The constraints described here are discussed in
        Section~\ref{sec:ML-ty-con-discuss} below.\hspace*{-2mm}

        \begin{enumerate}\vspace*{-2mm}
    	  \item If $x$ is a variable bound by {\bs}\
                %, {\tt fun}
                or {\tt letref}\index{letref in@\ttQ{letref} $\ldots$ \ttQ{in}
        	$\ldots$!type checking of}, then $x$ is ascribed the same type
        	as its binding occurrence.
                %% In the case of {\tt letref}, this
        	%% must be monotype if the {\tt letref} is top-level or an
        	%% assignment to $x$ occurs within a lambda-expression within its
        	%% scope.

	  \item If $x$ is bound by {\tt let}\index{let in@\ttQ{let} $\ldots$
	        \ttQ{in} $\ldots$!type checking of} or {\tt letrec}\index{letrec
	        in@\ttQ{letrec} $\ldots$ \ttQ{in} $\ldots$!type checking of},
	        then $x$ has $ty$, where $ty$ is an instance of the type of the
	        binding occurrence of $x$ (i.e.\ the {\it generic\/} type of
	        $x$), in which type variables occurring in the types of current
	        lambda-bound
                %or {\tt letref}-bound identifiers
                are not instantiated.

          \item If $x$ is not bound in the program (in which case it must be an
	        \ML\ primitive), then $x$ has $ty$, where $ty$ is an instance of
	        the type of $x$ has defined in the built-in library or
                in the library file.
                %given in Section~\ref{sec:ML-prims}.
  \end{enumerate}

  \item [Patterns: ]
	\index{patterns, in ML@patterns, in \ML!type checking of|(}

        Cases for a pattern $p$:
        \begin{itemize}\vspace*{-2mm}

          \item \ttQ{()}:
                $p$ has \ttQ{Unit}.

          \item \ttQ{\_}:
       		\index{wildcard, in ML@wildcard, in \ML}
	       	\index{ wildcard, in ML@{\small\verb+()+} (wildcard, in \ML)}
                $p$ has $ty$, where $ty$ is any type.

          \item \ttQ{$p_1$:$ty$}:
	       	\index{type constraint!in ML@in \ML}\\
                $p_1$ and $p$ have an instance of $ty$.

          \item \ttQ{($p_1$,$p_2$)}: If $p_1$ has $ty_1$ and $p_2$ has $ty_2$,
                 then $p$ has \ttQ{$ty_1$ * $ty_2$}.

          %% \item \ttQ{$p_1$.$p_2$}: If $p_1$ has $ty$ then $p_2$ and $p$
	  %%       have \ttQ{$ty$ list}.

          %% \item \ttQ{[$p_1$;\ldots;$p_n$]}:
	  %%       \index{list constructor, in ML@list constructor, in \ML!type
	  %%       checking of}
	  %%       For some $ty$, each $p_i$ has $ty$ and $p$ has \ttQ{$ty$ list}.

        \end{itemize}
	\index{patterns, in ML@patterns, in \ML!type checking of|)}

  \item [Expressions: ]
	\index{expressions, in ML@expressions, in \ML!type checking of}
	\index{combinations, in ML@combinations, in \ML}

        Cases for an expression $e$ (not a constant or identifier):

        \begin{itemize}\vspace*{-2mm}

          \item \ttQ{$e_1 e_2$}:
              	If $e_2$ has $ty$ and $e$ has $ty'$ then $e_1$ has
		\ttQ{$ty$ -> $ty'$}.

	      	\index{function application, in ML@function application, in
	      	\ML!type checking of}
		\index{function types, in ML@function types, in \ML}

          \item \ttQ{$e_1$:$ty$}: $e_1$ and $e$ have an instance of $ty$.

          \item \ttQ{$px$ $e_1$}: Treated as \ttQ{(op $px$)$e_1$} when $px$ is a
                prefix.  If $e$ is \ttQ{$\sim e_1$}, then $e$ and $e_1$ have
                \ttQ{Int}.

	      \index{prefixes, in ML@prefixes, in \ML}

          \item \ttQ{$e_1$ $ix$ $e_2$}: Treated as
                \ttQ{(op $ix$)$e_1$$e_2$}.
                %% if
		%% $ix$ is introduced with {\tt ml\_paired\_infix}, and as
		%% \ttQ{(\$$ix$ $e_1$ $e_2$)} if $ix$ is introduced by {\tt
		%% ml\_curried\_infix}.
                If $e$ is \ttQ{($e_1$ \& $e_2$)} or
		\ttQ{($e_1$ or $e_2$)} then $e$, $e_1$ and $e_2$ have
		\ttQ{Bool}.

          \item \ttQ{($e_1$,$e_2$)}: If $e_1$ has $ty_1$ and $e_2$ has $ty_2$ then
		$e$ has \ttQ{$ty_1$ * $ty_2$}.

	      \index{pairs, in ML@pairs, in \ML!type checking of}

          %% \item \ttQ{$p$:=$e_1$}:  For some $ty$, $p$, $e_1$ and $e$ all have
	  %%         $ty$.

	  %%       \index{assignments, in ML@assignments, in ML!type checking of}

          %% \item \ttQ{failwith $e_1$}: $e_1$ has \ttQ{tok}, and $e$ has any type.

	  %%       \index{failwith@\ttQ{failwith}}

          \item \ttQ{if $e_{1}$ then $e_{2}$ else $e_{3}$}:
    	        Each $e_{1}$ has \ttQ{Bool}, and $e_{2}$ and $e_{3}$
	        have $ty$ for some $ty$.
                %% However, this constraint does not
	        %% apply to an $e_{i}'$ preceded by \ttQ{loop} in place of
	        %% \ttQ{then}, nor to $e'$ preceded by \ttQ{loop} in place of
	        %% \ttQ{else}. If $e'$ is absent, then $ty$ = \ttQ{void}.

		\index{conditional loop construct, in ML@conditional/loop
			construct, in \ML!type checking of}
		\index{conditional loop construct, in ML@conditional/loop
			construct, in \ML}
		\index{if loop else@{\small if $\cdots$ loop $\cdots$ else
			$\cdots$}!type checking of}

        %% \item \ttQ{$e_{0}'$ ?? $e_1$ $e_{1}'\ldots$ ?? $e_n$ $e_{n}'$
        %%    	 ?\{{\bs}$x$\}$e'$}:  Each $e_i$ has \ttQ{tok list}, and $e$,
        %%    	 $e_{0}'$, each $e_{i}'$ and $e'$ all have $ty$  for some
        %%    	 $ty$. However, this constraint does not apply to an $e_{i}'$
        %%    	 preceded by \ttQ{!!} in place of \ttQ{??} nor to $e'$ preceded
        %%    	 by \ttQ{!} in place of \ttQ{?}.  If {\bs}$x$ is present, $x$ has
        %%    	 \ttQ{tok}.

	%% 	\index{failure, in ML@failure, in \ML!iterative selective
	%% 		trapping of}
	%% 	\index{failure, in ML@failure, in \ML!trapping of}
	%% 	\index{failure, in ML@failure, in \ML!selective trapping of}
        %%     	\index{failure, in ML@failure, in \ML!iterative trapping of}

        %% \item \ttQ{$e_1$;\ldots;$e_n$}:
	%% 	 If $e_n$ has $ty$ then $e$ has $ty$.

	%% 	\index{sequencing!of {\ML} expressions@of \ML\ expressions}

        \item \ttQ{[$e_1$;\ldots;$e_n$]}:
		For some $ty$, each $e_i$ has $ty$ and $e$ has \ttQ{$ty$ List}.

		\index{lists, in ML@lists, in \ML!type checking of}

        \item \ttQ{let $d$ in $e_1$}: If $e_1$ has $ty$ then $e$ has $ty$.
               %% If $d$
               %% is a type definition (see Sections~\ref{sec:ML-concrete-types}
               %% and~\ref{sec:ML-abstract-types}) then $ty$ must contain no type
               %% defined in $d$.

        \item \ttQ{{\bs}$p$.$e_1$}: If $p$ has $ty$ and $e_1$ has $ty'$ then $e$ has
		 \ttQ{$ty$ ->$ty'$}.

		\index{function abstraction, in ML@function abstraction, in
			\ML!type checking of}
  \end{itemize}

  \item [Declarations: ]~

        \begin{enumerate}\vspace*{-2mm}

          \item Each binding \ttQ{$x$ $p_1 \ldots p_n$ = $e$} is
              treated as \ttQ{$x$ = {\bs}$p_1$. \ldots {\bs}$p_n$.$e$}.

          %% \item \ttQ{let $p_1$ = $e_1$ and \ldots and $p_n$ = $e_n$} is treated
          %%     as \ttQ{let $p_1$,\ldots,$p_n$ = $e_1$,\ldots,$e_n$} (similarly
          %%     for {\tt letrec} and {\tt letref}).

	  %%       \index{let in@\ttQ{let} $\ldots$ \ttQ{in} $\ldots$!type checking
	  %%                     of}
	  %%       \index{letref in@\ttQ{letref} $\ldots$ \ttQ{in} $\ldots$!type
          %%     		      checking of}
	  %%       \index{letrec in@\ttQ{letrec} $\ldots$ \ttQ{in} $\ldots$!type
	  %%                     checking of}

          \item If $d$ is \ttQ{let $p$=$e$}, then $d$, $p$ and $e$ all have $ty$
		for some $ty$.% (similarly for {\tt letref}).
                Note that $e$ is not in the scope of the declaration.

          \index{declarations, in ML@declarations, in \ML!type checking of}

          \item If $d$ is \ttQ{letrec ($x_1$,\ldots,$x_n$) = ($e_1$,\ldots,$e_n$)},
		 then, for each $i\in\{1,\dots,n\}$, $x_i$ and $e_i$
                 have $ty_i$, and $d$ has
		 \ttQ{$ty_1$ * \ldots\ * $ty_n$} for some $ty_i$.  In addition,
		 each free occurrence of $x_i$ in $e_1$,\ldots,$e_n$ has $ty_i$,
		 so that the type of recursive calls of $x_i$ is the same as the
		 declaring type.
        \end{enumerate}

\end{description}

\index{ML@\ML!type checking of|)}
\index{type checking, in ML@type checking, in \ML|)}

% ----------------------------------------
\subsection {Discussion of type constraints}
\label{sec:ML-ty-con-discuss}
% ----------------------------------------

We give here reasons\index{type checking, in ML@type checking, in \ML!reasons
behind algorithm for|(} for our constraints on the types ascribed to occurrences
of identifiers.  The reader may like to skip this section at first reading.

%\begin{enumerate}\vspace*{-2mm}\setlength{\itemsep}{0mm}

%  \item
        Consider constraint (1) for lambda-bound identifiers.  This constraint
	implies that the expression \ttQ{let $x$ = $e$ in $e'$} may be
	well-typed even if the semantically-equivalent (dynamic
        semantics and not static semantics) expression \ttQ{let $f$
	$x$ = $e'$ in $f$ $e$} is not, since in the former expression $x$ may
	occur in $e'$ with two incompatible types which are both instances of
	the declaring type.  The greater constraint on $f$ is associated with
	the fact that $f$ may be applied to many different arguments during
	evaluation.  To show the need for the constraint, suppose that it is
	replaced by the weaker constraint for \ttQ{let}-bound identifiers, so
	that for example
	\
	\ttQ{let f x = if x then 1 + x else x(1)}
	\
	is a well-typed declaration of type \ttQ{'a -> Int}, in which the
	occurrences of {\tt x} receive types \ttQ{'a}, \ttQ{Bool}, \ttQ{Int},
	\ttQ{Int -> Int} respectively.  In the absence of an explicit argument for
	the abstraction, no constraint exists for the type of the binding
	occurrence of {\tt x}.  But, because {\tt f} is {\tt let}-bound,
	expressions such as \ttQ{f true} and \ttQ{f `dog`} are admissible in the
	scope of {\tt f}, although their evaluation should result in either
	nonsense or {\it run-time\/} type-errors; one of the our purposes is to
	preclude these.

	Note that expressions of the form
	\ttQ{({\bs}$x$.$e'$)$e$}, could be treated exactly as \ttQ{let
	$x$=$e$ in $e'$} because we know the unique instance of type of the
	argument $x$, namely the type of $e$.

  %% \item The analogous restriction for {\tt letref}-bound identifiers is also due
  %%       to the possibility that the identifier-value binding may change during
  %%       evaluation (this time because of assignments).  Consider the following:

  %%       \bt
  %%       \e  letref x = [] in
  %%       \e        (if e then do(x := 1.x) else do(x := [true]) ; hd x) ;;
  %%       \et

  %%       If {\tt letref} were treated like {\tt let}, this phrase would be
  %%       well-typed and indeed have type \ttQ{*}, despite the fact that the value
  %%       returned is either \ttQ{1} or \ttQ{true}.  So, calling the whole
  %%       expression $e$, all manner of larger expressions involving $e$ would be
  %%       well-typed, even including \ttQ{$e$($e$)}!

  %% \item Top level {\tt letref}s must be monomorphic to avoid retrospective type
  %%       constraints at top-level.  If this restriction were removed the
  %%       following would be allowed:

  %%       \bttight
  %%       \e   letref x = [] ;;
  %%       \e       \(\vdots\)
  %%       \e      2.x ;;
  %%       \et

  %%       But on type checking the last phrase, it would appear that the type of
  %%       {\tt x} at declaration should have been \ttQ{int list}, not \ttQ{*
  %%       list}, and the types of intervening phrases may likewise need
  %%       constraining.

  %% \item To see the need for the exclusion of polymorphic non-local assignments,
  %%       consider this example in the \HOL\ system (this example is originally
  %%       due to Lockwood Morris\index{Morris, L.}). (The type \ttQ{thm} is the
  %%       type of theorems.)
  %%       \vspace*{-2mm}

  %%       {\small\begin{verbatim}
  %%          let store,fetch =
  %%              letref x = [] in (\y. x:=[y]) , (\(). hd x ) ;;
  %%          store "T = F" ;;
  %%          let eureka :thm = fetch() ;;
  %%       \end{verbatim}}\vspace*{-2mm}

  %%       Now suppose we lift our constraint.  Then in the declaration, {\tt x}
  %%       has type \ttQ{* list} throughout its (textual) scope, and \ttQ{store},
  %%       \ttQ{fetch} receive types \ttQ{*->* list}, \ttQ{**->*} respectively.  In
  %%       the two ensuing phrases they get respective types \ttQ{term->term list},
  %%       \ttQ{void->thm} (instances of their declaring types), and the value of
  %%       \ttQ{eureka} is a contradictory formula masquerading as a theorem!

  %%       The problem is that the type checker has no simple way of discovering
  %%       the types of all values assigned to the polymorphic {\tt x},
  %%       since these assignments may be invoked by calls of the function
  %%       \ttQ{store} outside the (textual) scope of {\tt x}.
  %%       This is not possible under our constraint.\vspace*{-2mm}

  %%       However, polymorphic assignable identifiers are still useful: consider

  %%       \index{assignable variables, in ML@assignable variables, in \ML}
  %%       \index{assignable variables, in ML@assignable variables, in \ML}
  %%       \index{variables, in ML@variables, in \ML!assignable}

  %%       {\small\begin{verbatim}
  %%          let rev l =
  %%               letref l,l' = l,[] in
  %%                 if null l then l' loop (l,l':= tl l, hd l.l') ;;
  %%       \end{verbatim}}\vspace*{-2mm}


  %%       Such uses of assignable identifiers for iteration may be avoided given a
  %%       suitable syntax for iteration, but assignable identifiers are useful for
  %%       a totally different purpose, namely as `own variables' shared between
  %%       one or more functions (as in the store-fetch example).  Our constraint
  %%       of course requires them to be monomorphic; this is one of the few cases
  %%       where the user occasionally needs to add an explicit type to a program.

%\end{enumerate}
\index{type checking, in ML@type checking, in \ML!reasons behind algorithm for|)}


%% % ----------------------------------------
%% \subsection{Type abbreviations}
%% \label{sec:ML-concrete-types}
%% % ----------------------------------------

%% \index{abbreviation of types, in ML@abbreviation of types, in \ML}\index{type abbreviations!in ML@in \ML}\index{types, in ML@types, in \ML!abbreviation of}
%% \label{sec:ML-typeabbrev}
%% \index{lettype@{\small\verb+lettype+}|(}

%% The syntax of type abbreviation bindings $tab$ is

%% \begin{quote}\vspace*{-2mm}\tt
%% %%  $tab$ ::= $id_1$ = $ty_1$ and $\ldots$ and $id_n$ = $ty_n$
%%   $tab$ ::= $id$ = $ty$
%% \end{quote}\vspace*{-2mm}

%% \noindent Then the declaration

%% \begin{quote}\vspace*{-2mm}\tt
%%   type $tab$
%% \end{quote}\vspace*{-2mm}

%% \noindent
%% in which each $ty_i$ must be a monotype, built from basic types and previously
%% defined types, allows you to introduce new names $id_i$ for the types $ty_i$.
%% Within the scope of the declaration the expression \ttQ{$e$:$id_i$} behaves
%% exactly like \ttQ{$e$:$ty_i$}, and the type $ty_i$ will always be printed as
%% $id_i$.

%% One aspect of such type abbreviations should be emphasized.  Suppose for the
%% rational numbers you declare 
%% \
%% \ttQ{lettype rat = int \# int;;}
%% \
%% and set up the standard operations on rationals.
%% Within the scope of this declaration {\it any\/} expression of type \ttQ{int \#
%% int} will be treated as though it had type \ttQ{rat}, and this could be not only
%% confusing but also incorrect (in which case it ought to cause a type failure).
%% If you wish to introduce the type \ttQ{rat}, isomorphic to \ttQ{int \# int} but
%% not matching it for type checking purposes, then you should use abstract types.

%% \index{abstract types, in ML@abstract types, in \ML!reasons for}
%% \index{lettype@{\small\verb+lettype+}|)}

%% % ----------------------------------------
%% \subsection {Abstract types}
%% \label{sec:ML-abstract-types}
%% % ----------------------------------------

%% \index{types, in ML@types, in \ML!abstract|(}
%% \index{abstract types, in ML@abstract types, in \ML|(}
%% \index{absrectype@{\small\verb+absrectype+}$\ldots${\small\verb+with+}\ldots|(} 
%% \index{abstype with@\ttQ{abstype}$\ldots$\ttQ{with}$\ldots$|(}

%% As with concrete types, abstract type constructors may be introduced by a
%% declaration in which type variables are used as dummy arguments (or formal
%% parameters) of the operators.  The syntax of abstract type
%% bindings\index{bindings, in ML@bindings, in \ML!abstract type} $ab$ is

%% \begin{quote}\vspace*{-2mm}\tt
%%   $ab$ ::= $vtyarg_1$ $tycon_1$ = $ty_1$ and \ldots and $vtyarg_n$ $tycon_n$ =
%% 	   $ty_n$ with $b$
%% \end{quote}\vspace*{-2mm}

%% \noindent

%% where each $vtyarg_i$ must contain no type variable more than once, and all the
%% type variables in $ty_i$ must occur in $vtyarg_i$.  An abstract type declaration
%% takes the form

%% \begin{quote}\vspace*{-2mm}\tt
%% 	 \{abstype|absrectype\} $ab$
%% \end{quote}\vspace*{-2mm}

%% \noindent 

%% The declaration introduces a set of type operators, and also incorporates a
%% normal binding $b$ (treated like {\tt let}) of \ML\ identifiers.  Throughout the
%% scope of the abstract type declaration the type operators and \ML\ identifiers
%% are both available, but it is only within $b$ that the {\it representation\/} of
%% the type operators (as declared in terms of other operators) is available.
%% In an abstract type declaration

%% \begin{quote}\vspace*{-2mm}\tt
%%   abs\{rec\}type $vtyarg_1$ $id_1$ = $ty_1$ and \ldots and $vtyarg_n$ $id_n$
%% 	= $ty_n$ with $b$
%% \end{quote}\vspace*{-2mm}
%% \noindent
%% the sense in which the representation of each $id_i$ is available only within
%% $b$ is as follows: the isomorphism between objects of types $ty_i$ and
%% $vtyarg_i$ $id_i$ is available (only in $b$) via a pair of implicitly declared
%% polymorphic functions

%% \index{abs_@{\small\verb+abs_+$\ldots$}}
%% \index{rep_@{\small\verb+rep_+$\ldots$}}

%% \begin{quote}\vspace*{-2mm}\tt
%%    abs\_$id_i$ : $ty_i$ -> $vtyarg_i$ $id_i$\\
%%    rep\_$id_i$ : $vtyarg_i$ $id_i$ -> $ty_i$	
%% \end{quote}\vspace*{-2mm}

%% \noindent which are to be used as coercions between the abstract types
%% and their representations. Thus in the simple case
%% \
%% \ttQ{abstype $a$= $ty$ with $x$=$e'$ in $e$}
%% \
%% the scope of $a$ is $e'$ and $e$, the scope of \ttQ{abs\_$a$} and
%% \ttQ{rep\_$a$} is $e'$, and the scope of $x$ is $e$.
%% \index{scope!in {\ML} abstract types@in \ML\ abstract types} 

%% As an illustration, consider the definition of the type \ttQ{rat} of
%% rational numbers, represented by pairs of integers, together with operations
%% {\small\verb%plus%} and {\small\verb%times%} and the conversion functions

%% \begin{quote}\vspace*{-2mm}\tt
%%    inttorat : int->rat\\
%%    rattoint : rat->int	
%% \end{quote}\vspace*{-2mm}

%% \noindent Since \ttQ{rat} is a nullary type operation, no type variables are
%% involved, and \ttQ{rat} can be defined by:

%% \begin{verbatim}
%%    abstype rat = int# int
%%       with plus(x,y) = (abs_rat(x1*y2+x2*y1, x2*y2)
%%                         where x1,x2 = rep_rat x
%%                           and y1,y2 = rep_rat y    )
%%       and times(x,y) = (abs_rat(x1*y1, x2*y2)
%%                         where x1,x2 = rep_rat x
%%                           and y1,y2 = rep_rat y    )
%%       and inttorat n = abs_rat(n,1)
%%       and rattoint x = ((x1/x2)*x2=x1 => x1/x2 | failwith `rattoint`
%%                         where x1,x2 = rep_rat x    ) ;;
%% \end{verbatim}

%% \index{ML@\ML!top level of}

%% Most abstract type declarations are probably used at top-level, so that their
%% scope is the remainder of the top-level program.  But for non-top-level
%% declarations, a simple constraint ensures that a value of abstract type cannot
%% exist except during the execution of phrases within the scope of the type
%% declaration.  In the expression

%% \begin{quote}\vspace*{-2mm}\tt
%%   abs\{rec\}type $vtyarg_1$ $id_1$ = $ty_1$ and \ldots and $vtyarg_n$ $id_n$
%% 	= $ty_n$ with $b$ in $e$	
%% \end{quote}\vspace*{-2mm}

%% \noindent the type of $e$, and the types of any non-local assignments within $b$
%% and $e$, must not involve any of the $id_i$.

%% Finally, in keeping with the abstract\index{top level, of ML@top level, of
%% \ML!abstract type expressions at} nature of objects of abstract type, the value
%% of a top-level expression of abstract type is printed as a dash, \ttQ{-}
%% \index{non-printable values in ML@non-printable values in \ML}
%% \index{non-printable symbol, in ML@{\small\verb+-+} (`non-printable' symbol, in
%% 	\ML)}
%% \index{printing, of ML@printing, of \ML!of abstract-typed values}
%% \index{abstract-typed values, in ML@abstract-typed values, in \ML!printing of},
%% as functional values are. Users who wish to `see' such an object should declare
%% a coercion function in the `with' part of the type declaration, to yield a
%% suitable concrete representation of the abstract objects.

%% \index{absrectype@{\small\verb+absrectype+}$\ldots${\small\verb+with+}\ldots|)} 
%% \index{abstract types, in ML@abstract types, in \ML|)}
%% \index{abstype with@\ttQ{abstype}$\ldots$\ttQ{with}$\ldots$|)}
%% \index{type constructors!in ML@in \ML|)}
%% \index{types, in ML@types, in \ML!abstract|)}


%% % ------------------------------------------------------------------------------
%% \section{Primitive {\ML} Identifier Bindings}
%% \label{sec:ML-prims}
%% % ------------------------------------------------------------------------------

%% \index{identifiers, in ML@identifiers, in \ML!binding of|(}
%% The primitive \ML\ identifier bindings are described in this Section.
%% %% Some useful derived functions are in Section~\ref{sec:ML-basic-funs}.
%% The primitive bindings are of two kinds:

%% \begin{itemize}\vspace*{-2mm}\setlength{\itemsep}{0mm}
%%   \item ordinary bindings;
%%   \item ``op'' bindings (which are preceded by {\tt op}) having prefix or infix
%% 	status.
%% \end{itemize}

%% The description of the \ML\ value to which an identifier is bound is omitted if
%% the semantics is clear from the identifier name and type given.
%% %% For those
%% %% functions whose application may fail, the failure string\index{failure strings,
%% %% in ML@failure strings, in \ML!of primitive identifiers} is the function
%% %% identifier.

%% \index{predeclared bindings, in ML@predeclared bindings, in \ML|(} Predeclared
%% identifiers\index{identifiers, in ML@identifiers, in \ML!predeclared|(} are not
%% regarded as constants of the language.  As with all other \ML\ identifiers, the
%% user is free to rebind them, by {\tt let}, {\tt letref}, etc., but note that in
%% the case of infix or prefix operators rebinding the dollared operator will
%% affect even its non-dollared uses.  Predeclared bindings\index{bindings, in
%% ML@bindings, in \ML!predeclared|(} are to be understood as if they had been
%% bound by {\tt let}, rather than by {\tt letref}. In particular, therefore, none
%% of them can be changed by assignment (except, of course, within the scope of a
%% rebinding of the identifier by a {\tt letref}-declaration).

%% % ----------------------------------------
%% \subsection{Predeclared ordinary identifiers}
%% \label{avra_predeclared}
%% % ----------------------------------------


%% \begin{boxed}
%% \index{fst@\ttQ{fst}|pin}
%% \index{snd@\ttQ{snd}|pin}
%% \index{null@\ttQ{null}|pin}
%% \index{hd@\ttQ{hd}|pin}
%% \index{tl@\ttQ{tl}|pin}
%% \index{inl@\ttQ{inl}|pin}
%% \index{inr@\ttQ{inr}|pin}
%% \index{outr@\ttQ{outr}|pin}
%% \index{outl@\ttQ{outl}|pin}
%% \index{isl@\ttQ{isl}|pin}
%% \begin{verbatim}
%%    fst  : * #  ** -> *
%%    snd  : * #  ** -> **                    inl  : * -> * + **
%%                                            inr  : ** -> * + **
%%    null : * list -> bool                   outl : * + ** -> *
%%    hd   : * list -> *                      outr : * + ** -> **
%%    tl   : * list -> * list                 isl  : * + ** -> bool
%% \end{verbatim}
%% \end{boxed}

%% \noindent The functions \ttQ{hd} and \ttQ{tl} fail if their argument is an empty
%% list. The functions \ttQ{outl} and \ttQ{outr} fail if their arguments are not
%% in the left or right summand, respectively. A function \ttQ{isr} is not
%% provided because it is just the complement of \ttQ{isl}.

%% \begin{boxed}
%% \index{explode@\ttQ{explode}|pin}
%% \index{implode@\ttQ{implode}|pin}
%% \begin{verbatim}
%%    explode : tok -> tok list
%%    implode : tok list -> tok
%% \end{verbatim}
%% \end{boxed}


%% The function \ttQ{explode} maps a token into the list of its single character
%% tokens in order. The function \ttQ{implode} maps a list of single character
%% tokens (fails if any token is not of length one) into the token obtained by
%% concatenating these characters.  For example:

%% \setcounter{sessioncount}{1}
%% \begin{session}
%% \begin{verbatim}
%% # explode `whosit`;;
%% [`w`; `h`; `o`; `s`; `i`; `t`] : tok list

%% # implode [`c`;`a`;`t`];;
%% `cat` : tok

%% # implode [`cd`;`ab`;`tu`];;
%% evaluation failed     implode
%% \end{verbatim}
%% \end{session}


%% \begin{boxed}
%% \index{ascii@\ttQ{ascii}|pin}
%% \index{ascii_code@\ttQ{ascii\_code}|pin}
%% \begin{verbatim}
%%    int_to_char : int -> char
%%    char_to_int : char -> int
%% \end{verbatim}
%% \end{boxed}

%% The function \ttQ{int\_to\_char} on argument $i$ returns the $ith$ character in
%% \Nuprl's font. The integer $i$ must be non-negative and less than \ttQ{256}.
%% For arguments less than \ttQ{128} the integer-character correspondence is the
%% same as in {\small ASCII}.  The function \ttQ{char\_to\_int} returns integer
%% code of its argument, which must be a one-character token.

%% \begin{boxed}
%% \index{explode@\ttQ{explode}|pin}
%% \index{implode@\ttQ{implode}|pin}
%% \begin{verbatim}
%%    string_to_toks : string -> tok list
%%    toks_to_string : tok list -> string
%% \end{verbatim}
%% \end{boxed}

%% These functions are similar to \ttQ{explode} and \ttQ{implode} except that they
%% work on strings rather than tokens.

%% \begin{boxed}
%% \begin{verbatim}
%%    int_to_tok : int -> tok
%%    tok_to_int : tok -> int
%% \end{verbatim}
%% \end{boxed}

%% These are bound to the obvious type coercion functions, with \ttQ{tok\_to\_int}
%% failing if its argument is not a non-negative integer token.

%% \begin{boxed}
%% \index{ml_curried_infix@\ttQ{ml\_curried\_infix}|pin}
%% \index{ml_paired_infix@\ttQ{ml\_paired\_infix}|pin}
%% \begin{verbatim}
%%    ml_curried_infix : tok -> unit
%%    ml_paired_infix  : tok -> unit
%% \end{verbatim}
%% \end{boxed}\label{sec:ML-infixfns}

%% The functions \ttQ{ml\_curried\_infix} and \ttQ{ml\_paired\_infix} declare their
%% argument tokens to the \ML\ parser as having {\it infix status\/}.
%% Infixed\index{infixes, in ML@infixes, in \ML!currying of} functions can either
%% be curried\index{currying, in ML@currying, in \ML} or take a pair as an
%% argument.  For example, after executing

%% \begin{quote}\vspace*{-2mm}\tt
%%   ml\_paired\_infix `plus`;; \ let x plus y = x+y;;
%% \end{quote}\vspace*{-2mm}
%% \noindent
%% \ttQ{1\ plus\ 2} is synonymous with \ttQ{\$plus(1,2)} and after executing

%% \begin{quote}\vspace*{-2mm}\tt
%% 	ml\_curried\_infix `plus` ;; \ let x plus y = x+y ;;
%% \end{quote}\vspace*{-2mm}
%% \noindent
%% \ttQ{1\ plus\ 2} is synonymous with \ttQ{\$plus 1 2}.%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \footnote{Only ordinary identifiers should be used as infixes; infixing other
%% 	  tokens may have unpredictable effects on~the~parser.}
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \index{bindings, in ML@bindings, in \ML!predeclared|)}


%% % ----------------------------------------
%% \subsection{Predeclared dollared identifiers}
%% % ----------------------------------------

%% \index{prefixes, in ML@prefixes, in \ML|(}
%% \index{identifiers, in ML@identifiers, in \ML!dollared|(}

%% The following prefix\index{prefixes, in ML@prefixes, in \ML} and
%% infix\index{infixes, in ML@infixes, in \ML} operators are provided as primitives
%% (where the dollar\index{dollared infixes, in ML@dollared infixes, in \ML} symbol
%% is omitted from the table; the constants are \ttQ{\$do}, and so on):

%% \begin{boxed}
%% \index{list constructor, in ML@list constructor, in \ML}
%% \index{do@\ttQ{do}|pin}
%% \index{not@\ttQ{not}|pin}
%% \index{ multiplication, in ML@{\small\verb+*+} (multiplication, in \ML)|pin}
%% \index{ division, in ML@{\small\verb+/+} (division, in \ML)|pin}
%% \index{ addition, in ML@{\small\verb7+7} (addition, in \ML)|pin}
%% \index{ subtraction, in ML@{\small\verb+-+} (subtraction, in \ML)|pin}
%% \index{ greater than, in ML@{\small\verb+>+} (greater than, in \ML)|pin}
%% \index{ less than, in ML@{\small\verb+<+} (less than, in \ML)|pin}
%% \index{ equality, in ML@{\small\verb+=+} (equality, in \ML)|pin}
%% \index{ list concatenation, in ML@{\small\verb+"@+} (list concatenation, in
%% 	\ML)|pin}
%% \index{concatenation, of lists!in ML@in \ML}
%% \index{ list constructor, in ML@{\small\verb+.+} (list constructor, in \ML)|pin}
%% \begin{verbatim}
%%    do         : * -> void
%%    not        : bool -> bool
%%    *, /, +, - : int #  int -> int
%%    >, <       : int #  int -> bool
%%     =         : * #  * -> bool
%%     @         : * list #  * list -> * list
%%     .         : * #  * list -> * list
%% \end{verbatim}
%% \end{boxed}

%% \noindent
%% Clarifying remarks:

%% \begin{itemize}\vspace*{-2mm}\setlength{\itemsep}{0mm}
%%   \item \ttQ{\$do} is equivalent to \ttQ{{\bs}x.()}.
%% 	\ttQ{do$\ e$} evaluates $e$ for its side effects.

%%   \item \ttQ{/} returns the integer part of the result of a division,
%% 	for example

%% 	\begin{quote}\vspace*{-2mm}\tt
%% 	   \$/(7,3)  =  7/3  =  2

%% 	   \$/(-7,3) = -7/3  = -2
%% 	\end{quote}\vspace*{-2mm}

%% 	The failure token for division by zero is \ttQ{`div`}.

%% 	\index{failure strings, in ML@failure strings, in \ML!for division by
%% 	zero}

%%   \item \ttQ{-} is the binary subtraction function. Negation (unary minus) is
%% 	not available as a predeclared function of \ML, only as a prefix
%% 	operator. Of course, the user can define negation if he or she
%% 	wishes, e.g. by

%% 	\begin{quote}\vspace*{-2mm}\tt
%% 	   let minus x = -x
%% 	\end{quote}\vspace*{-2mm}

%%   \item Not all dollared infix operators are included above: {\tt\$,} is not
%%        provided since it would be equivalent (as a function) to the identity on
%%        pairs, nor is {\tt \&} as it has no corresponding call-by-value function
%%        (because \ttQ{$e$ \& $e'$} evaluates to \ttQ{false} when $e$ does even if
%%        evaluation of $e'$ would fail to terminate), nor is \ttQ{or} analogously.

%%   \item The period symbol \ttQ{.} is an infixed Lisp cons:

%% 	\ttQ{$x$.[$x_1$;\ldots;$x_n$]} = \ttQ{[$x$;$x_1$;\ldots;$x_n$]}


%%   \item \ttQ{=}\index{equality, in ML@equality, in \ML!weakness of} is bound to
%% 	the expected predicate for an equality test at non-function types, but
%% 	is necessarily rather weak, and may give surprising results, at function
%% 	types.  You can be sure that semantically (i.e.\ extensionally)
%% 	different functions\index{equality, in ML@equality, in \ML!at function
%% 	types} are not equal, and that semantically equivalent functions are
%% 	equal when they originate from the same evaluation of the same textual
%% 	occurrence of a function-denoting expression; for other cases the
%% 	equality of functions is unreliable (i.e.\ implementation dependent).
%% 	For example, after the top-level declarations

%% 	\begin{quote}\vspace*{-2mm}\tt
%% 	   let f x = x+1 and g x = x+2;;

%% 	   let f' = f and h x = f x and h' x = x+1;;
%% 	\end{quote}\vspace*{-2mm}


%% 	\ttQ{f=f'} evaluates to \ttQ{true} and \ttQ{f=g} evaluates to
%% 	\ttQ{false}, but the truth values of \ttQ{f=h}, \ttQ{f=h'}, and
%% 	\ttQ{h=h'} are unreliable. Furthermore, after declaring

%% 	\begin{quote}\vspace*{-2mm}\tt
%% 	   let plus = {\bs}x.{\bs}y.x+y;;

%% 	   let f = plus 1 and g = plus 1;;
%% 	\end{quote}\vspace*{-2mm}


%% 	the truth value of \ttQ{f=g} is also unreliable.

%%   \item \ttQ{@}\index{list concatenation, in ML@list concatenation, in
%% 	 \ML!parser status of} is a predeclared list concatenation operator; the
%% 	 symbol \ttQ{@}\index{ list concatenation, in ML@{\small\verb+"@+} (list
%% 	 concatenation, in \ML)}\index{concatenation, of lists!in ML@in \ML} has
%% 	 a special parser status and cannot be redeclared as a curried infix.

%% \end{itemize}

%% \index{identifiers, in ML@identifiers, in \ML!binding of|)}
%% \index{identifiers, in ML@identifiers, in \ML!dollared|)}
%% \index{identifiers, in ML@identifiers, in \ML!predeclared|)}
%% \index{predeclared bindings, in ML@predeclared bindings, in \ML|)}
%% \index{prefixes, in ML@prefixes, in \ML|)}


%% % ------------------------------------------------------------------------------
%% \section{General Purpose and List Processing Functions}
%% \label{sec:ML-basic-funs}
%% % ------------------------------------------------------------------------------


%% This Section describes a selection of commonly useful \ML\ functions applicable
%% to pairs, lists and other \ML\ values. All the functions are definable in \ML.
%% Each function is documented by:

%% \begin{enumerate}\vspace*{-2mm}\setlength{\itemsep}{0mm}
%%   \item Its name and type.
%%   \item A brief description.
%%   \item An \ML\ declaration defining the function (note that this is not
%%   	necessarily the definition used: some of the functions are coded
%% 	directly in Lisp).
%% \end{enumerate}

%% \noindent Functions preceded by {\tt\$}\index{ escape, in {\ML}
%% parser@{\small\verb+$+} (escape, in \ML\ parser)}\index{infixes, in ML@infixes,
%% in \ML}\index{dollared infixes, in ML@dollared infixes, in \ML} may be used as
%% infix operators (without the {\tt\$}), or in normal prefix form or as arguments
%% to other functions (with the {\tt\$}).

%% The functions usually fail with failure string\index{failure strings, in
%% ML@failure strings, in \ML!of general purpose functions} equal to their name;
%% sometimes, however, the failure string is the one generated by the subfunction
%% that caused the failure.

%% % --------------------------------------------------
%% \subsection{General purpose functions and combinators}
%% % --------------------------------------------------

%% The standard primitive combinators\index{combinators, in ML@combinators, in
%% \ML|(} are: \ttQ{I}, \ttQ{K}, and \ttQ{S}. 

%% \begin{boxed}
%% \index{I, the constant in ML@\ttQ{I}, the constant in \ML|pin}
%% \index{K, the constant in ML@\ttQ{K}, the constant in \ML|pin}
%% \index{S, the constant in ML@\ttQ{S}, the constant in \ML|pin}
%% \begin{verbatim}
%%    I : * -> *
%%    K : * -> ** -> *
%%    S : (* -> ** -> ***) -> (* -> **) -> * -> ***
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \({\tt I}\ x = x\qquad {\tt K}\ x\ y = x\qquad {\tt S}\ f\ g\ x = f\ x\ (g\ x)\)

%% \paragraph*{Definition:}~

%% \bttight
%% \e         let I x = x
%% \e         
%% \e         let K x y = x
%% \e         
%% \e         let S f g x = f x (g x)
%% \et\medskip
  
  
%% \noindent The derived combinators \ttQ{KI} (the dual of \ttQ{K}), \ttQ{C} (the
%% permutator), \ttQ{W} (the duplicator), \ttQ{B} (the compositor) and \ttQ{CB}
%% (which is declared to be infix) have types:

%% \begin{boxed}

%% \index{KI@\ttQ{KI}|pin}
%% \index{C@\ttQ{C}|pin}
%% \index{W@\ttQ{W}|pin}
%% \index{B@\ttQ{B}|pin}
%% \index{CB@\ttQ{CB}|pin}
%% \begin{verbatim}
%%    KI : * -> ** -> **
%%    C  : (* -> ** -> ***) -> ** -> * -> ***
%%    W  : (* -> * -> **) -> * -> **
%%    B  : (* -> **) -> (*** -> *) -> *** -> **
%%    CB : (* -> **) -> (** -> ***) -> * -> ***
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}~

%% \( {\tt KI}\ x\ y = y\qquad
%% {\tt C}\ f\ x\ y = f\ y\ x\qquad
%% {\tt B}\ f\ g\ x = f(g\ x)\qquad
%% {\tt W}\ f\ x = f\ x\ x \qquad
%% {\tt CB}\ f\ g\ x = g(f\ x) \)
%% \vspace*{-2mm}

%% \paragraph*{Definition:}~

%% \bttight
%% \e         let KI = K I
%% \e      
%% \e         let C f x y = f y x
%% \e      
%% \e         let W f x = f x x
%% \e      
%% \e         let B f g x = f(g x)
%% \e      
%% \e         let (f CB g) x = g(f x)
%% \et\medskip


%% \noindent The next group of functions are various useful infixed
%% function-composition\index{function composition, in ML@function composition, in
%% \ML} operators:

%% \begin{boxed}
%% \index{ function composition operator, in ML@{\small\verb+o+} (function composition operator, in \ML)|pin}
%% \index{ product function operator, in ML@{\small\verb+# +} (product function operator, in \ML)|pin}
%% \index{product function operator, in ML@product function operator, in \ML}
%% \index{Co@\ttQ{Co}|pin}
%% \begin{verbatim}
%%    $o  : ((* -> **) #  (*** -> *)) -> *** -> **
%%    $#   : ((* -> **) #  (*** -> ****)) -> (* #  ***) -> (** #  ****)
%%    $Co : ((* -> ** -> ***) #  (**** -> *)) -> ** -> **** -> ***
%% \end{verbatim}
%% \end{boxed}

%% \paragraph*{Description:}

%% \( \begin{array}[t]{ll}
%% 	(f\ {\tt o}\ g)\ x &= f(g\ x)			 	\\[0.3em]
%% 	(f\ {\mbox\small\verb%# %}\ g)(x,y) &= (f\ x,\ g\ y)	\\[0.3em]
%% 	(f\ {\tt Co}\ g)\ x\ y &= {\tt C}(f\ {\tt o}\ g)\ x\ y = f\ (g\ y)\ x
%% \end{array} \)
%% \index{combinators, in ML@combinators, in \ML|)}
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          ml\_paired\_infix `o`
%% \e          let (f o g) x = f(g x)
%% \e
%% \e          ml\_paired\_infix `\#`
%% \e          let (f \# g)(x,y) = (f x, g y)
%% \e
%% \e          ml\_paired\_infix `Co`
%% \e          let (f Co g) x y = f (g y) x
%% \et\medskip

%% \noindent The following two functions convert between curried and uncurried
%% versions of a binary function.

%% \begin{boxed}
%% \index{curry@\ttQ{curry}|pin}
%% \index{uncurry@\ttQ{uncurry}|pin}
%% \begin{verbatim}
%%    curry   : ((* #  **) -> ***) -> (* -> ** -> ***)
%%    uncurry : (* -> ** -> ***) -> ((* #  **) -> ***)
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \({\tt curry}\ f\ x\ y = f(x,y) \qquad {\tt uncurry}\ f\ (x,y) = f\ x\ y \)
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          let curry f x y = f (x,y)
%% \e
%% \e          let uncurry f (x,y) = f x y
%% \et\medskip


%% \noindent The next function tests for failure\index{failure, in ML@failure, in
%% \ML!test for}.

%% \begin{boxed}
%% \index{can@\ttQ{can}|pin}
%% \begin{verbatim}
%%    can : (* -> **) -> * -> bool
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{can\ $f$\ $x$} evaluates to \ttQ{true} if the application of $f$ to $x$
%% succeeds; it evaluates to \ttQ{false} if the evaluation fails.
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          let can f x = (f x; true) ? false
%% \et\medskip


%% \noindent The next function iterates\index{function application, in ML@function application, in \ML!iteration of}\index{iterated function application, in ML@iterated function application, in \ML} a function a fixed number of times.

%% \begin{boxed}
%% \index{funpow@\ttQ{funpow}|pin}
%% \begin{verbatim}
%%    funpow : int -> (* -> *) -> * -> *
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{funpow$\ n\ f\ x$} applies $f$ to $x$ $n$-times: \ttQ{funpow$\ n\ f$} =
%% $f^n$ \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          letrec funpow n f x = if n=0 then x else funpow (n-1) f (f x)
%% \et\medskip


%% \subsection{Miscellaneous list processing functions}

%% The function {\small\verb%length%}
%% computes the length of a list.

%% \begin{boxed}
%% \index{length@\ttQ{length}|pin}
%% \begin{verbatim}
%%    length : * list -> int
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{length [$x_1$;\ldots;$x_n$]} = $n$
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          letrec length = fun [] . 0 | (\_.l) . 1+(length l)
%% \et\medskip


%% \noindent The function \ttQ{append} concatenates\index{ list concatenation, in
%% ML@{\small\verb+"@+} (list concatenation, in \ML)} lists; \ttQ{@} is an
%% uncurried and infixed version of \ttQ{append}\index{concatenation, of lists!in
%% ML@in \ML}.

%% \begin{boxed}
%% \index{append@\ttQ{append}|pin}
%% \begin{verbatim}
%%    append : * list -> * list -> * list
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{append [$x_1$;\ldots;$x_n$] [$y_1$;\ldots;$y_m$]} =
%% \ttQ{$x_1$;\ldots;$x_n$;$y_1$;\ldots;$y_m$]}
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          letrec append l1 l2 = if null l1 then l2 else hd l1.append (tl l1) l2
%% \et\medskip


%% \noindent The function \ttQ{el} extracts a specified element from a list. It
%% fails if the integer argument is less than 1 or greater than the length of the
%% list.

%% \begin{boxed}
%% \index{el@\ttQ{el}|pin}
%% \begin{verbatim}
%%    el : int -> * list -> *
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{el  $i$ [$x_1$;\ldots;$x_n$]}  = $x_i$
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bt
%% \e           letrec el i l =
%% \e             if null l or i < 1 then failwith `el`
%% \e                else if i = 1 then hd l
%% \e                else el (i-1) (tl l)
%% \et\medskip


%% \noindent The functions \ttQ{last} and \ttQ{butlast} compute the last element
%% of a list and all but the last element of a list. Both fail if the argument
%% list is empty.

%% \begin{boxed}
%% \index{last@\ttQ{last}|pin}
%% \index{butlast@\ttQ{butlast}|pin}
%% \begin{verbatim}
%%    last    : * list -> *
%%    butlast : * list -> * list
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%%  \ttQ{last [$x_1$;\ldots;$x_n$]} = $x_n$
%%  \ \
%%  \ttQ{butlast  [$x_1$;\ldots;$x_n$]} =  \ttQ{[$x_1$;\ldots;$x_{n{-}1}$]}
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          letrec last l = last (tl l) ? hd l ? failwith `last`
%% \e
%% \e          letrec butlast l =
%% \e            if null (tl l) then [] else (hd l).(butlast(tl l)) ? failwith `butlast`
%% \et\medskip


%% \noindent The next function makes a list consisting of a value replicated a
%% specified number of times. It fails if the specified number is less than zero.

%% \begin{boxed}
%% \index{replicate@\ttQ{replicate}|pin}
%% \begin{verbatim}
%%    replicate : * -> int -> * list
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{replicate\ $x$\ $n$} evaluates to \ttQ{[$x$;\ldots;$x$]}, a list of length
%% $n$.
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bt
%% \e           letrec replicate x n =
%% \e             if n < 0 then failwith `replicate`
%% \e                else if n = 0 then []
%% \e                else x . (replicate x (n-1))
%% \et\medskip

%% % ----------------------------------------
%% \subsection{List mapping and iterating functions}
%% % ----------------------------------------

%% \begin{boxed}
%% \index{map@\ttQ{map}|pin}
%% \begin{verbatim}
%%    map : (* -> **) -> * list -> ** list
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{map\ $f$\ $l$} returns the list obtained by applying $f$ to the elements of
%% $l$ in turn.  \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          letrec map f l = if null l then [] else f(hd l). map f (tl l)
%% \et\medskip


%% \noindent The following three functions are versions of `reduce'\index{reduce}.

%% \begin{boxed}
%% \index{itlist@\ttQ{itlist}|pin}
%% \index{rev_itlist@\ttQ{rev\_itlist}|pin}
%% \begin{verbatim}
%%    itlist     : (* -> ** -> **) -> * list -> ** -> **
%%    rev_itlist : (* -> ** -> **) -> * list -> ** -> **
%%    end_itlist : (* -> * -> *) -> * list -> *
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \(\setlength{\arraycolsep}{0.5mm}
%% \begin{array}[t]{@{}ll}
%% \ttQ{itlist $f$ [$x_1$;$x_2$;\ldots;$x_n$] $x$}  & =
%% 	f\ x_1\ (f\ x_2\ (\ \ldots\ (f\ x_n\ x)\ \ldots\ ))\\
%%  &=    ((f\ x_1)\ {\tt o}\ (f\ x_2)\ {\tt o}\ \ldots\ {\tt o}\ (f\ x_n))\ x
%%  \\[0.5em]
%% \ttQ{rev\_itlist $f$ [$x_1$;\ldots;$x_{n{-}1}$;$x_n$] $x$} & =
%% 	f\ x_n\ (f\ x_{n-1}\ (\ \ldots\ (f\ x_1\ x)\ \ldots\ ))\\
%%  &= ((f\ x_n)\ {\tt o}\ (f\ x_{n-1})\ {\tt o}\ \ldots\ {\tt o}\ (f\ x_1))\ x
%%  \\[0.5em]
%% \ttQ{end\_itlist $f$ [$x_1$;$x_2$;\ldots;$x_{n{-}1}$;$x_n$]} & =
%% 	f\ x_1\ (f\ x_2\ (\ \ldots\ (f\ x_{n-1}\ x_n)\ \ldots\ ))\\
%%  &= ((f\ x_1)\ {\tt o}\ (f\ x_2)\ {\tt o}\ \ldots\ {\tt o}\ (f\ x_{n-1}))\ x_n\\
%% \end{array} \)
%% \vspace*{-4mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          letrec itlist f l x =
%% \e             if null l then x else f (hd l) (itlist f (tl l) x)
%% \e
%% \e          letrec rev\_itlist f l x =
%% \e             if null l then x else rev\_itlist f (tl l) (f (hd l) x)
%% \e
%% \e          let end\_itlist ff l =
%% \e             if null l then failwith `end\_itlist`
%% \e                       else (let last.rest = rev l in  rev\_itlist ff rest last)
%% \et
%% %\pagebreak

%% \noindent or, equivalently:

%% \bttight
%% \e          letrec itlist f     = fun [] . I | (y.l) . {\bs}x. f y (itlist f l x)
%% \e
%% \e          letrec rev\_itlist f = fun [] . I | (y.l) . {\bs}x. rev\_itlist f l (f y x)
%% \et\medskip

%% % ----------------------------------------
%% \subsection{List searching functions}
%% % ----------------------------------------

%% The functions described in this section search lists for elements with various
%% properties. Those functions that return elements fail if no such element is
%% found; those that return booleans never fail (\ttQ{false} is returned if the
%% element is not found).

%% \begin{boxed}
%% \index{find@\ttQ{find}|pin}
%% \index{tryfind@\ttQ{tryfind}|pin}
%% \begin{verbatim}
%%    find    : (* -> bool) -> * list -> *
%%    tryfind : (* -> **) -> * list -> **
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{find $p$ $l$} returns the first element of $l$ that satisfies the predicate
%% $p$.  \ttQ{tryfind $f$ $l$} returns the result of applying $f$ to the first
%% member of $l$ for which the application of $f$ succeeds.  \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          letrec find p    = fun []    . failwith `find`
%% \e                               | (x.l) . if p x then x else find p l
%% \e
%% \e          letrec tryfind f = fun []    . failwith `tryfind`
%% \e                               | (x.l) . (f x ? tryfind f l)
%% \et\medskip


%% \noindent The next two functions are analogous to the quantifiers $\exists$ and
%% {\all}.

%% \begin{boxed}
%% \index{forall@\ttQ{forall}|pin}
%% \index{exists@\ttQ{exists}|pin}
%% \begin{verbatim}
%%    exists : (* -> bool) -> * list -> bool
%%    forall : (* -> bool) -> * list -> bool
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{exists\ $p$\ $l$} applies $p$ to the elements of $l$ in order until one is
%% found which satisfies $p$, or until the list is exhausted, returning \ttQ{true} or
%% \ttQ{false} accordingly; \ttQ{forall} is the dual.
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          let exists p l = can (find p) l
%% \e
%% \e          let forall p l = not(exists (\$not o p) l)
%% \et\medskip


%% \noindent The next function tests for membership of a list.

%% \begin{boxed}
%% \index{mem@\ttQ{mem}|pin}
%% \begin{verbatim}
%%    mem : * -> * list -> bool
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{mem $x$ $l$} returns \ttQ{true} if some element of $l$ is equal to $x$,
%% otherwise it returns \ttQ{false}.  \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          let mem = exists o (curry \$=)
%% \et\medskip


%% \noindent The following two functions are \ML\ versions of Lisp's \ttQ{assoc}.

%% \begin{boxed}
%% \index{assoc@\ttQ{assoc}|pin}
%% \index{rev_assoc@\ttQ{rev\_assoc}|pin}
%% \begin{verbatim}
%%    assoc     : * -> (* #  **) list -> (* #  **)
%%    rev_assoc : * -> (** #  *) list -> (** #  *)
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{assoc $x$ $l$} searches a list $l$ of pairs for one whose first component
%% is equal to $x$, returning the first pair found as result; similarly,
%% \ttQ{rev\_assoc\ $y$\ $l$} searches for a pair whose second component is equal
%% to $y$. For example:

%% \setcounter{sessioncount}{1}
%% \begin{session}
%% \begin{verbatim}
%% # assoc 2 [(1,4);(3,2);(2,5);(2,6)];;
%% (2, 5) : (int #  int)

%% # rev_assoc 2 [(1,4);(3,2);(2,5);(2,6)];;
%% (3, 2) : (int #  int)
%% \end{verbatim}
%% \end{session}
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          let assoc x     = find ({\bs}(x',y). x=x')
%% \e
%% \e          let rev\_assoc y = find ({\bs}(x,y'). y=y')
%% \et\medskip

%% % ----------------------------------------
%% \subsection{List transforming functions}
%% % ----------------------------------------

%% \noindent The next function reverses a list:

%% \begin{boxed}
%% \index{rev@\ttQ{rev}|pin}
%% \begin{verbatim}
%%    rev : * list -> * list
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{rev [$x_1$;\ldots;$x_n$]} = \ttQ{[$x_n$;\ldots;$x_1$]}
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bt
%% \e           let rev = rev1 []
%% \e              whererec rev1 l = fun [] . l | (x.l') . rev1 (x.l) l'
%% \et\medskip


%% \noindent The following two functions filter a list to the sublist of elements
%% satisfying a predicate.

%% \begin{boxed}
%% \index{filter@\ttQ{filter}|pin}
%% \index{mapfilter@\ttQ{mapfilter}|pin}
%% \begin{verbatim}
%%    filter    : (* -> bool) -> * list -> * list
%%    mapfilter : (* -> **) -> * list -> * list
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{filter\ $p$\ $l$} applies $p$ to every element of $l$, returning a list of
%% those that satisfy $p$; evaluating \ttQ{mapfilter\ $f$\ $l$} applies $f$ to
%% every element of $l$, returning a list of results for those elements for which
%% application of $f$ succeeds.  \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          letrec filter p    = fun []   . []
%% \e                                | (x.l) . if p x then (x.filter p l) else filter p l
%% \e
%% \e          letrec mapfilter f = fun []   . []
%% \e                                | (x.l) . let l' = mapfilter f l in (f x).l' ? l'
%% \et\medskip


%% \noindent The following three functions break-up lists.

%% \begin{boxed}
%% \index{remove@\ttQ{remove}|pin}
%% \index{chop_list@\ttQ{chop\_list}|pin}
%% \index{partition@\ttQ{partition}|pin}
%% \begin{verbatim}
%%    remove    : (* -> bool) -> * list -> (* #  * list)
%%    partition : (* -> bool) -> * list -> (* list #  * list)
%%    chop_list : int -> * list -> (* list #  * list)
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{remove\ $p$\ $l$} separates from the rest of $l$ the first element that
%% satisfies the predicate $p$; it fails if no element satisfies the predicate.
%% \ttQ{partition\ $p$\ $l$} returns a pair of lists. The first list contains the
%% elements of $l$ which satisfy $p$. The second list contains all the other
%% elements of $l$.

%% \begin{center}\vspace*{-2mm}
%%   \ttQ{chop\_list $i$  [$x_1$;\ldots;$x_n$]} = 
%%   \ttQ{[$x_1$;\ldots;$x_i$],[$x_{i{+}1}$;\ldots;$x_n$]}
%% \end{center}\vspace*{-2mm}

%% \noindent {\tt chop\_list} fails if $i$ is negative or greater than $n$.
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          letrec remove p l =
%% \e            if p (hd l) then (hd l, tl l)
%% \e            else (I \# (\r. ((hd l) . r))) (remove p (tl l))
%% \e
%% \e          let partition p l =
%% \e            itlist ({\bs}a (yes,no). if p a then ((a.yes),no) else (yes,(a.no))) l ([],[])
%% \e
%% \e          letrec chop\_list i l =
%% \e            if i = 0 then ([],l)
%% \e            else (let l1,l2 = chop\_list (i-1) (tl l) in  hd l . l1 , l2)
%% \e            ? failwith `chop\_list`
%% \et\medskip


%% \noindent The next function flattens a list of lists:

%% \begin{boxed}
%% \index{flat@\ttQ{flat}|pin}
%% \begin{verbatim}
%%    flat : * list list -> * list
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \(\begin{array}[t]{l}
%%   \ttQ{flat  [[$l_{11}$;\ldots;$l_{1{m_1}}$];
%%   	      [$l_{21}$;\ldots;$l_{2{m_2}}$]; \ldots
%%   	      [$l_{n1}$;\ldots;$l_{n{m_n}}$]]}
%%   \\
%%   = \
%%   \ttQ{[$l_{11}$;\ldots;$l_{1{m_1}}$;
%%         $l_{21}$;\ldots;$l_{2{m_2}}$; \ldots
%%         $l_{n1}$;\ldots;$l_{n{m_n}}$]}
%%   \end{array} \)
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          letrec flat = fun [] . [] | (x.l) . x@(flat l)
%% \et\medskip


%% \noindent The next two functions `zip' and `unzip' between lists of pairs
%% and pairs of lists.

%% \begin{boxed}
%% \index{combine@\ttQ{combine}|pin}
%% \index{split@\ttQ{split}|pin}
%% \begin{verbatim}
%%    combine : (* list #  ** list) -> (* #  **) list
%%    split   : (* #  **) list -> (* list #  ** list)
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \(\begin{array}[t]{lcl}
%%   \ttQ{combine [$x_1$;\ldots;$x_n$] [$y_1$;\ldots;$y_n$]}
%%   & = & 
%%    \ttQ{[($x_1$,$y_1$);\ldots;($x_n$,$y_n$)]}
%%   \\
%%   \ttQ{split [($x_1$,$y_1$);\ldots;($x_n$,$y_n$)]}
%%   & = & 
%%   \ttQ{[$x_1$;\ldots;$x_n$],[$y_1$;\ldots;$y_n$]}
%%   \end{array} \)
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          letrec combine = fun ([],[])         . []
%% \e                            |  ((x.lx),(y.ly)) . ((x,y).combine(lx,ly))
%% \e                            |  \_              \, . failwith `combine`
%% \e         
%% \e          letrec split   = fun []        . ([],[])
%% \e                            |  ((x,y).l) . let lx,ly = split l in (x.lx,y.ly)
%% \et\medskip

%% % ----------------------------------------
%% \subsection{Functions for lists representing sets}
%% %----------------------------------------
  
%% \noindent The following functions behave like the corresponding set-theoretic
%% operations on sets\index{sets, as {\ML} lists@sets, as \ML\ lists} (represented
%% as lists without repetitions).

%% \begin{boxed}
%% \index{intersect@\ttQ{intersect}|pin}
%% \index{subtract@\ttQ{subtract}|pin}
%% \index{union@\ttQ{union}|pin}
%% \begin{verbatim}
%%    intersect : * list -> * list -> * list
%%    subtract  : * list -> * list -> * list
%%    union     : * list -> * list -> * list
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \( \ttQ{intersect  $l_1$ $l_2$} = l_1\cap l_2 \qquad
%%    \ttQ{subtract $l_1$ $l_2$} = l_1-l_2 \qquad
%%    \ttQ{union $l_1$ $l_2$} = l_1\cup l_2 
%% \)
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          let intersect l1 l2 = filter ({\bs}x. mem x l2) l1
%% \e        
%% \e          let subtract l1 l2  = filter ({\bs}x. not(mem x l2)) l1
%% \e        
%% \e          let union l1 l2     = l1 @ subtract l2 l1
%% \et\medskip


%% \noindent There are also functions to test if a list is a set, remove
%% duplicates from a list and test two lists for set equality.

%% \begin{boxed}
%% \index{distinct@\ttQ{distinct}|pin}
%% \index{setify@\ttQ{setify}|pin}
%% \index{set_equal@\ttQ{set\_equal}|pin}
%% \begin{verbatim}
%%    distinct  : * list -> bool
%%    setify    : * list -> * list
%%    set_equal : * list -> * list -> bool
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{distinct\ $l$} returns \ttQ{true} if all the elements of $l$ are distinct;
%% otherwise it returns \ttQ{false}. \ttQ{setify\ $l$} removes repeated elements
%% from $l$, leaving the last occurrence of each duplicate in the list.
%% \ttQ{set\_equal\ $l_1$\ $l_2$} returns \ttQ{true} if every element of $l_1$
%% appears in $l_2$ and every element of $l_2$ appears in $l_1$; otherwise it
%% returns \ttQ{false}. 
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          letrec distinct l =
%% \e           (null l) or (not (mem (hd l) (tl l)) \& distinct (tl l))
%% \e       
%% \e          let setify l = itlist ({\bs}a s. if mem a s then s else a.s) l []
%% \e       
%% \e          let set\_equal l1 l2 = (subtract l1 l2 = []) \& (subtract l2 l1 = [])
%% \et\medskip


%% \subsection{Miscellaneous string processing functions}

%% \index{strings, in ML@strings, in \ML!processing functions for|(}
%% The following functions split strings into `words'; 
%% \ttQ{words2} uses a user supplied separator, while \ttQ{words} uses space and
%% carriage-return as separators.

%% \begin{boxed}
%% \index{words2@\ttQ{words2}|pin}
%% \index{words@\ttQ{words}|pin}
%% \begin{verbatim}
%%    words2 : string -> string -> string list
%%    words  : string -> string list
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \( \begin{array}[t]{ll}
%% 	\ttQ{words2 `$c$` `$s_1 c s_2 c \ldots c s_n$`} & = 
%% 	\ttQ{[`$s_1$`;`$s_2$`; \ldots ;`$s_n$`]}
%% 	\\[0.5em]
%% 	\ttQ{words\ `$s_1\ s_2\ \ldots\ s_n$`} &=
%% 	\ttQ{[`$s_1$`;`$s_2$`; \ldots ;`$s_n$`]}
%% \end{array} \)
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e           let words2 sep string =
%% \e            snd (itlist ({\bs}ch (chs,tokl).
%% \e                            if ch = sep then
%% \e                               if null chs then [],tokl
%% \e                               else [], (implode chs . tokl)
%% \e                            else (ch.chs), tokl)
%% \e                        (sep . explode string)
%% \e                        ([],[]))
%% \e
%% \e           let word\_separators = [` `;`{\bs}L`]
%% \e\pagebreak
%% \e           let words string =
%% \e            snd (itlist ({\bs}ch (chs,tokl).
%% \e                            if mem ch word\_separators then
%% \e                               if null chs then [],tokl
%% \e                               else [], (implode chs . tokl)
%% \e                            else (ch.chs), tokl)
%% \e                        (` ` . explode string)
%% \e                        ([],[]))
%% \et\medskip


%% \noindent The next three functions (the second of which is an infixed version of
%% the first) are string concatenation operators.

%% \begin{boxed}
%% \index{concat@\ttQ{concat}|pin}
%% \index{concatl@\ttQ{concatl}|pin}
%% \index{ string concatenation, in ML@{\small\verb+^+} (string concatenation, in \ML)|pin}
%% \begin{verbatim}
%%    concat  : string -> string -> string
%%    $^      : string -> string -> string
%%    concatl : string list -> string
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{concat} \index{concatenation, of {\ML} strings@concatenation, of \ML\
%% strings} concatenates two strings, {\verb%$^%} is an infixed version of
%% \ttQ{concat}, and 
%% % ------------------------------
%% \linebreak 
%% % ------------------------------
%% \ttQ{concatl} concatenates all the strings in a list of strings.  
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e          let concat s1 s2 = implode(explode s1 @ explode s2)
%% \e         
%% \e          ml\_curried\_infix `{\verb%^%}`
%% \e          let s1 {\verb%^%} s2 = concat s1 s2
%% \e         
%% \e          let concatl sl = implode(itlist append (map explode sl) [])
%% \et\medskip
%% \index{strings, in ML@strings, in \ML!processing functions for|)}


%% \subsection{Failure handling functions}

%% The failure\index{failure, in ML@failure, in \ML!backtrace functions for}
%%  handling functions described here are useful for writing code that
%% fails with a backtrace\index{backtrace}.

%% \begin{boxed}
%% \index{set_fail@\ttQ{set\_fail}|pin}
%% \index{set_fail_prefix@\ttQ{set\_fail\_prefix}|pin}
%% \begin{verbatim}
%%    set_fail_prefix : string -> (* -> **) -> * -> **
%%    set_fail        : string -> (* -> **) -> * -> **
%% \end{verbatim}\end{boxed}

%% \paragraph*{Description:}

%% \ttQ{set\_fail\_prefix\ $s$\ $f$\ $x$} applies $f$ to $x$ and returns the
%% result of the application if it is successful; if the application fails then
%% the string $s$ is concatenated to the failure string and the resulting string
%% propagated as the new failure string.

%% \noindent
%% \ttQ{set\_fail\ $s$\ $f$\ $x$} applies $f$ to $x$ and returns the result of
%% the application if it is successful; if the application fails then the string
%% $s$ is propagated as the new failure string.
%% \vspace*{-2mm}

%% \paragraph*{Definition:} ~

%% \bttight
%% \e           let set\_fail\_prefix s f x \,= f x ?{\bs}s' failwith(concatl[s;`--`;s'])
%% \e
%% \e           let set\_fail s f x        = f x ? failwith s
%% \et\medskip

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\bibliography{../../tex/biblio}

\end{document} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
