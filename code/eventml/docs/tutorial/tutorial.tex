% -*-LaTeX-*-

%%  Copyright (C) 2011 Vincent Rahli
%%  Permission is granted to copy, distribute and/or modify this document
%%  under the terms of the GNU Free Documentation License, Version 1.3
%%  or any later version published by the Free Software Foundation;
%%  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
%%  A copy of the license is included in the section entitled "GNU
%%  Free Documentation License".


\documentclass[final]{article}
%\documentclass[draft]{article}


%%%% PACKAGES

\usepackage{amsmath}
\usepackage{url}
\usepackage{float}
\usepackage{proof}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{changepage}
\usepackage{makeidx}
\usepackage{fancyhdr}
\usepackage[nomargin,inline]{fixme}
\usepackage[usenames,dvipsnames]{color}
%\usepackage{hyperref}
\usepackage{{../../tex/bsymb}}
\usepackage{{../../tex/stmaryrd}}
\usepackage{{../../tex/nuprl}}
\usepackage{{../../tex/MSC}}

%%%% LISTING

\input{../../tex/eventml-listing}
\lstset{basicstyle=\small,language=EventML}

%% \definecolor{EMLgreen}{cmyk}{0.9,0.2,0.9,0.4}
%% \definecolor{EMLpurple}{cmyk}{0.1,0.9,0.14,0.29}
%% \definecolor{EMLpeach}{cmyk}{0,1,1,0.5}


%%%% INDEX

\makeindex


%%%% FIXME

\fxusetheme{color}
\fxuseenvlayout{color}


%%%% BIBLIOGRAPHY

\bibliographystyle{alpha}


%%%% MACROS

\input{../../tex/macros}

\newenvironment{markb}
               {\color{red}}
%               {\color{black}}
               {}
\newenvironment{old}
               {\color{green}}
%               {\color{black}}
               {}
\newenvironment{rahli}
               {\color{blue}}
%               {\color{black}}
               {}
\newenvironment{david}
               {\color{purple}}
%               {\color{black}}
               {}

\newcommand{\dgEML}[1]{{\tt #1}}
\newcommand{\dgclassrel}[3]{\NUPRLclassrel{}{#1}{}{#2}{#3}}
   % NOTE: v \in X(e) is \dgclassrel{e}{X}{v}
\newcommand{\vXe}%
 {\ensuremath{\dgclassrel{\NUPRLevent}{\text{\lstinline{X}}}{\NUPRL{v}}}}
\newcommand{\vYe}
 {\ensuremath{\dgclassrel{\NUPRLevent}{\text{\lstinline{Y}}}{\NUPRL{v}}}}
\newcommand{\listinline}[1]{\text{\lstinline{#1}}}
\newcommand{\bsp}{\mbox{$\NUPRLpair{\NUPRL{b}}{\NUPRLpair{\NUPRL{s}}{\NUPRL{p}}}$}}

\newcommand{\msg}[2]{\ensuremath{[\listinline{#1}:\NUPRL{#2}]}}
\newcommand{\MSG}[2]{[\listinline{#1}:#2]}

%%%% FIGURES

\floatstyle{ruled}
\restylefloat{figure}


%%%% TITLE

\title{Introduction to \eml, version 0.2}
\author{Mark Bickford,
       Robert L. Constable,
       Richard Eaton,\\
       David Guaspari, and
       Vincent Rahli}


\changepage{1in}%textheight
           {1.5in}%textwidth
           {0in}%evensidemargin
           {-1in}%oddsidemargin
           {0in}%columnsep
           {0in}%topmargin
           {0in}%headheight
           {0in}%headsep
           {0in}%footskip


%%%% HEADER AND FOOTER

%\setlength{\headheight}{14.5pt}
\renewcommand\headrulewidth{0pt}
\pagestyle{fancy}
\lhead{}
\rhead{DRAFT --- \today}

\begin{document}


\maketitle

\newpage

\tableofcontents

\newpage

\listoffixmes


\section{Introduction}


\subsection{Specification and Programming}

\eml\ is a functional programming language in the \ML\ family, closely
related to
\cml~\cite{Gordon+Milner+Wadsworth:1979,mi:ml-handbook84a,Kreitz+Rahli:2011}.
It is also a language for coding distributed protocols (such as
Paxos~\cite{VanRenesse:2011}) using high level \emph{combinators} from
the \logicE\ (or Event
Logic)~\cite{Bickford:2009,Bickford+Constable:2008}, hence the name
``\eml''.  The Event Logic combinators are high level specifications
of distributed computations whose properties can be naturally
expressed in Event Logic.  The combinators can be formally translated
(compiled) into the process model underlying Event Logic and thus
converted to distributed programs.  The interactions of these high
level distributed programs manifest the behavior described by the
logic. \eml\ can thus both specify and execute the processes that
create the behaviors, called \emph{event structures}, arising from the
interactions of the processes.

Since \eml\ can directly specify computing tasks using the event
combinators it can carry out part of the task normally assigned to a
theorem prover, formal specification.  \eml\ can also interact with a
theorem prover, presently
\nuprl~\cite{Constable+al:1986,Kreitz:02,Allen+al:2006} (a theorem
prover based on a constructive type theory called
\ctt\ (\CTT)~\cite{Constable+al:1986} and on \cml), which can express
logical properties and constraints on the evolving computations as
formulas of Event Logic and prove them.  From these proofs, a prover
can create \emph{correct-by-construction} process terms which
\eml\ can execute.  Thus \eml\ and \nuprl\ can work together
synergistically in creating a correct by construction concurrent
system.  \eml\ could play the same role with respect to any theorem
prover that implements the \logicE.  Thus \eml\ provides a new
paradigm for creating correct distributed systems, one in which a
systems programmer can design and code a system using event
combinators in such a way that a theorem prover can easily express and
prove logical properties of the resulting computations.
%
To \eml, the event combinators have a dual character.  They have the
\emph{logical character} of specifications and the \emph{computational
  character} of producing event structures with formally guaranteed
behaviors.


\subsection{Interaction with theorem provers}

\eml\ was created to work in \emph{cooperation} with an interactive
theorem prover and to be a key component of a \emph{Logical
  Programming Environment} (\LPE)~\cite{Allen+al:2006}.

In one direction, \eml\ can import logical specifications from the
prover as well as event class specifications and the process code that
realizes them.
%
In the present mode of operation, \eml\ \emph{docks} with the
\nuprl\ prover to obtain this information.

In the other direction, \eml\ can be used by programmers to specify
protocols using event logic combinators.
%
Following the line of work in which \nuprl\ was used to reason about
the
\ENSEMBLE\ system~\cite{Hayden:98a,Birman+al:2000a,Kreitz+Hayden+Hickey:1998,Liu+al:1999}
(coded in \OCAML~\cite{ma:Caml00a}), \eml, by docking to \nuprl,
provides a way to reason about (and synthesize) many distributed
protocols.
%
Thanks to its constructive logic, its expressiveness, and its large
library, \nuprl\ is well suited to reason about distributed
systems~\cite{Bickford+Kreitz+VanRenesse:2001}.
%
But in principle \eml\ can connect to any prover that implements Event
Logic and our General Process
Model~\cite{Bickford+Constable+Guaspari:2011a}.
%
Given an \eml\ specification, the \nuprl\ prover can: (1) synthesize
process code, and (2) generate the \emph{inductive logical form} of
the specification which is used to structure logical description of
the protocols and the system.



%% \begin{rahli}
%% \eml\ is a programming language used to generate asynchronous
%% distributed protocols (such as Paxos~\cite{VanRenesse:2011})
%% %
%% from Event Logic expressions.
%% % communicating by message passing.
%% %
%% It is an extension of
%% \cml~\cite{Gordon+Milner+Wadsworth:1979,mi:ml-handbook84a}, and its
%% \ML\ part is described in a separate
%% document~\cite{Kreitz+Rahli:2011}.
%% %
%% An \eml\ program is a high-level specification of a protocol from
%% which a program can automatically be generated.  Such a program
%% satisfies the corresponding specification.  Using the key concept of
%% \eml, namely \emph{event classes}, one specifies a protocol by
%% describing its flow information in terms of local observations.
%% %
%% Event classes are observers of the information computed by processes
%% on receipt of messages (i.e., when an event happens).  Event classes
%% have two facets: a programming one and a logical one.  On the
%% programming side, event classes can be seen as functions aggregating
%% information from input messages and past observations, and computing
%% appropriate responses.
%% % to these input messages.
%% On the logical side, event classes specify information flow on a
%% network of reactive agents.  There is a logic behind this information
%% flow called the
%% % are defined using the combinators of a logic called the
%% \logicE~\cite{Bickford:2009,Bickford+Constable:2008}.  This logic has
%% been formalized in
%% \nuprl~\cite{Constable+al:1986,Kreitz:02,Allen+al:2006} and allows one
%% to reason about protocols at a high-level of abstraction, for example,
%% to prove their correctness.
%% %
%% \nuprl\ is a \emph{Logical Programming Environment} based on a
%% constructive type theory called \ctt\ (\CTT)~\cite{Constable+al:1986}
%% and on the \ML\ programming language.  Thanks to its constructive
%% logic, its expressiveness, and its large library, \nuprl\ is well
%% suited to reason about distributed
%% systems~\cite{Bickford+Kreitz+VanRenesse:2001}.
%% %
%% Given an \eml\ specification, one can prove its correctness by: (1)
%% \emph{docking} to \nuprl, (2) loading specifications, (3) generating
%% logical formulas (called \emph{inductive logical forms}) corresponding
%% to the classes declared in \eml, and (4) finally by using these
%% formulas to prove properties of the corresponding protocol.  This
%% method is called \emph{correct-by-docking}.
%% %
%% Following the line of work done to reason about the
%% \ENSEMBLE\ system~\cite{Hayden:98a,Birman+al:2000a} using
%% \nuprl~\cite{Kreitz+Hayden+Hickey:1998,Liu+al:1999}, \eml, by docking
%% to \nuprl, provides a way to reason about (and synthesis) many
%% distributed protocols.

%% %% talk more about that work on Ensemble.

%% %% Discuss CML.
%% \end{rahli}


\section{Event Logic}

\subsection{Events, event orderings, and event classes}

The \logicE~\cite{Bickford:2009,Bickford+Constable:2008} is a logic
inspired by the work of Winskel on event
structures~\cite{Winskel:1988}, developed to deal with: (1) events;
(2) their spatial locations; and (3) their ``temporal locations,''
represented as a well-founded partial ordering of these events (causal
order).
%
An event is triggered by receipt of a message; the data of the message
body is called \emph{primitive information\/} of the event.
%
The \logicE\ provides ways to describe events by, among other things
giving access to their associated information.

An \emph{event ordering} is a structure consisting of: (1) a set of
events, (2) a location function $\NUPRLeslocSYMB$ that associates a
\emph{location} with each event, (3) an information function
$\NUPRLinfoSYMB$ that associates primitive information with each
event, and (4) a well-founded \emph{causal ordering} relation on
events $\NUPRLescauslSYMB$~\cite{Lamport:1978}.  An event ordering
represents a single run of a distributed system.

A basic concept in the \logicE\ is an \emph{event
  class}~\cite{Bickford:2009}, which effectively partitions the events
of an event ordering into those it ``recognizes'' and those it does
not, and associates values to the events it recognizes.  Different
classes may recognize the same event and assign it different values.
For example, one class may recognize the arrival of a message and
associate it with its primitive information, the message data.
Another class may recognize that, in the context of some protocol, the
arrival of that message signifies successful completion of the
protocol and assign to it a value meaning ``consensus achieved.''  We
specify a concurrent system in \eml\ by defining event classes that
appropriately classify system events.

%
Event classes have two facets: a programming one and a logical one.
%
On the logical side, event classes specify information flow on a
network of reactive agents by observing the information computed by
the agents when events occur, i.e., on receipt of messages.
%
On the programming side, event classes can be seen as processes that
aggregate information in an internal state from input messages and
past observations, and compute appropriate values for them.
%
%% An event class $\METAeclass$ can be regarded as a process that (1)
%% updates its internal state as a function of the primitive information
%% at an event $\NUPRLevent$, and (2) if $\NUPRLevent$ is in the class
%% $\METAeclass$, produces (or observes) some values (if $\METAeclass$ is
%% the main class in an \eml\ program these will be the responses to
%% $\NUPRLevent$).
%

Formally, an event class $\METAeclass$ is a function whose inputs are
event ordering and an event, and whose output is a bag of values
(observations).  If the observations are of type $\NUPRL{T}$, then the
class $\METAeclass$ is called an event class of type $\NUPRL{T}$.  The
associated type constructor is
%  NOTE: This used to be expressed with dependent types
$\NUPRLclass{\NUPRL{T}}
=\NUPRLarrow
{\NUPRLeventordering}
{\NUPRLarrow
  {\NUPRLese}
  {\NUPRLbag{\NUPRL{T}}}
}$,
%
where $\NUPRLeventordering$ is the type of event orderings and
$\NUPRLese$ the type of events.
%

Expressions denoting events or event orderings do not occur in
\eml\ programs; the types $\NUPRLeventordering$ and $\NUPRLese$ are
not \eml\ types.  We will refer to them when explaining the semantics
of programs or reasoning about them.  In particular, we will speak
about the bag of values returned by a class (at some event) and will
reason about the \emph{event class relation}:%
%
\index{event class relation}%
%
we say that the class $\NUPRL{X}$ observes $\NUPRL{v}$ at event
$\NUPRLevent$ (in an event ordering $\NUPRLes$), and write
$\NUPRLclassrel{\NUPRLes}{\NUPRLevent}{\NUPRL{T}}{\NUPRL{X}}{\NUPRL{v}}$,
if $\NUPRL{v}$ is a member of
$(\NUPRLappclass{\NUPRL{X}}{\NUPRLes}{\NUPRLevent})$.  In our
discussions, $\NUPRLes$ will be clear from context, so our notation
omits it.
%
If the bag of return values is nonempty we say that event
$\NUPRLevent$ is \emph{in} the class $\METAeclass$, and that
$\NUPRLevent$ is an $\METAeclass$-event.  If an event class always
returns either a singleton bag or an empty bag, we call it a
\emph{single-valued}%
%
\index{single-valued}
%
class.

%
Event classes are ultimately defined from one kind of primitive event
class (a \emph{base class}) using a small number of primitive
\emph{class combinators}---though users can define new combinators,
and we supply a useful library of them.  These primitives, and a
variety of useful defined combinators are introduced in the examples
of section~\ref{examples}.  Their definitions are gathered together in
section~\ref{sec:combinators}.

\subsection{Inductive logical forms}

The inductive logical form of a specification is a first order formula
that characterizes completely the observations (the responses) made by
the main class of the specification in terms of the event class
relation.  The formula is inductive because it typically characterizes
the responses at event $\NUPRLevent$ in terms of observations made by
a sub-component at a prior event
$\NUPRLescausl{\NUPRLes}{\NUPRLevent'}{\NUPRLevent}$.
%
Such inductive logical forms are automatically generated in
\nuprl\ from event class definitions, and simplified using various
rewritings.  From an inductive logical form we can prove
invariants of the specification by induction on causal order.

\section{Simple examples}
\label{examples}

We guide the reader through the features of this new
programming/specification language with a series of examples.

%% \subsection{Forwarding}

%% \begin{figure}[!t]
%%   \begin{lstlisting}[basicstyle=\small]
%% specification forward

%% parameter a : Loc ;;
%% parameter b : Loc ;;

%% input    (``echo``    : Unit, base Echo)
%% internal (``forward`` : Unit, base Forward, send forward)

%% main ((\_.\v.{forward b v})|Echo|) @ {a}
%%   \end{lstlisting}
%%   \caption{Forwarding protocol}
%%   \label{fig:forwarding}
%% \end{figure}

%% Let \lstinline{a} and \lstinline{b} be two machines.  We want
%% \lstinline{a} to be able to receive \lstinline{echo} messages and to
%% forward them to \lstinline{b}.


\subsection{Ping-pong}
\label{sec:ping-pong}


\begin{figure}[!t]
  \begin{lstlisting}[basicstyle=\small]
specification ping_pong

(* ------ Imported Nuprl definitions ------  *)
import bag-map

(* ------ Protocol parameters ------ *)
parameter p : Loc
parameter locs : Loc Bag

(* ------ Interface ------ *)
input    start : Loc
internal ping  : Loc
internal pong  : Loc
output   out   : Loc

(* ------ Classes ------ *)
class ReplyToPong (client,loc) =
  let F _ l = if l = loc then {out'send client loc} else {}
  in Once(F o pong'base) ;;
class SendPing (_,loc) = Output(\l.{ping'send loc l}) ;;
class Handler (c,l) = (SendPing (c,l) || ReplyToPong (c,l)) ;;

class Delegate = (\_.\client.bag-map (\l.(client,l)) locs) o start'base;;
class P = Delegate >>= Handler;;

class ReplyToPing = (\loc.\l.{pong'send l loc}) o ping'base ;;

(* ------ Main class ------ *)
main P @ {p} || ReplyToPing @ locs
  \end{lstlisting}
  \caption{Ping-pong protocol}
  \label{fig:ping-pong}
\end{figure}

Consider the following problem: a client wants to run some computation
that involves a certain collection of nodes, but first wants to know
which of them are still alive.
%
To learn that, the client initiates the (trivial) ping-pong protocol,
which will ``ping'' the nodes and tell the client which nodes respond
to the ping.  (This simple protocol does not deal with the fact that
nodes can fail after responding.)

An \eml\ specification requires only that the declaration of an
identifier precede its use.  For readability, however, a specification
is typically presented in the following order: name; imports (from a
library); parameters; messages; variables; class declarations.  Most
of these parts are optional.  Fig.\ref{fig:ping-pong} presents the
full \eml\ specification of the protocol.

\intitle{Specification name}

The keyword \lstinline{specification} marks a specification's name:
\begin{emlcode}
\begin{lstlisting}
specification ping_pong
\end{lstlisting}
\end{emlcode}


\intitle{Imports}

\eml\ provides a library file that is a snapshot of \nuprl's library.
The types in \eml\ are a subset of the types in \nuprl.  Accordingly,
any library function whose type is an \eml\ type can be used in
\eml\ program.  An \lstinline{import} declaration makes library
functions visible:
\begin{emlcode}
\begin{lstlisting}
import bag-map
\end{lstlisting}
\end{emlcode}
The \lstinline{bag-map} operation applies a function, pointwise, to
all elements of a bag:
\[
    \listinline{bag-map}~f~\{a,b,\ldots~\} = \{(f~a), (f~b), \ldots~\}
\]

\intitle{Parameters}

To avoid hardwiring the locations of any participants into the
specification, we declare two parameters: \lstinline{p} is the
location to which clients send their requests; \lstinline{locs} is a
(non-repeating) bag containing the locations of the nodes to be
checked.  To execute the protocol we will instantiate those parameters
as real physical machine addresses.\footnote{As a logical matter, an
  \eml\ program may have parameters of any type definable in \eml.  To
  compile an \eml\ specification, a developer must supply a
  configuration file that instantiates the parameters.  See
  section~\ref{sec:configuration}.}  A client will identify
will include its location in the request it sends, as a return address
for replies.
\begin{emlcode}
\begin{lstlisting}
parameter p : Loc
parameter locs : Loc Bag
\end{lstlisting}
\end{emlcode}

\intitle{Messages and directed messages}

The ping-pong protocol uses four kinds of messages:
%
\index{message}%
%
\begin{emlcode}
\begin{lstlisting}
input    start : Loc
internal ping  : Loc
internal pong  : Loc
output   out   : Loc
\end{lstlisting}
\end{emlcode}
Each of these lines declares a message \emph{kind}.%
%
\index{kind}
%
The elements of a message declaration
\begin{itemize}
\item
identify its \emph{category},%
%
\index{category}
%
using one of the keywords \lstinline{input}, \lstinline{output},
\lstinline{internal}

\lstinline{input} messages are generated by sources outside the
protocol; \lstinline{output} messages are generated by the protocol
and consumed by outside sources; \lstinline{internal} messages are
produced and consumed (only) by the protocol.

\item
provide a (user-chosen) name for the message \emph{kind} (in this
case, \lstinline{start}, \lstinline{ping}, \lstinline{pong}, or
\lstinline{out})

\item
specify the type of the message body (in this case, the contents of
every message exchanged in the protocol is a location).
\end{itemize}
The body of a \lstinline{ping} or \lstinline{pong} message will not,
in fact, be an arbitrary location; it must be one of the locations in
\lstinline{locs}.  However, we cannot formulate that more precise
declaration of these message kinds because \eml\ does not allow
subtype definitions (though \nuprl\ does).

Our discussions will use the notation \msg{start}{x} to denote a
\lstinline{start} message with body $\NUPRL{x}$, etc.
%
\footnote{For technical reasons, the \nuprl\ model represents a
  message as a triple: a list of tokens acting as a message header,
  the message body, and the type.}

A \emph{directed message}%
\index{message!directed}
%
is a pair consisting of a location (the addressee) and a message.  Our
discussions will use the notation $\NUPRL{(loc,msg)}$ to denote the
directed message that addresses message $\NUPRL{msg}$ to location
$\NUPRL{loc}$.  Directed messages have a special semantics.  When a
\emph{main} class (see below) produces a bag of directed messages, a
messaging system attempts to deliver them---i.e., given the directed
message $\NUPRL{(loc,msg)}$, the messaging system attempts to deliver
$\NUPRL{msg}$ to location $\NUPRL{loc}$.  We reason about the effect
of a protocol under assumptions about message delivery.  For present
purposes, we assume that all messages are eventually delivered at
least once, but make no assumption about transit times or the order in
which messages are delivered.

Message declarations automatically introduce certain operations and
event classes:
\begin{itemize}
\item
Every declaration of an \lstinline{input} or \lstinline{internal}
message kind \lstinline{foo} automatically introduces a \emph{base}
class,
%
\index{classes!base class}
%
denoted \lstinline{foo'base}, an event class that recognizes the arrival
of a \lstinline{foo} message and observes its body (and recognizes
messages of no other kind).

More precisely, the arrival of a message \msg{foo}{msg} at location
$\NUPRL{l}$, causes an event $\NUPRLevent$ to happen at $\NUPRL{l}$;
and when $\NUPRLevent$ occurs, \lstinline{foo'base} observes the
content of that message.  (Equivalently, we say that
\lstinline{foo'base} returns $\{\NUPRL{msg}\}$; or we say that
$\dgclassrel{e}{\listinline{foo'base}}{\NUPRL{v}}$ if and only if
$\NUPRL{v} = \NUPRL{msg}$.)

\item
Every declaration of an \lstinline{output} or \lstinline{internal}
message kind \lstinline{foo} automatically introduces functions
\lstinline{foo'send} and \lstinline{foo'broadcast} that are used to
construct directed messages or bags of them.  (These are the only way
to construct such messages---thus, we assume that the messages they
construct cannot be forged.)

If $\NUPRL{l}$ is a location and $\NUPRL{msg}$ is of the appropriate
type
\[
(\listinline{foo'send}~\NUPRL{l}~\NUPRL{msg}) =
\NUPRL(l,\msg{foo}{m})
\]
the directed message for sending \msg{foo}{m} to $\NUPRL{l}$.

If the $\NUPRL{l_i}$ are locations and $\NUPRL{msg}$ is of the
appropriate type
\[
\listinline{foo'broadcast}~\{l_1,\ldots,l_n\}~\NUPRL{msg} =
  \{(l_1,\msg{foo}{msg}), \ldots, (l_n,\msg{foo}{msg}) \}
\]
a bag of directed messages containing a
\msg{foo}{msg} message for each location $\NUPRL{l_i}$.
\end{itemize}

%% %
%% ---which we may formally express in either of two ways:
%% \begin{itemize}
%% \item
%% $\dgclassrel{\NUPRLevent}{\listinline{start'base}}{v}$ if and only if $v=s$
%% \item
%% At $\NUPRLevent$, \lstinline{start'base} returns the singleton bag $\{s\}$
%% \end{itemize}

Ultimately, all \eml\ programs are defined by applying combinators to
base classes, which are the only primitive
classes.\footnote{Technically, this is not quite true: It would be
  possible to define an event class in the \nuprl\ library and import it
  into an \eml\ program.}  We assume that any computing system on
which we wish to implement \eml\ provides the means to implement base
classes.

\intitle{The protocol}

The ping-pong protocol proceeds as follows:
\begin{enumerate}
\item
It begins when a message of the form \msg{start}{client} arrives at
location \lstinline{p}.  (Replies to this message will be sent to
$\NUPRL{client}$.)

\item
A supervisory class, \lstinline{P}, will then spawn several classes at
location \lstinline{p}.  For each $\NUPRL{l}$ in \lstinline{locs}, it
spawns the class \lstinline{Handler}($\NUPRL{client}$,$\NUPRL{l}$),
which will handle communications with node $\NUPRL{l}$.

\item\label{handler-ping}
  \lstinline{Handler}$(\NUPRL{client},\NUPRL{l})$ sends a
  \MSG{ping}{\lstinline{p}} message to the node at location
  $\NUPRL{l}$ and waits for a response.

\item
On receipt of a \MSG{ping}{\lstinline{p}} message, the
\lstinline{ReplyToPing} class at node $\NUPRL{l}$ sends a
\msg{pong}{l} message back to \lstinline{p}.

\item\label{handler-out}
On receipt of this \msg{pong}{l} message,
\lstinline{Handler}($\NUPRL{client}$,$\NUPRL{l}$) sends an
\msg{out}{l} message to $\NUPRL{client}$ and terminates.
\end{enumerate}
Intuitively, \lstinline{Handler} is a parameterized class---but,
because \eml\ is a higher-order language, we need no special generic
or template construct in order to express that.
%
\index{classes!parameterized class}
%
An event class parameterized by values of type $\NUPRL{T}$ is simply a
function that inputs values of type $\NUPRL{T}$ and outputs event
classes.

\intitle{Class combinators}

Our specification uses the following class combinators, all of them
provided in the standard library:
\begin{itemize}
\item
\lstinline{Output(f)}:%
\index{class combinators!Output combinator}%
%
If $\listinline{f}:\NUPRLarrow{\NUPRLloc}{\NUPRLbag{\NUPRL{T}}}$,
\lstinline{Output(f)} is the class that, in response to the
first event it sees at location
$\NUPRL{l}$, returns the bag of values $(\listinline{f}~\NUPRL{l})$;
it then terminates.

\item
\lstinline{X || Y}:%
%
\index{class combinators!parallel combinator}%
%
This event class is the parallel composition of classes \lstinline{X}
and \lstinline{Y}.  It recognizes events in either \lstinline{X} or
\lstinline{Y}, and observes a value iff either \lstinline{X} or
\lstinline{Y} observes it.  The parallel combinator is a primitive.

\item
\lstinline{X >>= Y}:%
%
\index{class combinators!delegation}%
\index{class combinators!bind}%
%
This is the \emph{delegation}, or \emph{bind},
combinator.\footnote{The class type forms a monad and delegation is
  the bind operator of that monad.}  If
\lstinline{X} is an
event class and \lstinline{Y} is a function that returns event classes,
%
\lstinline{X >>= Y}
%
is the event class that, whenever it recognizes an event, acts as
follows: For each \vXe, it ``spawns'' the class
(\lstinline{Y}~$\NUPRL{v}$).  (Events in this spawned class will occur
at the same location as $\NUPRLevent$ and causally after it.  We
temporarily defer a more precise discussion of its meaning.)
Delegation is primitive.

\item
\lstinline{f o X}:%
%
\index{class combinators!simple composition combinator}%
%
This is well typed if \lstinline{f} is a function that takes as
arguments a location and a value, and returns a bag.  It acts as
follows (for the case of a single-valued class): when \vXe and
$NUPRLevent$ has location $\NUPRL{loc}$, \lstinline{f o X} returns
$(\listinline{f}~\NUPRL{loc}~\NUPRL{v})$.  This \emph{simple
  composition} combinator is ``almost primitive.''  It is defined in
terms of a primitive combinator that is somewhat more expressive but
rarely, if ever, used.  (This combinator is described in more detail
in the discussion, below, of class \lstinline{ReplyToPong}.)

\item
\lstinline{Once(X)}:%
\index{class combinators!Once combinator}%
%
This class responds only to the first \lstinline{X}-event at any
location and, at such an event, behaves like \lstinline{X}.  That is,
$\dgclassrel{\NUPRLevent}{(\text{\lstinline{Once(X)}})}{v}$ iff
\vXe\ and there was no $\NUPRL{X}$-event prior at location
$\NUPRLesloc{}{\NUPRLevent}$ prior to $\NUPRLevent$.  \lstinline{Once}
is a defined combinator that our compiler treats specially, because it
knows that the process \lstinline{Once(X)} can be killed and cleaned
up after it has recognized one event.

\item
\lstinline{X@b}:%
%
\index{class combinators!``at'' combinator}%
%
This is the restriction of \lstinline{X} to the locations in the bag
\lstinline{b}:
$\dgclassrel{\NUPRLevent}{\listinline{(X@b)}}{\NUPRL{v}}$ iff
$\NUPRLevent$ occurs at a location in \lstinline{b} and \vXe.
Operationally, it means ``run the program for \lstinline{X} at each
location in \lstinline{b}.''
\end{itemize}
%

\intitle{The ``main'' class}\label{main}
%
\index{classes!main}
%

The keyword \lstinline{main} identifies the event class that
compilation of an \eml\ specification will actually implement (given
appropriate instantiations of its parameters).
The main program of the ping-pong program is the parallel composition
of the supervisory class \lstinline{P} running at location
\lstinline{p} and \lstinline{ReplyToPing} running at all the locations
in \lstinline{locs}:
\begin{emlcode}
\begin{lstlisting}
main P @ {p} || ReplyToPing @ locs
\end{lstlisting}
\end{emlcode}

\intitle{Spawning of handlers (delegation to sub-processes)}

The supervisory class \lstinline{P} uses the delegation combinator%
\index{class combinators!delegation}%
%
to spawn a handler for each request.
\begin{emlcode}
\begin{lstlisting}
class P = Delegate >>= Handler;;
\end{lstlisting}
\end{emlcode}
We will define \lstinline{Delegate} so that, in response to
\msg{start}{x}, returns the bag \(\{(\listinline{x},l_1),
(\listinline{x},l_2), \ldots\}\), where the $\NUPRL{l_i}$ are the
elements of \lstinline{locs}.  Each element of this bag is the initial
data needed by one of the spawned classes.  The effect of
\lstinline{Delegate >>= Handler} is therefore to spawn a class
(\lstinline{Handler}~$\NUPRL{(client,l_i)}$) for each $i$.  Notice how
the types match up: \lstinline{Delegate} is an event class of type
\lstinline{Loc * Loc}; \lstinline{Handler} will be a function mapping
values of type \lstinline{Loc * Loc} to event classes of type directed
message.  Therefore
%
\lstinline{Delegate >>= Handler} is an event class that returns (bags
of) directed messages.

Consider the definition of \lstinline{Delegate}, which we've rewritten
by introducing the locally defined function \lstinline{f}.
\begin{lstlisting}
class Delegate =
   let f = \client.bag-map (\l.(client,l)) locs in
      (\_.f) o start'base ;;
\end{lstlisting}
The ``\lstinline{_}'' is used, as in ML, as the name of a variable
whose value is ignored.

When a \msg{start}{x} message arrives, we want \lstinline{Delegate} to
return the bag
\[
\listinline{f}~x = \{\NUPRLpair{x}{l_1}, \NUPRLpair{x}{l_2}, \ldots\}
\]
where \lstinline{locs}~=~$\{l_1, l_2,\ldots\}$.  Intuitively, 
the simple composition operator %
\index{class combinators!simple composition combinator}%
%
transforms observed values by applying a function.  However, the
function we use is not \lstinline{f} but \lstinline{\_.f}.  The reason
is that the location of an event is also observable; accordingly, we
define ``\lstinline{g o X}'' so that that \lstinline{g} takes
\emph{two} arguments: the location of the event and a value observed
by \lstinline{X}.  It so happens that in this case, the location is
ignored.  We give a precise definition of this combinator at the end
of this section.

\noindent
\intitle{Handler}

Interactions betwen the \lstinline{Handler} classes spawned by
\lstinline{P} and the nodes carry out steps
(\ref{handler-ping})--(\ref{handler-out}) of the protocol.  The input
to the higher-type function \lstinline{Handler} is a pair of
locations: the client location and the location to ping.  The
resulting handler is the parallel composition of two other
parameterized classes: \lstinline{SendPing}, which executes
step~(\ref{handler-ping}) of the protocol, and
\lstinline{ReplyToPong}, which executes step~(\ref{handler-out}).

\begin{emlcode}
\begin{lstlisting}
class Handler (c,l) = (SendPing (c,l) || ReplyToPong (c,l)) ;;
\end{lstlisting}
\end{emlcode}
By the definition of the parallel combinator,
\lstinline{Handler}~$\NUPRL{(c,l)}$ computes everything that either
\lstinline{SendPing}~$\NUPRL{(c,l)}$ or
  \lstinline{ReplyToPong}~$\NUPRL{(c,l)}$ does.

\lstinline{SendPing}~$\NUPRL{(c,l)}$ is in charge of only one task:
  send a \lstinline{ping} message to \lstinline{l}.
\begin{emlcode}
\begin{lstlisting}
class SendPing (_,loc) = Output(\l.{ping'send loc l}) ;;
\end{lstlisting}
\end{emlcode}
By the definitions of \lstinline{Output} and \lstinline{ping'send}
given above, an instance of \lstinline{SendPing}$\NUPRL(client,loc)$%
%
\index{class combinators!Output combinator}%
%
running at location $\NUPRL{l}$ will respond to the first event it
sees at $\NUPRL{l}$ by directing a \lstinline{ping}
message with body $\NUPRL{l}$ to location $\NUPRL{loc}$; it will then
terminate.  The recipient will interpret $\NUPRL{l}$ as a return
address.
%

\lstinline{ReplyToPong}~$\NUPRL{(client,loc)}$ waits for a
\lstinline{pong} message from the node at location $\NUPRL{loc}$ and,
on receiving one, sends \msg{out}{l} to location $\NUPRL{client}$.  It
therefore responds to a \emph{subset} of the events recognized by the
base class \lstinline{pong'base}: not every \lstinline{pong} message,
but only those sent from $\NUPRL{loc}$, i.e., those whose message body
is $\NUPRL{loc}$.  If
$\dgclassrel{\NUPRLevent}{\text{\lstinline{pong'base}}}{\NUPRL{v}}$,
\lstinline{ReplyToPong} generates an output by applying the following
function to $\NUPRL{v}$:
\begin{lstlisting}
    \l.if l = loc then {out'send client loc} else {}
\end{lstlisting}
and then terminates.  This is the essence of the locally defined
function \lstinline{F} in
\begin{emlcode}
\begin{lstlisting}
class ReplyToPong (client,loc) =
  let F _ l = if l = loc then {out'send client loc} else {}
  in Once(F o pong'base) ;;
\end{lstlisting}
\end{emlcode}
Once again, because the response doesn't depend on the location at
which the input event occurred, the first argument to \lstinline{F} is
a dummy.


%% Let us consider the case where $n=2$.  Let $\NUPRL{X}$ and $\NUPRL{Y}$
%% be classes observing integers.  Let us define a new class $\NUPRL{C}$
%% that combines these two classes to create a class that makes
%% observations only when $\NUPRL{X}$ and $\NUPRL{Y}$ observe the same
%% integer:
%% \begin{emlcode}
%%   \begin{lstlisting}
%%     let C = let F loc x y = if x = y then {x} else {}
%%             in F|X;Y|;;
%%   \end{lstlisting}
%% \end{emlcode}
%% Note that the type of \lstinline{F} is
%% \lstinline{Loc -> Int -> Int -> Int Bag}.
%% %
%% If at event $\NUPRLevent$, $\NUPRL{X}$ observes $\NUPRLtermbag{1;2}$
%% and $\NUPRL{Y}$ observes $\NUPRLtermbag{2;3;4}$, then for each pair
%% $\NUPRLpair{\NUPRL{a}}{\NUPRL{b}}$ in the bag
%% $\NUPRLtermbag{\NUPRLpair{1}{2};\NUPRLpair{1}{3};\NUPRLpair{1}{4};\NUPRLpair{2}{2};\NUPRLpair{2}{3};\NUPRLpair{2}{4}}$,
%% the function $\NUPRL{F}$ gets applied to
%% $\NUPRLesloc{\NUPRLes}{\NUPRLevent}$, $\NUPRL{a}$, and $\NUPRL{b}$.
%% Finally, because $2=2$, then $\NUPRL{C}$ only observes the integer
%% $2$, i.e., it observe the integer bag $\NUPRLtermbag{2}$.
%% %
%% Note that if $\NUPRL{X}$ had observed $\NUPRLtermbag{1;2;3}$ at event
%% $\NUPRLevent$, then $\NUPRL{C}$ would have observed
%% $\NUPRLtermbag{2;3}$.

\intitle{ReplyToPing}

\lstinline{ReplyToPing} defines a program that must run at each node
that will be pinged.
\begin{emlcode}
\begin{lstlisting}
class ReplyToPing = (\loc.\l.{pong'send l loc}) o ping'base ;;
\end{lstlisting}
\end{emlcode}
This time the transformation function makes use of the initial
location argument.  When the class
%
(\lstinline!(\loc.\l.{pong'send l loc}) o ping'base!),
%
running at location $\NUPRL{s}$, receives \msg{ping}{l} it sends
\msg{pong}{s} to location $\NUPRL{l}$.

\intitle{Programmable classes}

No base class can be a main program. For example,
\lstinline{start'base} recognizes the arrival of every
\lstinline{start} message at any node whatsoever; but this abstraction
cannot be implemented: we cannot install the necessary code on every
node that exists (whatever that may mean).  However,
\lstinline{start'base} is \emph{locally programmable} in the sense
that we can implement any class that results from restricting it to a
finite set of locations.  All base classes are locally programmable
and all primitive class combinators preserve the property of being
locally programmable, so every class definable in an \eml\ program is
locally programmable.\footnote{This needs a qualification: One could
  define a class in \nuprl\ that is not locally programmable and then
  import it from the \nuprl\ library; one could similarly introduce a
  pathological combinator.  If that is done, the first step of
  compilation---verifying that the main program is
  programmable---would fail.}

A class is \emph{programmable} if it is equivalent to the restriction
of a locally programmable class to a finite set of locations.
Declaring a class as a main program incurs the obligation to prove
that it is programmable.  Using the ``\lstinline{__@__}'' combinator,
and the fact that primitive combinators also preserve the property of
being programmable, we can automatically prove that any idiomatically
defined main program is programmable.

\intitle{Simple composition, in detail}

One can apply simple composition
\index{class combinators!simple composition combinator}%
%
to any number of classes.  Given $n$ classes $\NUPRL{X_1}$, \dots,
$\NUPRL{X_n}$, of types $\NUPRL{T_1}$, \dots, $\NUPRL{T_n}$
respectively, and given a function $\NUPRL{F}$ of type
%
$\NUPRLarrow
{\NUPRLloc}
{\NUPRLarrow
  {\NUPRL{T_1}}
  {\NUPRLarrow
    {\cdots}
    {\NUPRLarrow
      {\NUPRL{T_n}}
      {\NUPRLbag{\NUPRL{T}}}
    }
  }
}$,
%
one can define a class $\NUPRL{C}:\NUPRLclass{\NUPRL{T}}$ by
$\NUPRL{C}=\NUPRLsimplecombn{\NUPRL{F}}{\NUPRL{X_1}}{\NUPRL{X_n}}$.

Intuitively, $\NUPRL{C}$ processes an event $\NUPRLevent$ as follows.
The first argument supplied to $\NUPRL{F}$ is the location at which
$\NUPRLevent$ occurs; the successive arguments are, in order, the
values observed by the classes $\NUPRL{X_i}$ at $\NUPRLevent$; and
$\NUPRL{C}$ returns the bag that $\NUPRL{F}$ computes from these
inputs.  That description leaves it unclear what to do if, for some
$i$, $\NUPRLevent$ is not an $\NUPRL{X_i}$-event, or what to do if for
some $i$, $\NUPRL{X_i}$ produces a bag with more than one element.

Here is a more precise formulation.  $\NUPRL{C}$ produces (observes) the
element $\NUPRL{v}$ of type $\NUPRL{T}$ iff each class $\NUPRL{X_i}$
observes an element $\NUPRL{v_i}$ of type $\NUPRL{T_i}$ at event
$\NUPRLevent$ and $\NUPRL{v} =\NUPRLappn
{\NUPRLapp{\NUPRL{f}}{\NUPRLesloc{\NUPRLes}{\NUPRLevent}}}
{\NUPRL{v_1}} {\NUPRL{v_n}}$.
%
Therefore, a $\NUPRL{C}$-event must be an $\NUPRL{X_i}$-event for all
$i\in\{1,\dots,n\}$.
%
If for some $i\in\{1,\dots,n\}$, $\NUPRL{X_i}$ does not observe
anything at event $\NUPRLevent$, then neither does $\NUPRL{C}$.


\subsection{Ping-pong with memory}
\label{sec:ping-pong-mem}

We now make our ping-pong protocol a bit more interesting by adding
some memory to the main process.  We introduce a new integer
parameter, \lstinline{threshold}; instead of sending an \msg{out}{l}
message to the client whenever node $\NUPRL{l}$ responds to a pong, we
wait until a total of \lstinline{threshold} responses have been
received, and then notify the client by sending a message
\msg{out}{[l_1;l_2;\ldots;l_{threshold}]}, whose body is the list of
all responders.  We modify the design of ping-pong by adding one more
(parameterized) class, a memory module: Instead of sending an
\lstinline{out} message directly to a client,
\lstinline{ReplyToPong} will send an \lstinline{alive} message to an
appropriate memory module, which will accumulate responses and send an
\lstinline{out} message to the client once it has received enough of
them.

And we add one more twist.  A client who sends multiple
\lstinline{start} messages will receive multiple \lstinline{out}
messages in reply and may need to know what request any
\lstinline{out} message is replying to.  So the client will attach
an integer id (we will call it a \emph{request number}) to its
\lstinline{start} messages; that request number will be included in
the \lstinline{out} message it receives.  The request numbers need
not be globally unique identifiers, so we will also arrange for the
supervisory class \lstinline{P} to attach a global id (which we
will call a \emph{round}) to each request that it receives.  The protocol
proceeds as follows:

\begin{enumerate}
\item
\lstinline{P} receives a $\MSG{start}{\NUPRLpair{client}{req\_num}}$
message from the location $\NUPRL{client}$.

\item\label{P-PState-Round}
\lstinline{P} generates a unique id, $\NUPRL{round}$, for the request
and spawns the following:
  \begin{itemize}
  \item
  for each node $\NUPRL{l}$ in \lstinline{locs}, a class
  \lstinline{Handler}$(\NUPRL{l},\NUPRL{round})$
  \item
  a memory module
  $(\listinline{Mem}~\NUPRL{client}~\NUPRL{req\_num}~\NUPRL{round})$
  \end{itemize}

\item\label{handler-m-ping}
\lstinline{Handler}($\NUPRL{l}$,$\NUPRL{round}$) sends a
\MSG{ping}{$\NUPRLpair{\listinline{p}}{round}$} message to the
node at location $\NUPRL{l}$ and waits for a reply.

\item
On receipt of \MSG{ping}{$\NUPRLpair{\listinline{p}}{round}$} the
  \lstinline{ReplyToPing} class at node $\NUPRL{l}$ sends a
  \MSG{pong}{$\NUPRLpair{\listinline{l}}{round}$} message to
    \listinline{p}.  \lstinline{Handler} classes respond to
    \lstinline{pong} messages.

\item\label{handler-m-alive}
On receipt of
\MSG{pong}{$\NUPRLpair{l}{round}$}, the class
$\listinline{Handler}(\NUPRL{l},\NUPRL{round})$ sends an
\MSG{alive}{$\NUPRLpair{l}{round}$} message to
itself (location \lstinline{p}).  \lstinline{Mem} classes respond to
\lstinline{alive} messages.

\item
When
(\lstinline{Mem}~$\NUPRL{client}$~$\NUPRL{req\_num}$~$\NUPRL{round}$)
has seen \lstinline{alive} messages from
$\NUPRL{threshold}$ distinct locations, it sends to location
$\NUPRL{client}$ an appropriate \lstinline{out} message tagged with
$\NUPRL{req\_num}$.

\end{enumerate}
Fig.~\ref{fig:ping-pong-mem} provides the full specification of this
protocol.  Most of it is a routine adaptation of the ping-pong
specification.  The novelty lies in the introduction of the event
classes \lstinline{PState} and \lstinline{Mem} that act like state
machines.  We will describe these in detail.


\begin{figure}[!t]
  \begin{lstlisting}[basicstyle=\small]
specification m_ping_pong

(* ------ Imported Nuprl declarations ------ *)
import bag-map deq-member length

(* ------ Parameters ------ *)
parameter p         : Loc
parameter locs      : Loc Bag
parameter threshold : Int

(* ------ Interface ------ *)
input    start : Loc * Int
internal ping  : Loc * Int
internal pong  : Loc * Int
internal alive : Loc * Int
output   out   : Loc List * Int

(* ------ Classes ------ *)
class ReplyToPong p =
  let F slf q = if p = q then {alive'send slf p} else {}
  in F o pong'base ;;
class SendPing (loc,round) = Output(\l.{ping'send loc (l,round)}) ;;
class Handler p = SendPing p || ReplyToPong p ;;

class MemState round =
  let F _ (loc:Loc,r:Int) L =
    if r = round & !(deq-member (op =) loc L) then {loc.L} else {L}
  in F o (alive'base,Prior(self)?{[]});;
class Mem client req_num round =
  let F _ L = if length L >= threshold then {out'send client (L,req_num)} else {}
  in F o (MemState round);;

class Round (client, req_num, round) =
     (Output(\_.locs) >>= \l.Handler (l,round))
  || Once(Mem client req_num round);;

class PState =
  let F loc (client,req_num) (_,_,n) = {(client, req_num, n + 1)}
  in F o (start'base,Prior(self)?(\l.{(l,0,0)}));;
class P = PState >>= Round;;

class ReplyToPing = (\loc.\(l,round).{pong'send l (loc,round)}) o ping'base ;;

(* ------ Main class ------ *)
main P @ {p} || ReplyToPing @ locs
  \end{lstlisting}
  \caption{Ping-pong protocol with memory}
  \label{fig:ping-pong-mem}
\end{figure}

%\clearpage

\intitle{Imported library functions}

The specification imports two \nuprl\ functions.
\begin{itemize}
\item
 \lstinline{length}, which computes the length of a list

\item\label{deq-member}
\lstinline{deq-member}, which checks whether an element belongs to a
list

To apply this to lists of type $\NUPRL{T}$ we must also supply an
operation that decides equality for elements of $\NUPRL{T}$.  That
operation is a parameter to the membership test; thus, we write
\lstinline{(deq-member eq y lst)} to compute the value of the boolean
``\lstinline{y} is a member of list \lstinline{lst}, based on the
equality test \lstinline{eq}.''
\end{itemize}

\intitle{Class combinators}

The specification uses the three remaining primitive combinators:
\begin{itemize}
\item
  \lstinline{Prior(X)}:%
  \index{class combinators!Prior combinator}%
  %
  Event $\NUPRLevent$ belongs to \lstinline{Prior(X)} if some
  \lstinline{X}-event has occurred at $\NUPRLesloc{}{\NUPRLevent}$
  strictly before event $\NUPRLevent$; if so, its value is the value
  returned by \lstinline{X} for the most recent such
  \lstinline{X}-event.  Once an \lstinline{X}-event has occurred at
  location $\NUPRL{l}$, all subsequent events at $\NUPRL{l}$ are
  \lstinline{Prior(X)}-events.

\item
  \lstinline{X?f}:%
  \index{class combinators!? combinator}%
  %
  For any class \lstinline{X} of type \lstinline{T}, and any function
  $\listinline{f}:\NUPRLarrow{\NUPRLloc}{\NUPRLbag{\listinline{T}}}$,
  \lstinline{X?f} has the following meaning:
  \[
  \dgclassrel{e}{\listinline{(X?f)}}{v} \qquad \text{iff} \qquad
  \begin{cases}
    \dgclassrel{e}{\listinline{X}}{v} &
    \text{if $\NUPRLevent$ is an \listinline{X}-event} \\
    v \in \listinline{f}(\NUPRLesloc{}{\NUPRLevent}) &
    \text{otherwise}
  \end{cases}
  \]
  If $(\listinline{f}~\NUPRL{l})$ is nonempty, then all events at
  location $\NUPRL{l}$ are (\lstinline{X?f})-events.

\item
  \lstinline{self}:%
  \index{class combinators!recursive composition combinator}%
  %
  The underlying semantic model of \eml\ has powerful operators for
  defining event classes by recursion, including mutual recursion.
  However, \eml\ itself currently provides only a simple recursion
  scheme, which has been adequate for all the practical examples we have
  considered.  The keyword \lstinline{self} can occur only in contexts
  such as
  \begin{lstlisting}
    class X = G (Prior(self)?f)
  \end{lstlisting}
  where, instead of being simply an argument to a function,
  \lstinline{Prior(self)?f} could be a subterm of a more general
  expression.  As a result of this definition \lstinline{X} satisfies
  the fix-point equation
  \begin{lstlisting}
    X = G (Prior(X)?f)
  \end{lstlisting}
  that specifies the value of \lstinline{X} at any event $\NUPRLevent$
  in terms of its value at the immediately prior \lstinline{X}-events;
  or, if there is no prior \lstinline{X}-event, in terms of
  $\listinline{f}(\NUPRLesloc{}{\NUPRLevent})$.  Examples will make
  this clear.
\end{itemize}

\intitle{\lstinline{P} and \lstinline{PState}}

Class \lstinline{P} uses \lstinline{PState} to generate a unique round
number for each request, and passes that to \lstinline{Round}, which
in turn performs step~\ref{P-PState-Round} of the protocol.  The
definition of \lstinline{PState} is recursive.
\begin{emlcode}
\begin{lstlisting}
class PState =
  let F loc (client,req_num) (_,_,n) = {(client, req_num, n + 1)}
  in F o (start'base,Prior(self)?(\l.{(l,0,0)}));;
\end{lstlisting}
\end{emlcode}

This defines a state machine as follows:
\begin{itemize}
\item
\lstinline{start'base}-events trigger change of state.

\item
The state type of \lstinline{PState} is
%
\lstinline{(Loc * int * int)}.  The state components represent,
respectively: the client whose request has caused the state change,
the request number assigned by the client, and the most recent round
number generated by \lstinline{PState}.

\item
For any \lstinline{start'base}-event $\NUPRLevent$,
$\dgclassrel{\NUPRLevent}{\listinline{PState}}{v}$ iff $\NUPRL{v}$ is
the state of \lstinline{PState} after it has processed  event
$\NUPRLevent$.

\item
The initial value of the state at location $\NUPRL{l}$ is $(l,0,0)$.

The first two components of this initial state are dummy values.

\item
The transition function at location $\NUPRL{l}$ is $(\listinline{F}~l)$.

If \MSG{start}{$\NUPRLpair{client}{req\_num}$} arrives in
state $(l,r,n)$, the new state is
$(\NUPRL{client},\NUPRL{req\_num},n+1)$.
\end{itemize}
As an exercise, we unroll some instances of the definition.
By definition, \lstinline{PState} satisfies the recursion equation:
\begin{lstlisting}
   PState =
    let F loc (client,req_num) (_,_,n) = {(client, req_num, n + 1)}
    in F o (start'base,Prior(PState)?(\l.{(l,0,0)}));;
\end{lstlisting}

\noindent Note first that, because the return value of
\begin{lstlisting}
    \l.{(l,0,0)}
\end{lstlisting}
is always nonempty, every event belongs to the class
\begin{lstlisting}
    Prior(PState)?(\l.{(l,0,0)})
\end{lstlisting}
It follows from this that the \lstinline{PState}-events are precisely
the \lstinline{start'base}-events.  (The locally defined function
\lstinline{F} always returns a nonempty result; therefore, for any
\lstinline{A} and \lstinline{B}, the events in \lstinline{F o (A,B)} will
be those events that are both \lstinline{A}-events and
\lstinline{B}-events.)

Suppose that event $\NUPRLevent_1$, the arrival of the message
\MSG{start}{$\NUPRLpair{c_1}{r_1}$},  is the
first \lstinline{PStart}-event occurring at location $\NUPRL{l}$.
Call it event $\NUPRLevent_1$.  At $\NUPRLevent_1$, \lstinline{PState}
returns
\[
    \listinline{F}~l~(c_1,r_1)~(l,0,0) = \{(c_1,r_1,1)\}
\]
Suppose $\NUPRLevent_2$, the arrival of the message
\MSG{start}{$\NUPRLpair{c_2}{r_2}$}, is the next
\lstinline{PStart}-event occurring at location $\NUPRL{l}$.  At
$\NUPRLevent_2$, \lstinline{PState} returns
\[
    \listinline{F}~l~(c_2,r_2)~(c_l,r_1,1) = \{(c_2,r_2,2)\}
\]
The key point is that the argument supplied to \lstinline{F} by
\begin{lstlisting}
    Prior(PState)?(\l.{(l,0,0)})
\end{lstlisting}
is the value of the state when the incoming message
\emph{arrives}---which is the value returned as a result of the
previous \lstinline{start} message---or, if there hasn't been one,
$(\NUPRL{l},0,0)$.

\intitle{Mem and MemState}

The state machine \lstinline{PState} maintains an internal state and
after an input event returns a singleton bag containing its new
state.  It is, essentially, a Moore machine.

A memory module will maintain an internal state (listing the nodes
from which \lstinline{alive} messages have been received); it outputs
not its state but an \lstinline{out} message---and not every change of
state will cause an output.  A simple way to achieve this is to define
two classes: \lstinline{MemState}, like \lstinline{PState}, simply
accumulates a state and makes it visible; \lstinline{Mem} observes
\lstinline{MemState} and generates an output when appropriate.

The class (\lstinline{MemState}~$\NUPRL{round}$) accumulates and makes visible
the internal state:
\begin{emlcode}
\begin{lstlisting}
class MemState round =
  let F _ (loc:Loc,r:Int) L =
    if r = round & !(deq-member (op =) loc L)
    then {loc.L}
    else {L}
  in F o (alive'base,Prior(self)?{\l.[]});;
\end{lstlisting}
\end{emlcode}
An input event to this state machine is the arrival of an
\lstinline{alive} message.  The state is a list of locations,
initially empty; it contains the distinct locations from which
\lstinline{alive} messages have been received for round number
$\NUPRL{round}$, and ignores all other messages.  When a message
arrives with body $(\NUPRL{loc},\NUPRL{r})$ the new state is
determined as follows: if the message's round number is
$\NUPRL{round}$, and $\NUPRL{loc}$ is not yet on the list, prepend
$\NUPRL{loc}$ to the state; otherwise, no change.  (Because round
numbers are globally unique, this class can perform its function
without knowing either the client who initiated the request or the
request number assigned.)

{\bf Notation:} Some of the formal arguments to the function
\lstinline{F} are labeled with types: \lstinline{(loc:Loc,r:Int)},
rather than \lstinline{(loc,r)}.  It is always legal to label patterns
or expressions with types; and, in some situations, the type inference
algorithm needs the extra help.  The use of labels can be eliminated
by using variable declarations, which are introduced in
section~\ref{sec:simple-consensus}.

{\bf Notation:} Recall that the first argument to
\lstinline{deq-member} must be an equality operation.  In the term
``\lstinline{deq-member (op =) loc L}'' the equality operation is
denoted by ``\lstinline{(op =)}.''  In general, ``\lstinline{(op g)}''
means ``\lstinline{g} used as a binary infix operator.''

When \lstinline{(Mem client req_num round)} sees that the
state of \lstinline{(MemState round)} has grown to a list of length
\lstinline{threshold} it signals the client.
\begin{emlcode}
\begin{lstlisting}
class Mem client req_num round =
  let F _ L = if length L >= threshold
              then {out'send client (L,req_num)}
              else {}
  in F o (MemState round);;
\end{lstlisting}
\end{emlcode}

\subsection{Leader election in a ring}
\label{sec:leader-ring}


Many distributed protocols require that a group of nodes choose one of
them, on the fly, as a leader.  Here is a simple strategy for doing
that under the assumptions that:
\begin{itemize}
\item the nodes are arranged in a ring (each node knowing its
  immediate successor)
\item each node has a unique integer id
\end{itemize}

\begin{figure}[!t]
  \begin{lstlisting}[basicstyle=\small]
specification leader_ring

(* ------ Parameters ------ *)
parameter nodes  : Loc Bag
parameter client : Loc
parameter uid    : Loc -> Int

(* ------ Imported Nuprl declarations ------ *)
import imax

(* ------ Type functions ------ *)
type Epoch = Int

(* ------ Interface ------ *)
input    config  : Epoch * Loc (* To inform a node of its Epoch and neighbor *)
output   leader  : Epoch * Loc (* Location of the leader    *)
input    choose  : Epoch       (* Start the leader election *)
internal propose : Epoch * Int (* Propose a node as the leader of the ring *)

(* ------ Classes ------ *)
let dumEpoch = 0 ;;

class Nbr =
  let F _ (epoch, succ) (epoch', succ') =
    if epoch > epoch'
    then {(epoch, succ)}
    else {(epoch', succ')}
  in F o (config'base,Prior(self)?(\l.{(dumEpoch,l)})) ;;
class PrNbr = Prior(Nbr)?(\l.{(dumEpoch,l)}) ;;

class ProposeReply =
  let F loc (epoch, succ) (epoch', ldr) =
    if epoch = epoch'
    then if ldr = uid loc
         then {leader'send client (epoch, loc)}
         else {propose'send succ (epoch, imax ldr (uid loc))}
    else {}
  in F o (PrNbr,propose'base) ;;

class ChooseReply =
  let F loc (epoch, succ) epoch' =
    if epoch = epoch'
    then {propose'send succ (epoch, uid loc)}
    else {}
  in F o (PrNbr,choose'base) ;;

(* ------ Main class ------ *)
main (ProposeReply || ChooseReply)  @ nodes
  \end{lstlisting}
  \caption{Leader election in a ring}
  \label{fig:leader-ring}
\end{figure}

%\clearpage

Any node may start an election by sending its own id to its immediate
successor (a \emph{proposal}).  With one exception, a node that
receives a proposal will forward to its successor the greater of the
following two values: \{the proposal it received, its own id\}.  The
exception occurs if (and only if) a node receives in a proposal its
own id.  In that case, the node stops forwarding messages and declares
itself elected.  If messages are delivered reliably and no nodes fail,
this protocol will always succeed in electing the node with the
greatest id.

Fig.~\ref{fig:leader-ring} presents our specification of a slightly
more sophisticated protocol.  We add an interface that makes it
possible for some external party to reconfigure the ring---e.g., if it
believes that some nodes have failed.  Informally, we call the
intervals between reconfigurations \emph{epochs} (setting aside the
vagueness of ``between'' in a distributed setting).  We number the
epochs with positive integers---using 0 to mean ``no epoch has started
at this node.''

The inputs to the protocol are of two kinds:
\begin{itemize}
\item a \lstinline{config} message tells a node to begin a new
  epoch and stipulates which node is, in the new epoch, its immediate
  successor in the ring;
\item a \lstinline{choose} message contains the number of an
  epoch, and asks for an election in that epoch.
\end{itemize}

The outputs of the protocol are \lstinline{leader} messages sent to
some designated client.  The body of a \lstinline{leader} message
contains an epoch number and the id of the leader elected in that
epoch.

Parameters to the protocol are
\begin{itemize}
\item \lstinline{nodes : Loc Bag} -- the nodes from which a leader
  must be chosen
\item \lstinline{client : Loc} -- the node to be informed of the
  election results
\item \lstinline{uid : Loc -> Int} -- a function assigning a unique id to each
  member of \lstinline{nodes}
\end{itemize}

Our slightly generalized protocol is still quite simple to describe.
A node keeps track of the epoch in which it is currently participating
and ignores all \lstinline{propose} or
\lstinline{choose} messages labeled with other epochs.  If it
receives a \lstinline{config} message for an epoch numbered higher
than its current epoch, it switches to the new epoch, and otherwise
ignores it.  A node reacts to all non-ignored \lstinline{propose}
and \lstinline{choose} messages as in the original protocol.

The delicate part lies in formulating the invariants preserved by the
protocol and the conditions under which it succeeds.  What if
reconfiguration occurs while an election is going on?  What if
\lstinline{config} messages arrive out of order---requesting epoch 4
and later requesting epoch 3?  What if \lstinline{config} messages
partition the nodes into two disjoint rings?  We ignore those
questions.

\intitle{Nbr, the state of a node}

Informally, the state of any node is a pair
$\NUPRLpair{epoch}{succ}$~:~\lstinline{Int * Loc}, where $\NUPRL{epoch}$
is the number of its current epoch and $\NUPRL{succ}$ is the location
of its current successor.  This state changes only in response to
\lstinline{config} messages.  We capture that behavior in the class
\lstinline{Nbr}, which defines a state machine as follows:
\begin{itemize}
\item At location $\NUPRL{l}$, its initial state is
  $\NUPRLpair{0}{l}$; essentially, these are both dummy values.
\item Input events are the arrivals of \lstinline{config} messages,
  which are recognized by the base class \lstinline{config'base}.
\item The state transition in response to the input
  $\NUPRLpair{epoch'}{succ'}$ is:
  if $\NUPRL{epoch'} > \NUPRL{epoch}$, then change to
  $\NUPRLpair{epoch'}{succ'}$; otherwise, no change.
\end{itemize}

We use the state machine idiom described in
section~\ref{sec:ping-pong-mem}.  In addition to \lstinline{Nbr},
which observes the state after an input has been processed, we define
\lstinline{PrNbr}, which observes the state when an input arrives and
before it has been processed.  (In fact, \lstinline{Nbr} is only an
auxiliary for the sake of defining \lstinline{PrNbr}.)
\begin{emlcode}
\begin{lstlisting}
let dumEpoch = 0 ;;

class Nbr =
  let F _ (epoch, succ) (epoch', succ') =
    if epoch > epoch'
    then {(epoch, succ)}
    else {(epoch', succ')} in
  F o (config'base,Prior(self)?(\l.{(dumEpoch,l)})) ;;
class PrNbr = Prior(Nbr)?(\l.{(dumEpoch,l)}) ;;
\end{lstlisting}
\end{emlcode}

\intitle{Factoring the main program.}

We factor the behavior of the protocol into two classes, one triggered
by \lstinline{propose} messages and one triggered by
\lstinline{choose} messages.  We define
\begin{emlcode}
\begin{lstlisting}
main (ProposeReply || ChooseReply)  @ nodes
\end{lstlisting}
\end{emlcode}
and will define both \lstinline{ProposeReply} and \lstinline{ChooseReply}
in terms of \lstinline{PrNbr}.

\intitle{\lstinline{ProposeReply}.}

The response to a proposal is as described informally: send a
\lstinline{leader} message if you receive your own id; otherwise,
propose to your successor the max of the proposal received and your
own id.
\begin{emlcode}
\begin{lstlisting}
class ProposeReply =
  let F loc (epoch, succ) (epoch', ldr) =
    if epoch = epoch'
    then if ldr = uid loc
         then {leader'send client (epoch, loc)}
         else {propose'send succ (epoch, imax ldr (uid loc))}
    else {}
  in F o (PrNbr,propose'base) ;;
\end{lstlisting}
\end{emlcode}

Since \lstinline{Nbr} changes only in response to \lstinline{config}
messages, the state of \lstinline{Nbr} is the same both before and
after a \lstinline{propose} message arrives.  So why couldn't we
simplify this definition by replacing the expression
``\lstinline{F o (PrNbr,Propose)}'' with
``\lstinline{F o (Nbr,Propose)}''?

The reason is that \lstinline{Nbr} can only observe
\lstinline{config'base}-events, whereas \lstinline{PrNbr} can
observe any event $\NUPRLevent$.
% such that a \lstinline{config'base} event
% has previously occurred at $\NUPRLesloc{\NUPRLes}{\NUPRLevent}$.
This use of \lstinline{(Prior(...))?(...)} is a basic idiom of
\eml\ programming---although, as will be seen in
section~\ref{sec:state-machine}, it is often conveniently packaged
within standard library combinators.

Note: If $\NUPRLevent$ is a \lstinline{propose'base}-event at location
$\NUPRL{loc}$, and no \lstinline{config'base}-event has yet occurred
at $\NUPRL{loc}$, then $\NUPRLevent$ is a \lstinline{PrNbr}-event, and
the only value \lstinline{PrNbr} observes at $\NUPRLevent$ is the pair
\lstinline[mathescape=true]{(dumEpoch,$\NUPRL{loc}$)}.
%therefore is not a \lstinline{ProposeReply} event.


\intitle{\lstinline{ChooseReply}}

When \lstinline{ChooseReply} receives a \lstinline{choose}
instruction for the epoch on which it is currently working, it
initiates an election by sending an appropriate
\lstinline{propose}
message.
\begin{emlcode}
\begin{lstlisting}
class ChooseReply =
  let F loc (epoch, succ) epoch' =
    if epoch = epoch'
    then {propose'send succ (epoch, uid loc)}
    else {}
  in F o (PrNbr,choose'base) ;;
\end{lstlisting}
\end{emlcode}
This uses \lstinline{PrNbr} instead of \lstinline{Nbr} for the same
reason that \lstinline{ProposeReply} does.

\section{State machines}
\label{sec:state-machine}

Previous examples have built state machine classes by hand, from
\eml\ primitives.  The \nuprl\ library defines combinators that
package up idioms for defining state machines of various kinds.  Many
of the automated tactics created to reason about event classes are
tuned for definitions that use these combinators.

\subsection{Moore machines, ``pre'' and
  ``post''}\label{sec:SM1-Memory1}

We have been using a standard strategy.  First define what might
loosely be called a Moore machine: in response to inputs it updates
its state and makes that state visible.  We then use the simple
composition combinator to define a Mealy machine (loosely called) from
this Moore machine: one that, in response to some of the Moore
machine's inputs, returns directed messages.  One virtue of this
factoring is that, by making the state visible, we can conveniently
express state invariants as properties of classes explicitly defined
in the \eml\ code.

In general, we can define a Moore machine from the following data:
\begin{itemize}
\item $\NUPRL{A}$, the type of input values
\item $\NUPRL{S}$, the type of state values
\item $\NUPRL{X}:\NUPRLclass{\NUPRL{A}}$, recognizing input events
\item $\NUPRL{init} : \NUPRLarrow{\NUPRLloc}{\NUPRLbag{\NUPRL{S}}}$,
  assigning a bag of initial states to each location
\item
  $\NUPRL{tr} : \NUPRLarrow{\NUPRLloc}
  {\NUPRLarrow{\NUPRL{A}}{\NUPRLarrow{\NUPRL{S}}{\NUPRL{S}}}}$,
  assigning a transition function to each location
\end{itemize}

We introduce combinators, \lstinline{SM1-class} and
\lstinline{Memory1},
%
\index{class combinators!SM1-class}%
\index{class combinators!Memory1}%
%
that provide two different ways to observe this
state machine.  In the idiomatic case, in which
$\NUPRL{init}$ assigns a singleton bag to every location:
\begin{itemize}
\item
$(\listinline{SM1-class}~\NUPRL{init}~(\NUPRL{tr},\NUPRL{X}))$ is the
``post'' observer of the state machine, which behaves as follows:
  \begin{itemize}
  \item
  The events it recognizes are the \lstinline{X}-events.
  \item
  To every \lstinline{X}-event $\NUPRLevent$ it assigns a singleton
  bag $\{\NUPRL{v}\}$, where $\NUPRL{v}$ is the state of that state
  machine after responding to $\NUPRLevent$.
  \end{itemize}
\item
$(\listinline{Memory1}~\NUPRL{init}~\NUPRL{tr}~\NUPRL{X})$ is the
``pre'' observer of the state machine, which behaves as
  follows:\footnote{The use of two separate parameters, $\NUPRL{tr}$ and
    $\NUPRL{X}$, rather than a single pair, is a slightly awkward bit
    of legacy that will eventually be changed.}
  \begin{itemize}
  \item
  It recognizes \emph{all} events.
  \item
  To every event $\NUPRLevent$ it assigns a singleton bag,
  $\{\NUPRL{v}\}$ where, intuitively, $\NUPRL{v}$ is the value of the
  state when $\NUPRLevent$ arrives (\emph{before} it is processed).

  More precisely, if there has been no previous $\NUPRL{X}$-event at
  location $\NUPRLesloc{\NUPRLes}{\NUPRLevent}$,
  $\{\NUPRL{v}\}=(\NUPRL{init}~\NUPRLesloc{}{\NUPRLevent})$; otherwise, letting
  $\NUPRLevent'$ be the most recent such $\NUPRL{X}$-event before
  $\NUPRLevent$,
  $\{\NUPRL{v}\} =
    (\listinline{SM1-class}~\NUPRL{init}~(\NUPRL{tr},\NUPRL{X}))(\NUPRLevent')$
  \end{itemize}
\end{itemize}


\noindent We can define\footnote{The definition we use for
  \lstinline{SM1-class} is not literally this one, but is
  equivalent to it.} these combinators as follows:
\begin{emlcode}
\begin{lstlisting}
   class SM1-class init (tr,X) = tr o (X, Prior(self)?init) ;;
   class Memory1 init tr X = Prior(SM1-class init (tr,X))?init ;;
\end{lstlisting}
\end{emlcode}


Thus, if we declare
\begin{lstlisting}
   class Y = SM1-class init (tr,X);;
   class PrY = Memory1 init tr X;;
\end{lstlisting}
we know that that the following equations are satisfied:
\begin{lstlisting}
   Y = tr o (X,Prior(Y)?init)
   PrY = Prior(Y)?init
\end{lstlisting}

\subsection{Moore machines with multiple transition
  functions}\label{sec:SM2-Memory2}

One often wants a state machine whose inputs are defined by two or
more different classes---typically, base classes that recognize inputs
of different kinds.  For notational simplicity, consider the case of
two input classes.  Now we have, for $i = 1,2$:
\begin{itemize}
\item $\NUPRL{A}_i$, a type of input values
\item $\NUPRL{S}$, a type representing values of the state
\item $\NUPRL{X}_i:\NUPRLclass{\NUPRL{A_i}}$ recognizing input events
\item $\NUPRL{init} : \NUPRLarrow{\NUPRLloc}{\NUPRLbag{\NUPRL{S}}}$,
  assigning a bag of initial states to each location
\item
  $\NUPRL{tr}_i : \NUPRLarrow{\NUPRLloc}
  {\NUPRLarrow{\NUPRL{A}_i}{\NUPRLarrow{\NUPRL{S}}{\NUPRL{S}}}}$,
  assigning transition functions to each location
\end{itemize}

Together with $\NUPRL{init}$, each of the pairs
$\NUPRLpair{\NUPRL{tr}_i}{\NUPRL{X}_i}$ defines a state machine with
the same state type, $\NUPRL{S}$, but possibly different types of
input values.  In the idiomatic case, the $\NUPRL{X}_1$-events and the
$\NUPRL{X}_2$-events are disjoint and the state machine we want to
define acts as follows: If $\NUPRLevent$ is an $\NUPRL{X}_i$-event, it
takes the transition defined by $\NUPRL{tr}_i$.  (The definition will
guarantee that if $\NUPRLevent$ should be both an $\NUPRL{X}_1$-event
and an $\NUPRL{X}_2$-event, the state machine takes transition
$\NUPRL{tr}_1$.)

As before, we can define classes that represent both ``post'' and
``pre'' observations of this state machine (for the idiomatic case):
\begin{itemize}
\item
$(\listinline{SM2-class}~\NUPRL{init}~(\NUPRL{tr}_1,\NUPRL{X}_1)~(\NUPRL{tr}_2,\NUPRL{X}_2))$ is the
``post'' observer.
  The events it recognizes are $\NUPRL{X}_1$-events or
  $\NUPRL{X}_2$-events.

\item
$(\listinline{Memory2}~\NUPRL{init}~\NUPRL{tr}_1~\NUPRL{X}_1~\NUPRL{tr}_2~\NUPRL{X}_2)$ is the
``pre'' observer, which recognizes \emph{all} events.
\end{itemize}

\lstinline{SM3-class}/\lstinline{Memory3} and
\lstinline{SM4-class}/\lstinline{Memory4} are similar, except that
they combine, respectively, three and four different sources of
inputs.

Note: \eml\ is rich enough to define all of these classes.  For
technical reasons, their official definitions use features of the
\nuprl\ type system not available in \eml, so we prefer simply to make
instances of these combinators available as quasi-primitives.




\section{The two-thirds consensus protocol}
\label{sec:simple-consensus}

\begin{figure}[!t]
  \begin{lstlisting}[basicstyle=\small]
specification rsc

(* ------ Parameters ------ *)
(* consensus on commands of arbitrary type Cmd with equality decider (cmdeq) *)
parameter Cmd, cmdeq : Type * Cmd Deq
parameter coeff      : Int
parameter flrs       : Int     (* max number of failures                  *)
parameter locs       : Loc Bag (* locations of (3 * flrs + 1)   replicas  *)
parameter clients    : Loc Bag (* locations of the clients to be notified *)

(* ------ Imported Nuprl declarations ------ *)
import length poss-maj list-diff deq-member from-upto bag-append Memory1

(* ------ Type definitions ------ *)
type Inning   = Int
type CmdNum   = Int
type RoundNum = CmdNum * Inning
type Proposal = CmdNum * Cmd
type Vote     = (RoundNum * Cmd) * Loc

(* ------ Messages ------ *)
internal vote    : Vote
internal retry   : RoundNum * Cmd
internal decided : CmdNum
output   notify  : Proposal
input    propose : Proposal

(* ------ Variables ------ *)
variable sender  : Loc
variable loc     : Loc
variable ni      : RoundNum
variable n       : CmdNum

(* ------ Auxiliaries ------ *)
let init x loc = {x} ;;
  \end{lstlisting}
  \caption{2/3 consensus: preliminaries}
  \label{fig:simple-consensus-header}
\end{figure}

%\clearpage

Consider the following problem: A system has been replicated for fault
tolerance.  It responds to commands issued to any of the replicas,
which must come to consensus on the order in which those commands are
to be performed, so that all replicas process commands in the same
order.  Replicas may fail.  We assume that all failures are crash
failures: that is, a failed replica ceases all communication with its
surroundings.  The two-thirds consensus protocol is a simple protocol
for coming to consensus, in a manner that tolerates $n$ failures, by
using (precisely) $3n+1$ replicas.

Input events communicate \emph{proposals}, which consist of
integer/command pairs: $\NUPRLpair{n}{c}$ proposes that command
$\NUPRL{c}$ be the $\NUPRL{n}^{th}$ one performed.  The protocol is
intended to obtain agreement, for each $\NUPRL{n}$, on which command
will be the $\NUPRL{n}^{th}$ to be performed, and to broadcast a
\lstinline{notify} message with those decisions (which are also
integer/command pairs) to a list of clients.

Each copy of the replicated system will contain a module that carries
out the consensus negotiations.  In this specification we describe
only those modules (which we continue to call Replicas).  To specify
the full system we would have to include a description of how those
decisions are used.  That is done in the description of the Paxos
protocol (section~\ref{sec:Paxos}).

For convenient display, we split the full specification into smaller
chunks: figure~\ref{fig:simple-consensus-header} contains the
prefatory information (parameters, imports, type definitions, message
declarations, variables, auxiliaries) and
figures~~\ref{fig:simple-consensus-replicastate}
through~\ref{fig:simple-consensus-top-level} define the classes.
Section~\ref{sec:simple-consensus-code} walks through code,
redisplaying fragments of the text as they are discussed.  A reader
may find it helpful first to concentrate on the informal description
of each class provided and then, before studying details, turn to
section~\ref{sec:consensus-runs} to see some scenarios showing the
protocol in action.  Section~\ref{sec:simple-consensus-consistent}
explains why the protocol satisfies the basic safety property of
\emph{consistency}---it will not send contradictory notifications.
That section also defines the precise sense in which the protocol can
``tolerate'' up to \lstinline{flrs} ``failures,'' but does not provide
a proof of that.

\subsection{The specification of 2/3-consensus}\label{sec:simple-consensus-code}

\subsubsection{Preliminaries}

This section comments on the preliminary definitions given
figure~\ref{fig:simple-consensus-header}, and also introduces the
library combinator \lstinline{until}.

\intitle{Parameters}

The parameters of the protocol are
\begin{itemize}
\item \lstinline{Cmd}: the type of commands
\item \lstinline{flrs}: the max number of failures to be tolerated
\item \lstinline{locs}: the locations of the $3*\listinline{flrs} + 1$
  replicated processes that decide on consensus
\item \lstinline{clients}: the locations of the clients to be notified
  of decisions
\end{itemize}
We make no assumptions about who submits inputs or constraints on how
they are submitted.

The declaration of the \lstinline{Cmd} parameter also introduces a
parameter for an equality operator:
\begin{emlcode}
\begin{lstlisting}
    parameter Cmd, cmdeq : Type * Cmd Deq
\end{lstlisting}
\end{emlcode}
When we instantiate the type \lstinline{Cmd}, we must also instantiate
\lstinline{cmdeq} with an operation that decides equality for members
of that type.  The keyword \lstinline{Deq} denotes a type constructor:
(\lstinline{Cmd Deq}) is the type of all equality deciders for
\lstinline{Cmd}.  We need \lstinline{cmdeq} because we want to apply
\lstinline{deq-member} to compute membership in a list of commands; as
noted in section~\ref{deq-member}, we must therefore supply an
equality decider.

%% \vspace{1.0ex}
%% \noindent{\bf Messages}
%% Officially, the message headers are the token lists
%% \lstinline{rsc vote}, \lstinline{rsc retry}, etc.  Informally, we will denote
%% these by \lstinline{rsc vote}, \lstinline{rsc retry}, etc.

%
%% The declarations of \lstinline{rsc vote} and \lstinline{notify}
%% messages introduce constructors for broadcasting directed messages,
%% via the keyword \lstinline{broadcast}:
%% \begin{emlcode}
%% \begin{lstlisting}
%%   internal vote : Vote
%% \end{lstlisting}
%% \end{emlcode}
%

%% \vspace{1.0ex}
%% \noindent{\bf Imported operations}
%% We will describe the operations imported from the \nuprl\ library when
%% explaining the code in which they appear.

\intitle{Variables}

One reason for the variable declarations, such as
\begin{emlcode}
\begin{lstlisting}
   variables sender : Loc
   variable ni      : RoundNum
\end{lstlisting}
\end{emlcode}
is to introduce notational conventions that make the specification
easier to read.  Type checking will object if the notations are misused.

A second reason is to help the type inference algorithm, which
sometimes requires hints about the types of the arguments to functions
being defined.  An expression or pattern may be labeled with a type,
which will be checked statically, and may also constrain polymorphism
that might otherwise arise.  E.g., after
\begin{lstlisting}
    let foo x = x ;;
    let bar (x:Int) = x ;;
    let baz (x,y:Bool) = (x,y) ;;
\end{lstlisting}
\lstinline{foo} is thepolymorphic function on every type;
\lstinline{bar} is the identity function on integers; and
\lstinline{baz} is the identity function on pairs whose second
coordinate is boolean.  Typically, we want library functions to be
highly polymorphic and widely applicable, but the functions defined in
\eml\ programs to be much more constrained.  By and large, the
polymorphism of an \eml\ program is expressed in its parameters.

Without variable declarations for \lstinline{ni} and
\lstinline{sender} the definition of the \lstinline{newvote} operation
would have to be expressed as
\begin{lstlisting}
   let newvote (ni:RoundNum) ((ni',c),sender:Loc) (_,locs) = ... ;;
\end{lstlisting}
but with those declarations, we may simply write
\begin{lstlisting}
   let newvote ni ((ni',c),sender) (_,locs) = ... ;;
\end{lstlisting}
As a practical matter, there's not much point in trying to anticipate
where type inference needs hints.  Most commonly, help may be needed when
the right hand side of the definition calls on a polymorphic function
such as \lstinline{deq-member}, which operates on lists of any type
that has a decidable equality operator.

The balance between introducing variable declarations and adding type
labels to patterns and expressions is a matter of taste.

\intitle{Auxiliaries}

We introduce a convenient notation for specifying the
``\lstinline{init}'' parameter of \lstinline{SM*-class} or
\lstinline{Memory*} (section~\ref{sec:state-machine}):
\begin{emlcode}
\begin{lstlisting}
let init x loc = {x} ;;
\end{lstlisting}
\end{emlcode}
Used in that context, (\lstinline{init}~$\NUPRL{x}$) is the function
that assigns the initial state $\NUPRL{x}$ to every location.

%% Instantiating \lstinline{init_state} with
%% (\lstinline{init}~$\NUPRL{v}$) assigns the initial state $\NUPRL{v}$
%% to every location.  Instantiating \lstinline{f} with
%% \lstinline{thr_out} defines a state machine that acts purely as a
%% filter: the value of an output is the value of the input that caused
%% it.

\intitle{Class combinators}

The specification uses one new library combinator:
\begin{itemize}
\item
\lstinline{X until Y}:%
\index{class combinators!until combinator}%
%
$\dgclassrel{\NUPRLevent}{\text{(\lstinline{X until Y})}}{\NUPRL{v}}$
iff \vXe\ and no \lstinline{Y}-event has previously occurred at
$\NUPRLesloc{}{\NUPRLevent}$.  That is, at any location $\NUPRL{l}$,
the class (\lstinline{X until Y}) acts exactly like \lstinline{X} until
a \lstinline{Y}-event occurs at $\NUPRL{l}$, after which it falls
silent.

\end{itemize}

\begin{figure}[!t]
  \begin{lstlisting}[basicstyle=\small]
(* ---------- ReplicaState: a state machine ---------- *)

(* -- inputs -- *)
let vote2prop loc (((n,i),c),loc') = {(n,c)} ;;
class Proposal = propose'base || (vote2prop o vote'base);;

let update_replica (n,c) (max,missing) =
  if n > max
  then (n, missing ++ (from-upto (max + 1) n))
  else if deq-member (op =) n missing
       then (max, list-diff (op =) missing [n])
       else (max,missing) ;;

class ReplicaState = Memory1 (init (0,nil)) update_replica Proposal ;;

(* ---------- NewVoters ---------- *)

let when_new_proposal loc (n,c) (max,missing) =
  if n > max or deq-member (op =) n missing then {(n,c)} else {} ;;

class NewVoters = when_new_proposal o (Proposal, ReplicaState) ;;
  \end{lstlisting}
  \caption{2/3 consensus: NewVoters and ReplicaState}
  \label{fig:simple-consensus-replicastate}
\end{figure}

%\clearpage

\begin{figure}[!t]
  \begin{lstlisting}[basicstyle=\small]

(* ---------- QuorumState ---------- *)

let newvote ni ((ni',c),sender) (cmds,locs) =
  ni = ni' & !(deq-member (op =) sender locs);;

let add_to_quorum ni ((ni',c),sender) (cmds,locs) =
  if newvote ni ((ni',c),sender) (cmds,locs)
  then (c.cmds, sender.locs)
  else (cmds,locs);;

class QuorumState ni = Memory1 (init (nil,nil)) (add_to_quorum ni) vote'base ;;

(* ---------- Quorum ---------- *)

let roundout loc (((n,i),c),sender) (cmds,_) =
  if length cmds = 2 * flrs
  then let (k,x) = poss-maj cmdeq (c.cmds) c in
         if k = 2 * flrs + 1
         then bag-append (decided'broadcast locs n)
                         (notify'broadcast clients (n,x))
         else { retry'send loc ((n,i+1), x) }
  else {} ;;

let when_quorum ni loc vote state =
  if newvote ni vote state then roundout loc vt state else {} ;;

class Quorum ni = (when_quorum ni) o (vote'base, QuorumState ni) ;;

(* ---------- Round ---------- *)

class Round (ni,c) = Output(\loc.vote'broadcast locs ((ni,c),loc))
                  || Once(Quorum ni) ;;
  \end{lstlisting}
  \caption{2/3 consensus: Rounds and Quorums}
  \label{fig:simple-consensus-quorum}
\end{figure}

%\clearpage

\begin{figure}[!t]
  \begin{lstlisting}[basicstyle=\small]
(* ---------- NewRoundsState ---------- *)

let vote2retry loc ((ni,c),sender) = {(ni,c)};;
let RoundInfo = retry'base || (vote2retry o vote'base);;

let update_round n ((m,i),c) round = if n = m & round < i then i else round ;;

class NewRoundsState n = Memory1 (init 0) (update_round n) RoundInfo ;;

(* ---------- NewRounds ---------- *)

let when_new_round n loc ((m,i),c) round =
  if n = m & round < i then {((m,i),c)} else {} ;;

class NewRounds n = (when_new_round n) o (RoundInfo, NewRoundsState n) ;;

(* ---------- Voter ---------- *)

class Halt n = (\_.\m. if m = n then {()} else {}) o decided'base;;

class Voter (n,c) = Round ((n,0),c)
                 || ((NewRounds n >>= Round) until (Halt n));;
  \end{lstlisting}
  \caption{2/3 consensus: NewRounds and Voters}
  \label{fig:simple-consensus-voter}
\end{figure}

\begin{figure}[!t]
  \begin{lstlisting}[basicstyle=\small]
(* ---------- Replica ---------- *)

class Replica = NewVoters >>= Voter;;

(* ---------- Main program ---------- *)

main Replica @ locs ;;
  \end{lstlisting}
  \caption{2/3 consensus: The top level}
  \label{fig:simple-consensus-top-level}
\end{figure}


%\clearpage


\subsubsection{The top level:
  \lstinline{Replica}}\label{sec:simple-consensus-top-level}

Replica is the event class characterizing the actions of a decider.
As noted in figure~\ref{fig:simple-consensus-top-level}, the main
program
\begin{emlcode}
\begin{lstlisting}
main Replica @ locs
\end{lstlisting}
\end{emlcode}
installs a decider at each location in \lstinline{locs}.

For each $n$, a \lstinline{Replica} will spawn (at most) one instance
\lstinline{Voter} to communicate with other instances of
\lstinline{Voter} and come to consensus on a single proposal of the
form $(n,\_)$.
\begin{emlcode}
\begin{lstlisting}
class Replica = NewVoters >>= Voter ;;
\end{lstlisting}
\end{emlcode}
For each $n$, \lstinline{NewVoters} spawns a \lstinline{Voter} in
response to the first proposal or vote it receives concerning command
$n$.

We define consensus on proposal $\NUPRLpair{n}{c}$ to mean that 2/3
(plus one) of the replicas vote for it.  On any particular poll of the
voters that degree of consensus cannot be guaranteed---so we allow
do-over polls, for which we adopt the following terminology.
Successive polls for each command number are assigned consecutive
integers called \emph{innings}; the pair
$\NUPRLpair{\NUPRL{command\_number}}{\NUPRL{inning}}$ is called the
polling or voting \emph{round}.

Votes are of type \lstinline{Vote}.   Each contains:
\begin{itemize}
\item the round in which the vote is cast
\item a command being voted for in that round
\item the voter's location (used to ensure that repeat votes from the
  same source are ignored)
\end{itemize}


\subsubsection{\lstinline{ReplicaState} and \lstinline{NewVoters}}

This section refers to figure~\ref{fig:simple-consensus-replicastate}.

A \lstinline{Replica} acts when \lstinline{NewVoters} does, in
response to \lstinline{propose} and \lstinline{vote} inputs.  These
are recognized by the class \lstinline{Proposal}:
\begin{emlcode}
\begin{lstlisting}
  let vote2prop loc (((n,i),c),sender) = {(n,c)} ;;
  class Proposal = propose'base || (vote2prop o vote'base);;
\end{lstlisting}
\end{emlcode}
\lstinline{Proposal} observes the value of type \lstinline{Proposal}
input in its input.

\lstinline{ReplicaState} maintains the state of a \lstinline{Replica},
enough information to recognize the first time it sees a
\lstinline{Proposal}-event about command $n$ (meaning a value of the
form $\NUPRLpair{n}{c}$ for some command $c$).  Its state has type
%
\lstinline{Int * (Int List)}.  The \lstinline{Int} component is the
greatest $n$ for which it has seen such an event; and the
%
\lstinline{(Int List)} component is the list of all natural numbers
less than that maximum for which it has \emph{not} yet seen a proposal
event.
\begin{emlcode}
\begin{lstlisting}
   let update_replica (n,c) (max,missing) =
     if n > max
     then (n, missing ++ (from-upto (max + 1) n))
     else if deq-member (op =) n missing
          then (max, list-diff (op =) missing [n])
          else (max,missing) ;;

   class ReplicaState = Memory1 (init (0,nil)) update_replica
                                 Proposal ;;
\end{lstlisting}
\end{emlcode}
The initial state of a \lstinline{ReplicaState} is
$\NUPRLpair{0}{\NUPRL{nil}}$.  The infix operator \lstinline{++} is the
append operator and the imported
\nuprl\ operations \lstinline{from-upto} and \lstinline{list-diff}
have the following meanings:
\begin{eqnarray*}
\listinline{from-upto}~i~j &=& [i; i+1; i+2; ...; j-1] \\
\listinline{list-diff}~(\listinline{op}~=) [a;b;...] [m;n;\ldots] &=&
       \text{the result of deleting all occurrences of $m,n,\ldots$
         from $[a;b;...]$} 
\end{eqnarray*}

Every event is a \lstinline{ReplicaState}-event, and observes the
state of the state machine when the event occurs (before any processing).

\lstinline{NewVoters}-events are \lstinline{Proposal}-events.
\lstinline{NewVoters} compares the data observed by
\lstinline{Proposal} with the state of the replica when the message
arrives, in order to decide whether it is the first proposal about some
$n$.
\begin{emlcode}
\begin{lstlisting}
   let when_new_proposal loc (n,c) (max,missing) =
     if n > max or deq-member (op =) n missing
     then {(n,c)}
     else {} ;;

   class NewVoters = when_new_proposal o (Proposal, ReplicaState) ;;
\end{lstlisting}
\end{emlcode}

\subsubsection{The next level:
  \lstinline{Voter}}\label{sec:simple-next-level}

A \lstinline{Voter} is a parallel composition of two classes:
\begin{emlcode}
\begin{lstlisting}
class Voter (n,c) = Round ((n,0),c)
                 || ((NewRounds n >>= Round) until Halt n);;
\end{lstlisting}
\end{emlcode}
where:
\begin{itemize}
\item \lstinline{Round}$\NUPRL((n,i),c)$ will, at any location, conduct the
  voting for round $\NUPRL(n,i)$, and will
  cast its vote in that round for command $\NUPRL{c}$.

\item \lstinline{NewRounds}~$\NUPRL{n}$~\lstinline{>>= Round} will
  determine when it is time to begin a new round of voting for the
  $\NUPRL{n}^{th}$ command and spawn a class to conduct the voting in
  that new round.

\item
  The clause ``\lstinline{until Halt n}''%
  %
  \index{class combinators!until combinator}%
  %
  will cause termination when it detects a \lstinline{Halt}~$n$ event,
  which signals that some \lstinline{Voter} has found a consensus for
  command $n$.
\end{itemize}

\subsubsection{\lstinline{Round} and \lstinline{Quorum}}

This section refers to figure~\ref{fig:simple-consensus-quorum}.

\intitle{\lstinline{Round} $\NUPRL{((n,i),c)}$}

\lstinline{Round}~$\NUPRL{((n,i),c)}$, running at location
$\NUPRL{loc}$, broadcasts a vote from $\NUPRL{loc}$ for command
$\NUPRL{c}$ in round $\NUPRL{(n,i)}$ and runs an instance of
\lstinline{Quorum}.  \lstinline{Quorum}~$(n,i)$ keeps a tally of votes
received at $\NUPRL{l}$ in round $(n,i)$ and uses that tally to
determine \emph{either} that consensus has been reached (in which case
it notifies the clients and sends every \lstinline{Replica}, including
itself (i.e., the replica that spawned it), a \lstinline{decided}
message) \emph{or} that consensus might not be possible in inning
$\NUPRL{i}$ (in which case it sends to itself a suitable
\lstinline{retry} message).
\begin{emlcode}
\begin{lstlisting}
class Round (ni,c) = Output(\loc.vote'broadcast locs ((ni,c),loc))
                     || Once(Quorum ni) ;;
\end{lstlisting}
\end{emlcode}

\vspace{1.0ex} (\lstinline{Quorum}~$(n,i)$) is a state machine that
responds to \lstinline{vote} messages.  Intuitively, its state
consists of a pair $\NUPRLpair{cmds}{locs}$.  Each time it receives a
\emph{new} vote for proposal $\NUPRLpair{n}{c}$ in inning $\NUPRL{i}$,
it prepends $\NUPRL{c}$ to the list $\NUPRL{cmds}$.  $\NUPRL{locs}$ is
the list of the locations that sent those commands.  (We keep the list
of senders so that, if a vote from any sender is delivered multiple
times, it will only be counted once.)  The initial state is a pair of
empty lists.  (\lstinline{QuorumState}~$(n,i)$) is the ``pre'' Moore
machine that observes this state when a vote arrives.

\begin{emlcode}
\begin{lstlisting}
let newvote ni ((ni',c),sender) (cmds,locs) =
  ni = ni' & !(deq-member (op =) sender locs);;

let add_to_quorum ni ((ni',c),sender) (cmds,locs) =
  if newvote ni ((ni',c),sender) (cmds,locs)
  then (c.cmds, sender.locs)
  else (cmds,locs);;

class QuorumState ni = Memory1 (init (nil,nil))
                                    (add_to_quorum ni) vote'base ;;
\end{lstlisting}
\end{emlcode}
The transition function for (\lstinline{QuorumState}~$(n,i)$) is
(\lstinline{add_to_quorum}~$(n,i)$).  A \lstinline{vote} message is a
no-op unless it's a vote in round $(n,i)$ that comes from a new
location.  If it's both, then the vote is tallied by prepending to it
state components the command it votes for and the location of its
sender.

\lstinline{Quorum}~$(n,i)$ is a Mealy machine defined from
\lstinline{QuorumState}.  It produces an output once it has received
votes from $2\listinline{flrs}+1$ distinct locations.  If all of them
are votes for the same command $\NUPRL{d}$, it broadcasts
\lstinline{notify} and \lstinline{decided} messages.  If not, then it
is possible that on this round no proposal will ever receive
$2\listinline{flrs}+1$ votes; so it sends itself a \lstinline{retry}
message to trigger initiation of inning $\NUPRL{i+1}$.  (Once it has
sent the \lstinline{retry} message it will ignore any votes it
subsequently receives in round $\NUPRLpair{n}{i}$, even if they would
result in some proposal's receiving $2\listinline{flrs}+1$.)
\begin{emlcode}
\begin{lstlisting}

let roundout loc (((n,i),c),sender) (cmds,_) =
  if length cmds = 2 * flrs
  then let (k,x) = poss-maj cmdeq (c.cmds) c in
         if k = 2 * flrs + 1
         then bag-append (decided'broadcast locs n)
                         (notify'broadcast clients (n,x))
         else { retry'send loc ((n,i+1), x) }
  else {} ;;

let when_quorum ni loc vote state =
  if newvote ni vote state then roundout loc vt state else {} ;;

class Quorum ni = (when_quorum ni) o (vote'base, QuorumState ni) ;;
\end{lstlisting}
\end{emlcode}

Consider first the outer conditional.  The \lstinline{(cmds,_)}
argument matches the value observed by \lstinline{QuorumState}, so
(\lstinline{length cmds}) is the number of votes tallied before the
input arrives.  If this test fails then, even with the new input, the
state machine will not yet have received $2\listinline{flrs}+1$ votes,
so the input is ignored.

Consider the inner conditional.  The imported operation
\lstinline{poss-maj} implements the Boyer-Moore majority algorithm.
Thus, the locally defined constants \lstinline{k} and \lstinline{x}
have the following meaning: If some element of the list
\lstinline{c.comds} appears in a majority of its entries,
\lstinline{x} is that element and \lstinline{k} is the number of times
it occurs.  Thus, the inner conditional tests for unanimity.

The data of a \lstinline{retry} message consists of the new round to
be initiated and, in addition, the name of a command to propose in
this new round.  The definition of \lstinline{roundout} attempts to
choose that command in a reasonable way:   So, if the votes are
not unanimous, but some command receives a majority, that
majority-receiving command will be proposed in the \lstinline{retry}
message.\footnote{This is crucial to the correctness of the protocol.}

\subsubsection{\lstinline{NewRounds} and \lstinline{Voters}}

This section refers to figure~\ref{fig:simple-consensus-voter}.

\intitle{\lstinline{Halt} $n$}

\lstinline{Halt} $n$ recognizes the arrival of \lstinline{decided}
message with body $n$.  We make it a class of type \lstinline{Unit},
since the only information conveyed is the fact that the message has
arrived.

\begin{emlcode}
\begin{lstlisting}
class Halt n = 
    Once((\_.\i.if i = n then {()} else {}) o decided'base) ;;
\end{lstlisting}
\end{emlcode}


\intitle{\lstinline{NewRounds} $\NUPRL{n}$}

Recall that (\lstinline{NewRounds} $\NUPRL{n}$) decides when to
initiate a new round of voting about the $n^{th}$ command and, when
necessary, spawns an instance of \lstinline{Round}, supplying it with
a new round number of the form $\NUPRLpair{n}{\_}$ and a command to
vote for in that round.

(\lstinline{NewRoundsState}~$\NUPRL{n}$) is a ``pre'' Moore machine.
It's state is an integer, initially $0$.  At any location it keeps
track of the greatest inning $\NUPRL{i}$ for which it has
``participated'' in a round of the form $\NUPRLpair{n}{i}$.  A
location has ``participated'' in such a round if it has received a
\lstinline{retry} message with data
$\NUPRLpair{\NUPRLpair{n}{i}}{\_}$, or a \lstinline{vote} message with
data $\NUPRLpair{\NUPRLpair{\NUPRLpair{n}{i}}{\_}}{\_}$.  So its input
events are recognized by \lstinline{RoundInfo}, which observes the
round/command pair embedded in its input.
\begin{emlcode}
\begin{lstlisting}
let vote2retry loc ((ni,c),sender) = {(ni,c)};;
class RoundInfo = retry'base || (vote2retry o vote'base);;
\end{lstlisting}
\end{emlcode}
The transition function, \lstinline{update_round}, updates
the state whenever its input constitutes participation in an inning
greater than the current state value:
\begin{emlcode}
\begin{lstlisting}
let update_round n ((m,i),c) round = if n = m & round < i
                                     then i else round ;;
class NewRoundsState n = 
    Memory1 (init 0) (update_round n) RoundInfo ;;
\end{lstlisting}
\end{emlcode}

There's some redundancy in defining the Mealy machine
\lstinline{NewRounds} from \lstinline{NewRoundsState}.\footnote{The
  next version of the library will contain a different set of
  combinators that avoids that.}  The condition in
\lstinline{when_new_round} is the same as that in the transition
function \lstinline{updated_round}: when the transition is a no-op,
\lstinline{NewRounds} ignores the input; when it's not,
\lstinline{NewRounds} passes along the input that caused the update.
\begin{emlcode}
\begin{lstlisting}
let when_new_round n loc ((m,i),c) round =
  if n = m & round < i then {((m,i),c)} else {} ;;
class NewRounds n = 
    (when_new_round n) o (RoundInfo, NewRoundsState n) ;;
\end{lstlisting}
\end{emlcode}

\subsection{Illustrative runs of the protocol}
\label{sec:consensus-runs}

This section contains message sequence charts that describe some
possible runs of the 2/3-consensus protocol.  To make the charts
easier to read, all message arrows are drawn horizontally (except for
self-messages).\footnote{A horizontal arrow does \emph{not} imply
  instantaneous communication.}  That requires a small, but
semantically inessential, deviation from the official semantics of
\eml.  Actions that are atomic in \eml\ may be shown as nonatomic.
Consider figure~\ref{fig:atomic-nonatomic}.  The top diagram shows A
broadcasting message $x$ to B, C, and D as a single event.  At C, the
act of receiving message $x$ and replying with $y$ is atomic.  The
second diagram teases everything apart.

We can represent delay in message transit, in part, as a delay in
sending the message.  Since only message arrivals are observable, no
distinction between the picture and the official semantics will be
observable.

\begin{figure}
\begin{center}
\drawinstfoot{no}
% \setmscscale{.8}
\begin{msc}{Lots of criss-crossing arrows}
\setlength{\levelheight}{2.0\levelheight}
\declinst{A}{}{A}
\declinst{B}{}{B}
\declinst{C}{}{C}
\declinst{D}{}{D}

\mess{$x$}{A}{B}
\mess{$x$}{A}[.62]{C}[1]
\mess{$x$}{A}[.8]{D}[2]

\nextlevel
\mess{$y$}{C}[.75]{A}[1]

\nextlevel

\end{msc}
\end{center}

\begin{center}
\drawinstfoot{no}
% \setmscscale{.8}
\begin{msc}{Teased apart}
\setlength{\levelheight}{2.0\levelheight}
\declinst{A}{}{A}
\declinst{B}{}{B}
\declinst{C}{}{C}
\declinst{D}{}{D}
\mess{$x$}{A}{B}

\nextlevel
\mess{$x$}{A}[.75]{C}

\nextlevel
\mess{$x$}{A}[.83]{D}

\nextlevel
\mess{$y$}{C}[.75]{A}

\end{msc}
\end{center}
\caption{Simplifying pictures}
\label{fig:atomic-nonatomic}
\end{figure}

%\clearpage

\paragraph{A detailed look at retry}

Figure~\ref{fig:consensus-retry} shows (part of) one possible run of
the consensus protocol, in which a round ends not in consensus but in
a retry that starts a new round.  We assume that \lstinline{flrs}~=~1,
so there are four instances of \lstinline{Replica} and a proposal will
be accepted if it gets three votes.  The diagram does not depict all
the classes---in particular, we show only three of the replicas---and
does not display all the messages sent.  It contains abbreviations,
which are defined in the following table:
%\vspace{1.0ex}
\begin{center}
\begin{tabular}{|lcl|}
\hline
\emph{vote}$_{1x}$ &=& \msg{vote}{((2,0), x, l_1)} \\
\emph{vote}$_2$ &=& \msg{vote}{((2,0), x, l_2)} \\
\emph{vote}$_{4y}$ &=& \msg{vote}{((2,0), y, l_4)} \\
\emph{retry}$_x$ &=& \msg{retry}{((2,1),x)} \\
\emph{vote}$'_{2x}$ &=& \msg{vote}{((2,1), x, l_2)} \\
$\alpha$ &:& start \listinline{Round} ((2,0),$x$);
             \listinline{Quorum} state = $([x],[l_1])$ \\
$\beta$  &:& \listinline{Quorum} state = $([x;x],[l_1;l_2])$  \\
$\gamma$ &:& \listinline{Quorum} state = $([x;x;y],[l_1;l_2;l_4])$ \\
$\delta$ &:& start \listinline{Round} ((2,1),$x$);
             \listinline{Quorum} state = $([x],[l_2])$\\
\hline
\end{tabular}
\end{center}
%\vspace{1.0ex}

Note that votes not marked with a ``$'$'' are cast in inning 0 (i.e.,
in this case, round (2,0)) and votes marked with ``$'$'' are cast in
inning 1.

This run begins when the \lstinline{Replica} at location $l_1$
receives a proposal $(2,x)$ from the environment.  We assume that
location $l_1$ has not previously received a vote or proposal for
command $2$; accordingly, it responds by spawning an instance of
\lstinline{Voter}~$(2,x)$ at $l_1$.  Only one component of this
\lstinline{Voter} will play a role: \lstinline{Round}~$((2,0),x)$.
This class broadcasts \emph{vote}$_{1x}$, a vote for the proposal it
received---though the diagram shows only two of those messages.  Its
\lstinline{Quorum} component plays no role in this part of the run.

A \lstinline{Replica} can respond to either a vote or a proposal.
When the \lstinline{Replica} at location $l_2$ receives
\emph{vote}$_{1x}$ (also assumed to be new), it spawns an instance of
\lstinline{Voter}~$(2,x)$ at $l_2$.  This initiates an instance of
\lstinline{Round}~$((2,0),x)$ at location $l_2$, which will broadcast
\emph{vote}$_2$ and spawn an instance of \lstinline{Quorum}~$(2,0)$ at
$l_2$.  Of this broadcast we show only the message it sends to
itself.\footnote{The \lstinline{Replica} at location $l_2$ sees this
  vote but, as it has already seen a vote for command 2, the self
  message does not cause it to spawn a new \lstinline{Voter}.}
Comment $\alpha$ says that the vote that spawned the \lstinline{Round}
updates the internal state of \lstinline{Quorum} to $([x],[l_1])$,
recording the fact that a vote for command $x$ came from $l_1$.  As
$\beta$ indicates, the self message updates the state of this
\lstinline{Quorum} to $([x;x],[l_1;l_2])$.

Meanwhile, the \lstinline{Replica} at location $l_4$ has received a
competing proposal: that command 2 be $y$, not $x$.  It spawns
\lstinline{Voter}~$(2,y)$, which broadcasts \emph{vote}$_{4y}$; we
show only the message received by the Voter at $l_2$.  This updates
the state of \lstinline{Quorum} at $l_2$ to $([x;x;y],[l_1;l_2;l_4])$.
Once it has received votes from three distinct locations
\lstinline{Quorum} makes a decision: in this case, because the votes
are not unanimous, it must start a new round by sending itself a
\emph{retry} message.\footnote{It is possible that the fourth
  \lstinline{Replica} would cast a vote for proposal $(2,x)$,
  providing the three votes, but that would come too late.}  As
$\delta$ indicates, this retry starts \lstinline{Round}~$((2,1),x)$.
So the \lstinline{Voter} at $l_2$ begins by broadcasing
\emph{vote}$'_{2x}$.

\begin{figure}
\begin{center}
\drawinstfoot{no}
\begin{msc}{Retry}
\setlength{\levelheight}{2.0\levelheight}
\declinst{Rep1}{$l_1$}{\small Rep1}
\dummyinst{Voter1}
\declinst{Rep2}{$l_2$}{\small Rep2}
\dummyinst{Voter2}
\dummyinst{Voter4}
\declinst{Rep4}{$l_4$}{\small Rep4}

\mess{\small (prop,$(2,x)$)}{envleft}{Rep1}

\nextlevel  % level 1
\create{}{Rep1}{Voter1}{}{\small Voter$(2,x)$}

\nextlevel  % level 2
\mess{\small \emph{vote}$_{1x}$}{Voter1}{Voter1}[1]
\mess{\small \emph{vote}$_{1x}$}{Voter1}{Rep2}
\mess{\small (prop,$(2,y)$)}{envright}{Rep4}

\nextlevel % level 3
\create{}{Rep2}{Voter2}{}{\small Voter$(2,x)$}
\create{}{Rep4}{Voter4}{}{\small Voter$(2,y)$}

\nextlevel % level 4
\action{$\alpha$}{Voter2}

\nextlevel % level 5
\mess{\small \emph{vote}$_{2x}$}{Voter2}{Voter2}[1]

\nextlevel[2] % level 7
\action{$\beta$}{Voter2}

\nextlevel % level 8
\mess{\small \emph{vote}$_{4y}$}{Voter4}{Voter2}

\nextlevel % level 9
\action{$\gamma$}{Voter2}

\nextlevel % level 10
\mess{\small retry$_x$}{Voter2}{Voter2}[1]

\nextlevel[2] % level 12
\action{$\delta$}{Voter2}

\nextlevel
\mess{\small \emph{vote}$'_{2x}$}{Voter2}{Voter4}
\mess{\small \emph{vote}$'_{2x}$}{Voter2}[.75]{Voter1}

\end{msc}
\end{center}
\caption{Detailed example of a retry}
\label{fig:consensus-retry}
\end{figure}

%\clearpage

\paragraph{Notification and retry in the same round}

Figure~\ref{fig:consensus-notify-retry} shows part of a run in which
the \lstinline{Voter} at $l_1$ broadcasts a notification that the
second command will be $x$, but the \lstinline{Voter} at $l_2$ sends a
retry that launches a new round.  As before, the diagram does not
depict all the classes or all the messages sent.  Instead of walking
through the successive states of the \lstinline{Quorum} classes, we
only note their states when they reach a decision.  The abbreviations
are as follows:
%\vspace{1.0ex}
\begin{center}
\begin{tabular}{|lcl|}
\hline
\emph{vote}$_{1x}$ &=& \msg{vote}{((2,0), x, l_1)} \\
\emph{vote}$_{2x}$ &=& \msg{vote}{((2,0), x, l_2)} \\
\emph{vote}$_{3x}$ &=& \msg{vote}{((2,0), x, l_3)} \\
\emph{vote}$_{4y}$ &=& \msg{vote}{((2,0), y, l_4)} \\
\emph{decided}$_x$ &=& \msg{decided}{(2,x))} \\
\emph{notify}$_x$ &=& \msg{notify}{(2,x)} is broadcast to all clients \\
\emph{retry}$_x$ &=& \msg{retry}{((2,1),x)} \\
$\alpha$ &:& \listinline{Quorum} state = $([x;x;x],[l_1;l_2;l_3])$ \\
$\beta$ &:& \listinline{Quorum} state = $([x;x;y],[l_1;l_2;l_3])$ \\
$\gamma$ &:& start \listinline{Round} ((2,1),$x$);
             \listinline{Quorum} state = $([x],[l_2])$\\
\hline
\end{tabular}
\end{center}
%\vspace{1.0ex}

The first three votes seen by the \lstinline{Voter} at location $l_1$
are votes for $x$, so it notifies all clients that agreement has been
reached---command 2 is $x$---and sends a \lstinline{decided} message
to stop all the Voters working on command 2.  The \lstinline{Voter} at
location $l_2$ sees two votes for $x$ and one for $y$ and it launches
a new round before it receives the \lstinline{decided} message that
stops it.  The crucial point is that, on launching this round it casts
its vote for $x$.  If the retry proposed $y$, it might be possible
that the remaining voters in some later round would come to consensus
on command $y$; clients would then receive a contradictory
notification saying that command 2 is $y$.
Section~\ref{sec:simple-consensus-consistent} explains why this
calamity cannot occur.



\begin{figure}
\begin{center}
\drawinstfoot{no}
\setmscscale{.8}
\begin{msc}{Notification and Retry}
\setlength{\levelheight}{2.0\levelheight}
\declinst{Rep1}{$l_1$}{\small Rep1}
\dummyinst{Voter1}
\declinst{Rep2}{$l_2$}{\small Rep2}
\dummyinst{Voter2}
\dummyinst{Voter3}
\declinst{Rep3}{$l_3$}{\small Rep3}
\dummyinst{Voter4}
\declinst{Rep4}{$l_4$}{\small Rep4}

\mess{\small (prop,$(2,x)$)}{envleft}{Rep1}

\nextlevel
\create{}{Rep1}{Voter1}{}{\small Voter$(2,x)$}

\nextlevel
\mess{\small \emph{vote}$_{1x}$}{Voter1}{Rep3}

\nextlevel
\mess{\small \emph{vote}$_{1x}$}{Voter1}{Voter1}[1]
\mess{\small \emph{vote}$_{1x}$}{Voter1}{Rep2}
\mess{\small (prop,$(2,y)$)}{envright}{Rep4}
\create{}{Rep3}{Voter3}{}{\small Voter$(2,x)$}

\nextlevel % level 3
\create{}{Rep2}{Voter2}{}{\small Voter$(2,x)$}
\create{}{Rep4}{Voter4}{}{\small Voter$(2,y)$}

\nextlevel % level 4
\mess{\small \emph{vote}$_{2x}$}{Voter2}[.75]{Voter1}

\nextlevel[2] % level 7
\mess{\small \emph{vote}$_{3x}$}{Voter3}{Voter1}

\nextlevel
\action{$\alpha$}{Voter1}
\mess{\small \emph{vote}$_{4y}$}{Voter4}{Voter2}

\nextlevel % level 8
\action{$\beta$}{Voter2}

\nextlevel
\mess{\small \emph{retry}$_x$}{Voter2}{Rep2}

\nextlevel
\action{$\gamma$}{Voter2}

\nextlevel
\mess{\small \emph{notify}$_x$}{Voter1}{envleft}
\mess{\small \emph{decided}$_x$}{Voter1}{Voter2}
\mess{\small \emph{decided}$_x$}{Voter1}{Voter1}[1]


\nextlevel
\stop{Voter2}

\nextlevel
\stop{Voter1}

\end{msc}
\end{center}
\caption{Notify and Retry on the same round}
\label{fig:consensus-notify-retry}
\end{figure}

%\clearpage

\paragraph{Failure to achieve consensus}

Figure~\ref{fig:consensus-failure} illustrates a run in which this
protocol fails to achieve consensus, a possibility that, according to
the FLP theorem~\cite{Fischer+Lynch+Patterson:1985} is inevitable.
The abbreviations are as follows:
%\vspace{1.0ex}
\begin{center}
\begin{tabular}{|lcl|}
\hline
\emph{vote}$_{1x}$ &=& \msg{vote}{((2,0), x, l_1}) \\
\emph{vote}$_{2x}$ &=& \msg{vote}{((2,0), x, l_2}) \\
\emph{vote}$_{3y}$ &=& \msg{vote}{((2,0), y, l_3}) \\
\emph{vote}$_{4y}$ &=& \msg{vote}{((2,0), y, l_4}) \\
\emph{retry}$_x$ &=& \msg{retry}{((2,1),x}) \\
\emph{retry}$_y$ &=& \msg{retry}{((2,1),y}) \\
$\alpha_1$ &:& \listinline{Quorum} state = $([x;x],[l_1;l_2])$ \\
$\alpha_2$ &:& \listinline{Quorum} state = $([x;x;y],[l_1;l_2;l_4])$ \\
$\alpha_3$ &:& start \listinline{Round} ((2,1),$x$);
               \listinline{Quorum} state = $([x],[l_1])$\\
$\beta_1$ &:& \listinline{Quorum} state = $([y;y],[l_4;l_3])$ \\
$\beta_2$ &:& \listinline{Quorum} state = $([y;y;x],[l_4;l_3;l_1])$ \\
$\beta_3$ &:& start \listinline{Round} ((2,1),$y$);
              \listinline{Quorum} state = $([y],[l_4])$\\
\hline
\end{tabular}
\end{center}
%\vspace{1.0ex}

We omit the \lstinline{Voter} classes spawned at locations $l_2$ and
$l_3$, depicting their messages as coming directly from the
\lstinline{Replica} classes themselves.  In round~(2,0), the
\lstinline{Replica} at $l_1$ votes for $x$ and the \lstinline{Replica}
voting for $y$.  This exchange of messages results in abandoning round
(2,0).  But round (2,1) begins in exactly the same way: with
\lstinline{Replica} at $l_1$ voting for $x$ and at $l_2$ voting for
$y$.   The pattern can in principle repeat endlessly.

\begin{figure}
\begin{center}
\drawinstfoot{no}
\setmscscale{.8}
\begin{msc}{No consensus}
\setlength{\levelheight}{2.0\levelheight}
\declinst{Rep1}{$l_1$}{\small Rep1}
\dummyinst{Voter1}
\declinst{Rep2}{$l_2$}{\small Rep2}
\declinst{Rep3}{$l_3$}{\small Rep3}
\dummyinst{Voter4}
\declinst{Rep4}{$l_4$}{\small Rep4}

\mess{\small (prop,$(2,x)$)}{envleft}{Rep1}
\mess{\small (prop,$(2,y)$)}{envright}{Rep4}

\nextlevel
\create{}{Rep1}{Voter1}{}{\small Voter$(2,x)$}
\create{}{Rep4}{Voter4}{}{\small Voter$(2,y)$}

\nextlevel
\mess{\small \emph{vote}$_{1x}$}{Voter1}{Rep2}
\mess{\small \emph{vote}$_{1x}$}{Voter1}{Voter1}[1]
\mess{\small \emph{vote}$_{4y}$}{Voter4}{Rep3}
\mess{\small \emph{vote}$_{4y}$}{Voter4}{Voter4}[1]

\nextlevel[2]
\mess{\small \emph{vote}$_{2x}$}{Rep2}{Voter1}
\mess{\small \emph{vote}$_{3y}$}{Rep3}{Voter4}

\nextlevel
\action{$\alpha_1$}{Voter1}
\action{$\beta_1$}{Voter4}

\nextlevel
\mess{\small \emph{vote}$_{4y}$}{Voter4}{Voter1}
\nextlevel
\mess{\small \emph{vote}$_{1x}$}{Voter1}{Voter4}

\nextlevel
\action{$\alpha_2$}{Voter1}
\action{$\beta_2$}{Voter4}

\nextlevel
\mess{\small \emph{retry}$_{x}$}{Voter1}{Voter1}[1]
\mess{\small \emph{retry}$_{y}$}{Voter4}{Voter4}[1]

\nextlevel[2]
\action{$\alpha_3$}{Voter1}
\action{$\beta_3$}{Voter4}

\nextlevel

\end{msc}
\end{center}
\caption{Failure to achieve consensus}
\label{fig:consensus-failure}
\end{figure}

\subsection{Properties of the 2/3-consensus protocol}
\label{sec:simple-consensus-consistent}

\paragraph{Consistency}

The 2/3-consensus protocol must satisfy the basic safety property of
\emph{consistency}---if the messages $(\MSG{notify}{\NUPRLpair{n}{x}})$ and
$(\MSG{notify}{\NUPRLpair{n}{y}})$ are sent, then $x=y$.  The example in
figure~\ref{fig:consensus-notify-retry} makes it clear that the
following property is necessary (though not quite sufficient) to
guarantee that.

\begin{quote}
If, in any round, some \lstinline{Voter} finds a quorum for command
$x$, then, in that round, $x$ is the only command that can be proposed
by a \lstinline{retry} message.
\end{quote}

\noindent{PROOF:} Suppose that one \lstinline{Voter} sees $2f+1$
votes for command $x$ in a given round.  Since each \lstinline{Voter}
votes for only one command in any round, that round can contain no
more than $f$ votes for any command other than $x$.  Now consider the
situation of any other \lstinline{Voter} making a decision in that
round: It will have received $2f+1$ votes, and at most $f$ of them can
be for a command other than $x$.  Therefore, at least $f+1$ of the
votes it sees must be for $x$; so if it sends a retry message, that
retry proposes $x$.

\vspace{1.0ex}

The argument is not quite done.  Suppose one \lstinline{Voter} finds a
quorum for $x$ in round $\NUPRLpair{n}{i}$ but other Voters do not,
and will therefore participate in subsequent rounds.  Is it possible
that one of those later rounds contains a vote for some other command
$y$ (possibly as the result of a new proposal received from some
external source), and that, as a result, some later round
$\NUPRLpair{n}{j}$ finds a quorum for $y$?  No, because a stronger
property holds.

\begin{quote}
If some \lstinline{Voter} finds a quorum for command $x$ in round
$\NUPRLpair{n}{i} $ then in any round $\NUPRLpair{n}{j}$ with $j >$ i
all votes cast are votes for $x$.
\end{quote}

\noindent{PROOF:} Every vote can ultimately be traced either to a
\lstinline{retry} message or to a \lstinline{proposal} message
received by some \lstinline{Replica} from an external source.
However, a \lstinline{Replica} will ignore a proposal with body
$\NUPRLpair{n}{c}$ unless it has \emph{never} before received either a
proposal or a vote for something of the form $\NUPRLpair{n}{\_}$.
Thus, votes that arise from external proposals can be cast only in
rounds of the form $(\_,0)$.  That is to say that all votes in round
$\NUPRLpair{n}{i}$ with $i > 0$ arise from retry messages sent in
round $\NUPRLpair{n}{i-1}$.  So, by induction, once we encounter any
round in which all retry messages are for command $x$, all subsequent
rounds can only contain votes for $x$.

\paragraph{Fault tolerance}

When a process suffers a \emph{crash failure} it stops sending
messages.  (It does not perform erratically by, e.g., violating the
requirements of the protocol.)  The 2/3-consensus protocol will
tolerate up to \lstinline{flr} crash failures, in the following sense:

\begin{quote}
All executions of the protocol that suffer only crash failures, and no
more than \lstinline{flr} of those, are \emph{non-blocking}---that is,
execution never reaches a state from which consensus is impossible.
\end{quote}

By the FLP theorem, this is the strongest fault tolerance guarantee
that a consistent consensus protocol can provide.

\section{Paxos}\label{sec:Paxos}

Paxos is also a consensus protocol for coordinating the behavior of
copies of a state machine that has been replicated to tolerate crash
failures.  It requires only $2n+1$ copies in order to tolerate $n$
failures.  The \eml\ program formalizes the pseudo-code description of
Paxos given in~\cite{VanRenesse:2011}.  We assume that the reader is
familiar with that paper and has a copy in hand.

\subsection{A gross description of the protocol}

This section gives a very high-level description of how participants
in the protocol---Replicas, Leaders, and Acceptors---interact.  It
omits much of the combinatorial detail that makes the protocol work.

\subsubsection{Replicas}

A Replica puts a wrapper around a copy of the state machine we want to
replicate.  To invoke an operation on the state machine a client sends
every Replica a request that contains a \lstinline{Command} consisting
of three things: the client's return address; the name of an operation
to be performed; an identifier, a ``client id,'' chosen by the client.
After the operation is performed the client will receive a message
containing both the result and that identifier---so clients should
give distinct requests distinct client id's, but the correctness of
the protocol does not depend on that.

On receiving requests, Replicas formulate proposals.  A
\lstinline{Proposal} is a pair consisting of a positive integer and a
\lstinline{Command}.\footnote{Depending on context,
  \cite{VanRenesse:2011} uses the word ``proposal'' sometimes for a value
  of type \lstinline{Command} and sometimes for one of type
  \lstinline{Proposal}.} Intuitively,
$\NUPRLpair{\NUPRL{n}}{\NUPRL{cmd}}$ ``proposes'' that $\NUPRL{cmd}$
should be the $\NUPRL{n}^{th}$ command performed by each copy of the
state machine; we call $\NUPRL{n}$ the \emph{slot number} of the
proposal.

Replicas send proposals to Leaders; Leaders send to Replicas
\lstinline{decision} messages containing the \lstinline{Proposal}
values on which the protocol has achieved consensus.

More specifically, when a Replica receives a request for command
$\NUPRL{cmd}$, it chooses the least slot number $\NUPRL{n}$ for which
it has neither made a previous proposal nor received a decision and
sends the proposal $\NUPRLpair{\NUPRL{n}}{\NUPRL{cmd}}$ to every
Leader.  A Replica that has proposed
$\NUPRLpair{\NUPRL{n}}{\NUPRL{cmd}}$ may subsequently receive a
\lstinline{decision} message choosing some other command for slot
$\NUPRL{n}$; if so, and if the Replica has not already executed
$\NUPRL{cmd}$, the Replica will propose the command for a different
slot.  (Note: Leaders may receive proposals to put the same command in
different slots and, as a result, the same command may be chosen for
multiple slots; but it will not be executed more than once.)

There may be gaps in what a Replica knows---e.g., it may have received
$\NUPRLpair{\NUPRL{1}}{\NUPRL{cmd}_1}$,
$\NUPRLpair{\NUPRL{2}}{\NUPRL{cmd}_2}$, and
$\NUPRLpair{\NUPRL{4}}{\NUPRL{cmd}_4}$, in \lstinline{decision}
messages, but no such message about any proposal of the form
$\NUPRLpair{\NUPRL{3}}{\_\_}$.  In this state, a Replica may execute
${\NUPRL{cmd}_1}$ and ${\NUPRL{cmd}_2}$, in that
order\footnote{Assuming that neither of them has previously been
  executed.}, but may not execute any further commands until it has
received a decision about the command for slot number 3.  The details
of the bookkeeping make Replicas the most algorithmically complex of
the participants, but they are from our point of view the least
interesting, because the actions of the Replicas are essentially
independent of the protocol used to obtain consensus.

\subsubsection{Leaders and Acceptors}\label{sec:Leaders-Acceptors}

The heart of the protocol is the interaction between Leaders and
Acceptors, which can be defined independently of the beavior of the
Replicas.  Leaders engage in a dialogue with the Acceptors to
determine which of the proposals they receive will be agreed to.
Acceptors vote and their votes are tallied by processes that the
Leaders spawn.  As usual, any one election need not yield a decision;
so re-votes must be accommodated.  Each Leader has an unbounded supply
of ballot numbers (of type \lstinline{Ballot_Num}), disjoint from the
supply of every other Leader.  The data contained in a vote is a
``pvalue'' consisting of a ballot number and a \lstinline{Proposal}
(voted for on that ballot).  The set of \emph{all} ballot numbers is
linearly ordered.

The Leader/Acceptor dialogue consists of two phases, repeated as often
as necessary.  To carry out each instance of phase~1 a Leader chooses
a ballot number from its supply and spawns a Scout process that
exchanges messages with Acceptors to determine whether that ballot
number will be \emph{adopted} or \emph{preempted}.\footnote{These
  messages will contain additional data needed for bookkeeping.}
Scouts send \lstinline{p1a} messages and Acceptors reply with
\lstinline{p1b} messages.  If the ballot number is preempted, the
Leader will choose a new ballot number and spawn a new Scout for it.
(As will be seen, a ballot number may also be preempted in phase 2.)
If its ballot number is adopted, a Leader proceeds to phase 2.

To carry out phase 2, a Leader spawns Commander processes that solicit
votes from Acceptors.  Each Commander is associated with a pvalue,
\bsp, where $\NUPRL{b}$ is a ballot number adopted in phase 1 and not
(yet) preempted.  (Call this an ``active'' ballot number.)  The Commander
asks the Acceptors for the highest ballot number they've seen
(including the $\NUPRL{b}$ they've just received).  Commanders send
\lstinline{p2a} messages and Acceptors reply with \lstinline{p2b}
messages.  The Commander for \bsp\ tallies the replies from
Acceptors, which will result either in choosing $\NUPRLpair{s}{p}$ (in
which case the Commander notifies the Replicas with
\lstinline{decision} messages) or preempting $\NUPRL{b}$ (causing the
Leader to choose a new ballot number and spawn a new Scout).

The phase 1 and phase 2 voting dialogues are described further in
section~\ref{sec:paxos-voting}.

\vspace{1.0ex} All a Leader does is spawn Scouts and Commanders.  Its
state consists of three things: a ballot number; a boolean that is
true iff that ballot number is active; a list of proposals that the
Leader is working on.  This list will always be consistent (as defined
in section~\ref{sec:types-variables}).  A Leader begins by spawning a
Scout for the least ballot number that it owns and thereafter responds
to \lstinline{preempted}, \lstinline{propose}, and \lstinline{adopted}
messages.

A \lstinline{preempted} message, which may come from a Scout or a
Commander, causes a Leader to choose a new ballot number (which will
be ``bad'' unless and until it becomes adopted) and spawn a Scout for
it.

A \lstinline{propose} message comes only from a Replica.  In response
to $\MSG{propose}{\NUPRLpair{s}{p}}$, a Leader acts as follows:
If it has already received a proposal for slot $\NUPRL{s}$ it ignores
the input.  If not, it adds $\NUPRLpair{s}{p}$ to the list of
proposals it's working on; and if, in addition, its current ballot
number $\NUPRL{b}$ is active, it spawns a Commander for \bsp.

If a Leader receives an \lstinline{adopted} message for its current
ballot number (call it $\NUPRL{bn}$), the Leader first uses additional
data in the message to update its list of ``proposals I'm currently
working on.''  (The details are somewhat complex.)  Then, for each
proposal $\NUPRLpair{s}{p}$ in that revised list it spawns a Commander
for $\NUPRLpair{bn}{\NUPRLpair{s}{p}}$.  (An \lstinline{adopted}
message for a ballot number other than $\NUPRL{bn}$ will be ignored.)

\subsubsection{The voting}\label{sec:paxos-voting}

\paragraph{Phase 1, simplified:}

A Scout for ballot number $\NUPRL{b}$ sends every Acceptor a
\lstinline{p1a} message containing $\NUPRL{b}$.  An Acceptor replies
with a \lstinline{p1b} message containing (among other things) the
greatest ballot number that it has so far received (in either a
\lstinline{p1a} or \lstinline{p2a} message)---which is guaranteed
to be a ballot number at least as great as $\NUPRL{b}$.  The Scout
tallies responses and comes to a decision as soon as one of the
following two things happens:
\begin{enumerate}
\item\label{acceptor-preempts}
It receives a \lstinline{p1b} message with a value
$\NUPRL{b'}\neq\NUPRL{b}$.

In this case, the Scout sends the Leader a \lstinline{preempted}
message with value $\NUPRL{b'}$.   The Leader will update its current
ballot to a value greater than $\NUPRL{b'}$ and spawn a new Scout for
it.

\item
It receives \lstinline{p1b} messages with value $\NUPRL{b}$ from a
majority of the Acceptors.

In this case, the Scout sends the Leader an \lstinline{adopted}
message with value $\NUPRL{b}$.  What makes this a simplified account:
an Acceptor sends extra information to a Scout in its \lstinline{p1b}
message and a Scout sends extra information to its Leader in its
\lstinline{adopted} message.  Explaining that will require some
discussion of phase 2.
\end{enumerate}
Because of~(\ref{acceptor-preempts}), the Scout will declare its
ballot number adopted only if it receives a \emph{unanimous} majority.
If, before that occurs, it receives a single reply with a value other
than $\NUPRL{b}$ then it is logically possible that, because of
failures, a majority for $\NUPRL{b}$ cannot exist.

\paragraph{Phase 2, simplified:}

A Commander for the pvalue \bsp\ sends a \msg{p2a}{\bsp}
message to every Acceptor.  Each Acceptor responds with a
\lstinline{p2b} message containing the largest ballot number it has
seen (including $\NUPRL{b}$).  The Commander tallies these responses
just as a Scout does: If it receives a \lstinline{p2b} message with a
$\NUPRL{b'}\neq\NUPRL{b}$ before it receives a unanimous majority for
$\NUPRL{b}$ it preempts; otherwise, it broadcasts a
\lstinline{decision} message for proposal $\NUPRLpair{s}{p}$.

\paragraph{Phases 1 and 2, unsimplified:}

If an Acceptor responds to a
\msg{p2a}{\bsp} message from a
Commander by returning $\NUPRL{b}$, we say that it \emph{accepts} that
pvalue.  An Acceptor keeps track of all the pvalues it has thus far
accepted and includes that set in the \lstinline{p1b} messages it
sends to Scouts.  When a Scout finds that a majority has accepted its
ballot number, it includes in the \lstinline{adopted} message it
sends to the Leader a set consisting of all the pvalues accepted by
all the Acceptors that accepted it.  The Leader will use this
information to constrain the way it spawns Commanders, so as to
guarantee consistency in decisions: if there are decisions for slot
$\NUPRL{n}$ on multiple ballots they all choose the same command.

\vspace{1.0ex} Following these rules literally means that the state of
an Acceptor and the contents of \lstinline{p1b} and
\lstinline{adopted} messages can grow without bound.
\cite{VanRenesse:2011} notes simple optimizations that achieve the
desired result but keep the sizes of the states and messages bounded.

\subsection{Parameters}

Figure~\ref{fig:Paxos-parameters} declares the parameters of the
specification.  This section explains their intended meanings.

\begin{figure}%[!t]
  \begin{lstlisting}[basicstyle=\small]
parameter accpts : Loc Bag  (* Locations of acceptors *)
parameter reps   : Loc Bag  (* Locations of replicas  *)
parameter ldrs   : Loc Bag  (* Locations of leaders   *)
(* We're assuming that none of these bags has repetitions. *)

parameter ldrs_uid : Loc -> Int
(* This function is used to order the leader locations. *)


parameter Op,  eqOp   : Type * Op  Deq (* Operations invoked by replicas.  *)
parameter Cid, eq_Cid : Type * Cid Deq (* Command identifiers              *)

parameter Result      : Type           (* Results returned by replicas     *)
parameter RepState    : Type           (* State of SMs to be replicated    *)

parameter init_rstate : RepState       (* Common initial state of SMs      *)
parameter apply_op    : Op -> RepState -> RepState * Result
  \end{lstlisting}
  \caption{Paxos parameters}
  \label{fig:Paxos-parameters}
\end{figure}

Acceptors will reside at locations in the bag \lstinline{accpts},
Replicas at locations in \lstinline{reps}, and Leaders at locations
\lstinline{ldrs}.  We will assume that none of these bags contains
repetitions but do not assume that they are disjoint.

The main program, given in figure~\ref{fig:Paxos-main-program}, is
\begin{emlcode}
\begin{lstlisting}
main Leader @ ldrs || Acceptor @ accpts || Replica @ reps
\end{lstlisting}
\end{emlcode}
Instances of event classes implementing the \lstinline{Scout} and
\lstinline{Commander} will be spawned by, and therefore co-located
with, \lstinline{Leader} classes.

We use the function parameter \lstinline{ldrs_uid} to order the
locations of leaders, and thereby to order the ballot numbers; we
therefore assume that it maps each element of \lstinline{ldrs} to a
different integer.

\lstinline{Cid} is the type of client id's.  Recall: A user who sends
the replicas a request to perform some operation will tag the request
with a value from \lstinline{Cid}; the return value that the user
receives will be tagged with the same value.  Clients should tag their
requests sensibly, but the protocol doesn't care how they do it.

The remaining parameters model the abstract state machine being
replicated.  It has a state, of type \lstinline{RepState}, whose
initial value is \lstinline{init_state}.  Inputs to the state machine,
of type \lstinline{Op}, name operations to be performed.  The
transition function \lstinline{apply_op} takes an \lstinline{Op} and
\lstinline{RepState} as arguments and returns a pair consisting of a
new \lstinline{RepState} and an output value of type
\lstinline{Result}.  Our current notion of configuration file
(section~\ref{sec:configuration}) is not rich enough to specify how to
map these parameters to the actions of a state machine we wish to
replicate.

\subsection{Types and variables}\label{sec:types-variables}

The types defined in figure~\ref{fig:Paxos-types} encode the types
used in~\cite{VanRenesse:2011}.  This section a few details of the
encoding that may not be immediately obvious.

\begin{figure}%[!t]
  \begin{lstlisting}[basicstyle=\small]
type Ballot_Num = (Int * Loc) + Unit;;
type Command    = Loc * Cid * Op ;;
type Slot_Num   = Int ;;
type Proposal   = Slot_Num * Command;;
type PValue     = Ballot_Num * Proposal ;;
type PVlist     = PValue List;;
type ReplicaState = RepState * Slot_Num * Proposal List * Proposal List ;;

(* ------ VARIABLES ------ *)

variable loc, loc1, loc2  : Loc
variable cid, cid1, cid2  : Cid
variable op1, op2 : Op
variable slt, slt1, slt2  : Slot_Num
variable bnum, bnum1, bnum2  : Ballot_Num
variable cmd : Command
variable state : ReplicaState

  \end{lstlisting}
  \caption{Paxos types and variables}
  \label{fig:Paxos-types}
\end{figure}

As noted, the ballot numbers are ordered.  They are of two kinds: a
``normal'' ballot number is a pair containing an integer and the
location of a \lstinline{Leader}; the ``special'' ballot number $\bot$
is less than every normal one.  The type \lstinline{Ballot_Num} is
therefore a disjoint union: the normal values belong to the left hand
side of the union and $\bot$ is the unique element of the right hand
side, represented by the value
\lstinline{dummy_ballot}~=~\lstinline{inr ()}.  (This constant is
declared later in the specification, along with the constants used to
represent initial values.)

Replicas use values of type \lstinline{Slot_Num} to index commands in
the order in which they are to be performed.  These index values will
always be positive integers.  Although the type of positive integers
is definable in \nuprl, it is not definable in \eml.  So we make
\lstinline{Slot_Num} a synonym for \lstinline{Int}.

Type \lstinline{ReplicaState} represents values of the internal state
of the process \emph{Replica} defined in~\cite{VanRenesse:2011}, the
wrapper process that includes the state machines we want to replicate.
The state variables \emph{proposals} and \emph{decisions} that
\cite{VanRenesse:2011} represents as sets of proposals we represent as
lists of proposals; \eml\ does not provide a type constructor for
sets.  (For technical reasons, explained in
section~\ref{sec:Replicas}, the internal state of the event class
\lstinline{Replica} will contain one additional component.)

It will be an invariant that each of these lists is \emph{consistent}
in the following sense: 
%
\index{consistent list}
%
A list of pairs is consistent if, whenever it contains both
$\NUPRLpair{x}{y}$ and $\NUPRLpair{x}{y'}$, then $y = y'$.  It is
possible in \nuprl\ to define a type consisting of consistent lists,
but such a type definition is not possible in \eml.

\subsection{Imports}

\begin{figure}%[!t]
  \begin{lstlisting}[basicstyle=\small]
import map mapfilter deq-member 
       bag-append bl-exists bag-size bag-remove 
       SM1-class SM2-class Memory3
  \end{lstlisting}
  \caption{Paxos imports}
  \label{fig:Paxos-imports}
\end{figure}

The \lstinline{SM*-class} operations and \lstinline{Memory3} are class
combinators defined in section~\ref{sec:state-machine}.  The
operations \lstinline{map}, \lstinline{deq-member},
\lstinline{bag-size}, and \lstinline{bag-remove} have already been
encountered in section~\ref{sec:simple-consensus}.

\begin{itemize}
\item
\lstinline{quicksort-int} is what the name says: It sorts integer
lists in ascending order via quicksort.

\item
If $P:\NUPRLarrow{T}{\listinline{Bool}}$ and
$L:\NUPRLlist{T}$.  Then 

   \begin{itemize}
   \item
   $(\listinline{filter}~P~L)$ is the sublist of $L$ consisting
   of elements that satisfy $P$.  

    \item
    If, in addition, $f:\NUPRLarrow{T}{T'}$, then
    $\listinline{mapfilter}~f~P = 
    \listinline{map}~f~(\listinline{filter}~P~L)$


    \item
    $(\listinline{bl-exists}~L~P)$ returns a boolean; its value is
      \listinline{true} iff some element of $L$ satisfies
      $P$. 

    \end{itemize}

\item
If $f:\NUPRLarrow{S}{\NUPRLarrow{T}{S}}$ and
$y:S$ and $x_i:T$ then
   $\listinline{list_accum}~f~y~[x_1;x_2;x_3] =
   f~(f~(f~y~x_1)~x_2)~x_3$
\end{itemize}

\subsection{Auxiliary functions}

Figure~\ref{fig:Paxos-auxiliaries-1} defines operations that perform a
number of auxiliary bookkeeping duties.  The reader should consult it,
and the explanations below, as needed.

\begin{figure}%[!t]
  \begin{lstlisting}[basicstyle=\small]
let same_command  (loc1,cid1,op1) (loc2,cid2,op2) = loc1 = loc2 & cid1 = cid2 ;;
let same_proposal (slt1,cmd1) (slt2,cmd2) = slt1 = slt2 & same_command cmd1 cmd2;;
let same_pvalue   (bnum1,prp1) (bnum2,prp2) = bnum1 = bnum2 & same_proposal prp1 prp2 ;;

let in_domain deq x xys = deq-member deq x (map fst xys) ;;

let add_if_new test val lst =
  if bl-exists lst (test val)
  then lst
  else lst ++ [val] ;;

let append_news test = list_accum (\a.\x.add_if_new test x a);;

let leq_bnum' (i1,l1) (i2,l2) = i1 < i2 or (i1 = i2 & ldrs_uid l1 <= ldrs_uid l2);;

(* leq : Ballot_Num -> Ballot_Num -> Bool ;;*)
let leq_bnum bn1 bn2 = !(isl bn1) or (isl bn1 & isl bn2 & leq_bnum' (outl bn1) (outl bn2));;

let lt_bnum' (i1,l1) (i2,l2) = i1 < i2 or (i1 = i2 & ldrs_uid l1 < ldrs_uid l2);;

let lt_bnum bn1 bn2 =
  (!(isl bn1) & isl bn2)
  or
  (isl bn1 & isl bn2 & lt_bnum' (outl bn1) (outl bn2));;

(* max : Ballot_Num -> Ballot_Num -> Ballot_Num ;;*)
(* If they're equal, we take bn2. *)
let max_bnum bn1 bn2 = if leq_bnum bn1 bn2 then bn2 else bn1;;

let pmax pvals =
  (* We keep only the ones where the slot_number is = and the ballot num is > *)
  let g bn slt (bn',(s',_)) = s = s' & lt_bnum bn bn' in
  (* P says that bn has to be a isl. *)
  let P (bn, (s, c)) = !(bl-exists pvals (g bn s)) in
    mapfilter snd P pvals;;

let update_proposals proposals1 proposals2 =
  list_accum (\a.\ (slt,p).
                  if bl-exists proposals2 (\ (s',_). slt = s')
                  then a
                  else (slt,p) . a)
             proposals2
             proposals1 ;;

(* A computed parameter *)
let threshold = (bag-size accpts + 1) / 2 ;;
  \end{lstlisting}
  \caption{Paxos part 1, auxiliaries}
  \label{fig:Paxos-auxiliaries-1}
\end{figure}

\subsubsection{Equality tests}

Because their definitions make use of declared variables, the
operations \lstinline{same_command}, \lstinline{same_proposal}, and
\lstinline{same_pvalue} are equality tests specifically for the types
\lstinline{Command}, \lstinline{Proposal}, and \lstinline{PValue}.

\subsubsection{Operations on lists}

As noted, we represent sets of proposals as lists of proposals.  Each
proposal is a pair consisting of a slot number and a command.  We need
a few operations for querying and manipulating them.

\[
\listinline{in_range}~\NUPRL{deq}~z~[(x_1,y_1); (x_2,y_2); ...]
\] 
is a boolean value that is \lstinline{true} iff $z$ is one of the
$y_i$.  The argument $\NUPRL{deq}$ denotes an operation that decides
equality among the $y$'s.

\vspace{1.0ex}
%
We also introduce two operations for adding elements to lists without
introducing repetitions.
\[
\listinline{add_if_new}~eq~[x_1;x_2;\ldots;x_n]~v =
   \begin{cases}
   [x_1;x_2;\ldots;x_n] & \text{if $v$ is one of the $x_i$}   \\
   [x_1;x_2;\ldots;x_n;v] & \text{if not}
   \end{cases}
\]
The operator \lstinline{eq} must be an appropriate equality decider.
That requirement is enforced by typechecking, because the definition
of \listinline{add_if_new} contains the expression 
%
(\lstinline{eqof eq}).  The operation \lstinline{eqof} is predefined
in \eml.  If \lstinline{eq} is an equality decider, 
%
(\lstinline{eqof eq}) is \lstinline{eq}; if not, (\lstinline{eqof eq})
is ill-typed.
\vspace{1.0ex}

If \lstinline{eq} is an equality decider, then
\[
\listinline{append_new_elems}~eq~[x_1;\ldots;x_n]~[y_1;\ldots;y_m]
  = [x_1;x_2;\ldots;x_n; a_1;\ldots;a_k]
\]
where the list of $\NUPRL{a}$'s contains one copy of each $\NUPRL{y}_i$
that is not an $\NUPRL{x}_j$.

\subsubsection{Operations on ballot numbers}

The basic operations on ballot numbers are as follows:
\begin{itemize}
\item
\lstinline{leq_bnum} is the less-then-or-equal-to relation.

\lstinline{leq_bnum'} is an auxiliary used only to define
\lstinline{leq_bnum}.  As in~\cite{VanRenesse:2011}, normal ballot
numbers are ordered lexicographically; we use the function parameter
\lstinline{ldrs_uid} to order leaders.

\item
\lstinline{lt_bnum} is the strict-less-then relation (defined from the
auxiliary \lstinline{lt_bnum'}).

\item
\lstinline{max_bnum} $bn_1$ $bn_2$ returns the maximum of $\{bn_1,bn_2\}$.
\end{itemize}

\subsubsection{Auxiliaries introduced in~\cite{VanRenesse:2011}}
\label{auxiliaries-from-paper}

$\listinline{pmax}:\NUPRLarrow{\listinline{PVlist}}{\listinline{PVlist}}$
implements the operation \emph{pmax}.

\vspace{1.0ex}
%
From a list $\NUPRL{pvs}$ of pvalues, it produces a consistent list of
proposals by giving preference to proposals voted for in later
ballots.  More precisely, we'll say that the proposal
$\NUPRLpair{n}{c}$ is \emph{maximal} in the list $\NUPRL{pvs}$ if for
some ballot number $\NUPRL{b},$
$\NUPRLpair{b}{\NUPRLpair{n}{c}}\in{}\NUPRL{pvs}$ and for no ballot
number $b' > b$ does $\NUPRL{pvs}$ contain an element of the form
$\NUPRLpair{b'}{\NUPRLpair{n}{\_\_}}$.  Then
$\listinline{pmax}(\NUPRL{pvs})$ consists of all the maximal elements
of $\NUPRL{pvs}$.  This will be a consistent list of proposals
provided that $\NUPRL{pvs}$ is a consistent list of pvalues---that is,
$\NUPRL{pvs}$ does not contain two entries having the same ballot
number but different proposals.  We will apply \lstinline{pmax} only
to consistent lists of pvalues.

\vspace{1.0ex}
\noindent
$\listinline{update_proposals}:\NUPRLarrow{\listinline{PVlist}}{\NUPRLarrow{\listinline{PVlist}}{\listinline{PVlist}}}$
implements the operator $\oplus$.

\vspace{1.0ex}
%
This is essentially the override operator for partial functions.  If
$\NUPRL{xs}$ and $\NUPRL{ys}$ are consistent lists of proposals, then
$(\listinline{update_proposals}~xs~ys)$ is consistent: it contains all
the proposals in either list, except that, when there is a conflict,
the conflicting proposal from $\NUPRL{xs}$ is omitted.

\subsubsection{Iterating a Mealy machine}

Consider the Mealy machine with input type $\NUPRL{I}$, state type
$\NUPRL{S}$, output type $\NUPRLbag{\NUPRL{R}}$, and transition
function
%
$\NUPRL{tr}:\NUPRLarrow{\NUPRL{I}}
               {\NUPRLarrow{\NUPRL{S}}
                           {\NUPRLprod{\NUPRL{S}}
                                      {\NUPRLbag{\NUPRL{R}}}}}$

We use \lstinline{iterate_tr} to compute the result of applying this
state machine to a sequence of inputs.  That is, if
$\NUPRL{ops}:\NUPRLlist{\NUPRL{I}}$ is the list of inputs to be
processed and and $\NUPRL{init}:\NUPRL{S}$ is the initial state then
(\lstinline{iterate_tr}$~\NUPRL{tr}~\NUPRL{init}~\NUPRL{ops})$ is a
pair $\NUPRLpair{s}{rs}\in\NUPRLprod{\NUPRL{S}}{\NUPRLbag{\NUPRL{R}}}$
such that $\NUPRL{s}$ is the final state after consuming all the
inputs in $\NUPRL{ops}$, in order, and $\NUPRL{rs}$ is the bag
containing \emph{all} the outputs produced along the way.


\subsubsection{Class combinator: \lstinline{OnLoc}}\label{OnLoc-defined}

The polymorphic combinator \lstinline{OnLoc}
%
\index{class combinators!OnLoc combinator}%
%
is primitive.  For any type $\NUPRL{T}$ and any function
$F:\NUPRLarrow{\listinline{Loc}}{\NUPRLclass{\NUPRL{T}}}$,
$(\listinline{OnLoc}~F):\NUPRLclass{\NUPRL{T}}$ is the event
class that, at any location $\NUPRL{l}$, acts like the class $(F~l)$.

It is defined in the underlying computation model by
\(
 \listinline{OnLoc}(F) = \lambda es.\lambda e.(F~\listinline{loc}(e)~es~e)
\)

\subsection{Interface}

Figure~\ref{fig:Paxos-interface} declares all the messages used
in~\cite{VanRenesse:2011}.  The comments indicate who sends which kind
of message to whom.  (Recall that each \lstinline{Scout} and
\lstinline{Commander} is co-located with a \lstinline{Leader}; so a
message sent to or from one of them is sent to or from the location of
its \lstinline{Leader}.)

\begin{figure}%[!t]
  \begin{lstlisting}[basicstyle=\small]
input  request  : Command       (* client    -> Replica *)
output response : Cid * Result  (* Replica   -> client  *)

internal p1a : Loc * Ballot_Num
 (* Scout -> Acceptor, The Loc is the Scout's leader, *)
internal p1b: Loc * (Ballot_Num * PVlist)
(* Acceptor -> Scout, The Loc is the Acceptor's location *)
internal p2a: Loc * PValue
 (* Commander ->  Acceptor, The Loc is the Commander's leader, *)
internal p2b: Loc * Ballot_Num
  (* Acceptor -> Commander,  The Loc is the Acceptor's location *)
internal preempted: Ballot_Num
 (* Commander,Scout->  Leader *)
internal adopted: Ballot_Num *  PVlist
 (* Scout -> Leader *)
internal propose: Proposal
  (* Replica -> Leader *)
internal decision: Proposal
  (* Commander -> Replica *)
  \end{lstlisting}
  \caption{Paxos part 1, interface}
  \label{fig:Paxos-interface}
\end{figure}

\subsection{Initial values}

Figure~\ref{fig:Paxos-initial-values} defines the initial values for
various state machine classes.  Note that the
function\lstinline{init_leader} assigns initial values to instances of
\lstinline{Leader} based on their locations: the initial ballot number
for each \lstinline{Leader} is the least ballot number that it owns.

\begin{figure}%[!t]
  \begin{lstlisting}[basicstyle=\small]
let dummy_ballot : Ballot_Num = inr () ;;

let init_accepted : PVlist = [] ;;
let init_acceptor = (dummy_ballot, init_accepted) ;;

let init_slot_num : Slot_Num = 1 ;;
let init_proposals : Proposal List = [] ;;

let init_pvalues : PVlist = [];;
let init_scout = (accpts, init_pvalues);;

let init_ballot_num loc : Ballot_Num = inl (0,loc);;
let init_active = false ;;
let init_leader loc = (init_ballot_num loc, init_active, init_proposals) ;;

let init_decisions : Proposal List = [] ;;
let init_latest_decision : Proposal + Unit = inr() ;;
let init_replica : ReplicaState = (init_rstate,
                                   init_slot_num,
      	       	   	           init_proposals,
                                   init_decisions) ;;
  \end{lstlisting}
  \caption{Paxos initial values}
  \label{fig:Paxos-initial-values}
\end{figure}

\subsection{Acceptors}\label{sec:Paxos-acceptors}

\begin{figure}%[!t]
  \begin{lstlisting}[basicstyle=\small]
let on_p1a loc (_,x) (ballot_num, accepted) =
  (max_bnum x ballot_num, accepted);;

let on_p2a loc (_,(b,sp):PValue) (ballot_num, accepted) =
  let ballot_num' = max_bnum b ballot_num in
  let accepted' = if leq_bnum ballot_num b
     	          then add_if_new same_pvalue (b,sp) accepted
	       	  else accepted in
    (ballot_num', accepted') ;;

class AcceptorState =
  SM2-class (\l.{init_acceptor})
            (on_p1a, p1a'base)
            (on_p2a, p2a'base) ;;

class AcceptorsP1a =
  let f loc (ldr,_) bnum_acc = {p1b'send ldr (loc,bnum_acc)}
  in f o (p1a'base, AcceptorState) ;;

class AcceptorsP2a =
  let f loc (ldr,_) (bnum, _) = {p2b'send ldr (loc,bnum)}
  in f o (p2a'base, AcceptorState) ;;

let Acceptor = AcceptorsP1a || AcceptorsP2a ;;
  \end{lstlisting}
  \caption{Acceptor}
  \label{fig:Paxos-Acceptor}
\end{figure}

An \lstinline{Acceptor} acts like a state machine.  Its input events
are the arrivals of \lstinline{p1a} or \lstinline{p2a} messages
and its outputs are \lstinline{p1b} and \lstinline{p2b} messages.
Its state has type \lstinline{Ballot_Num * (PVlist)}, and is
initially \lstinline{(dummy_ballot,nil)}.

We first define the ``post'' Moore machine \lstinline{AcceptorState}:
$\dgclassrel{\NUPRLevent}{\listinline{AcceptorState}}{\NUPRL{s}}$ iff
$\NUPRL{s}$ is the value of the state after processing input event
$\NUPRLevent$.  We then define \lstinline{Acceptor} in terms of it,
using the simple composition combinator to compute the output(s) from
the input and the state.

Since \lstinline{AcceptorState}-events are the
\lstinline{p1a'base}-events and the \lstinline{p2a'base}-events, we
define \lstinline{AcceptorState} with the \lstinline{SM2-class}
combinator of section~\ref{sec:state-machine}.  The transition
functions for these two kinds of inputs, \lstinline{on_p1a} and
\lstinline{on_p2a}, straightforwardly encode the updates to the state
variables given in the pseudo-code in Figure~2
of~\cite{VanRenesse:2011}, and described in
section~\ref{sec:paxos-voting}.

We similarly factor the definition of \lstinline{Acceptor} into
classes \lstinline{AcceptorsP1a} and \lstinline{AcceptorsP2a}
responding to the two kinds of inputs:
\begin{lstlisting}
  let Acceptor = AcceptorsP1a || AcceptorsP2a ;;
\end{lstlisting}

The definitions of these classes are similar, so consider the
first:
\begin{lstlisting}
  class AcceptorsP1a =
    let f loc (ldr,_) bnum_acc = {p1b'send ldr (loc,bnum_acc)}
    in f o (p1a'base,AcceptorState) ;;
\end{lstlisting}
An \lstinline{AcceptorsP1a}-event is a \lstinline{p1a'base}-event.
(It must be both an \lstinline{AcceptorState}-event and a
\lstinline{p1a'base}-event, but every \lstinline{p1a'base}-event is an
\lstinline{AcceptorState}-event.)

When the simple composition operator applies the local function
\lstinline{f}
\begin{itemize}
\item
the \lstinline{loc} parameter will match the location at which the
input event occurs (the location of an instance of
\lstinline{Acceptor})

\item
\lstinline{(ldr,_)} will match the observation from
\lstinline{p1a'base} (the body of the incoming \lstinline{p1a}
message; so \lstinline{ldr} is the location of the Leader who spawned
the Scout that sent this message)

\item
\lstinline{bnum_acc} will match the observation of
\lstinline{AcceptorState} (the state after the input event is processed)
\end{itemize}
The output, \lstinline!{p1b'send ldr (loc,bnum_acc)}!, directs to
\lstinline{ldr} a \lstinline{p1b} message containing the location
and state of the \lstinline{Acceptor} that processes it.

Notice: \lstinline{AcceptorsP1a} and \lstinline{AcceptorsP2a} are not
completely independent of one another.  Each of them reacts to inputs
by changing the state in a way that could affect the behavior of the
other.  That is why we use a single Moore machine
\lstinline{AcceptorState}, maintaining the whole state, to define the
two Mealy machines responding to the two different kinds of inputs.

\subsection{Commanders}

\begin{figure}%[!t]
  \begin{lstlisting}[basicstyle=\small]
class CommanderNotify bsp = Output(\ldr.p2a'broadcast accpts (ldr, bsp)) ;;

class CommanderState b =
  let tr loc (loc,b') waitfor =
    if b = b' then bag-remove (op =) waitfor loc else waitfor
  in
     SM1-class (\_.{accpts}) (tr, p2b'base) ;;

class CommanderOutput (b,(s,p)) =
  let f ldr (a,b') waitfor =
    if b = b'
    then if bag-size waitfor < threshold
         then decision'broadcast reps (s,p)
         else {} (* keep looking for majority *)
    else (* when b <> b', send preempted *)
         { preempted'send ldr b' }
  in
     Once(f o (p2b'base, CommanderState b)) ;;

class Commander bsp = CommanderNotify bsp || CommanderOutput bsp ;;
  \end{lstlisting}
  \caption{Paxos Commander}
  \label{fig:Paxos-Commander}
\end{figure}

A \lstinline{Leader} spawns a \lstinline{Commander} that tries to
elect a particular proposal on a particular ballot.  So we define a
parameterized class
$\listinline{Commander}:\NUPRLarrow{\listinline{PValue}}{\NUPRLclass{\listinline{MSG}}}$.
(\lstinline{Commander}~\bsp) does two things:
\begin{lstlisting}
  class Commander bsp = CommanderNotify bsp || CommanderOutput bsp ;;
\end{lstlisting}
The \lstinline{CommanderNotify} component sends a \lstinline{p2a}
message to all the Acceptors (the locations in \lstinline{accpts}) and
then terminates.  The \lstinline{CommanderOutput} component is a state
machine whose input events are \lstinline{p2b} messages (received in
response to its initial \lstinline{p2a} broadcast).  It will
send \lstinline{decision} messages to all the Replicas or will
send a \lstinline{preempted} message to the Leader the spawned it;
having done either, it terminates.

To define \lstinline{CommanderOutput} we first define the ``post''
Moore machine \lstinline{CommanderState}.  One difference from the
previous case is worth noting: Every \lstinline{AcceptorState}-event
is an \lstinline{Acceptor}-event (i.e., results in a nonempty bag of
directed messages); but there will be
\lstinline{CommanderState}-events that are not
\lstinline{CommanderOutput}-events.

For any $\NUPRL{b}:\listinline{Ballot_Num}$ we define
(\lstinline{CommanderState}~$\NUPRL{b}$) with \lstinline{SM1-class},
since its input events are of just one kind, \lstinline{p2b} messages.
Its state is a bag of locations---the locations of all Acceptors from
which it has not yet received a \lstinline{p2b} message about ballot
number $\NUPRL{b}$.  Thus, it is initially \lstinline{accpts}. 

Consider the definition of (\lstinline{CommanderOutput} \bsp).  The
decision logic in figure~3(a) of~\cite{VanRenesse:2011} is captured in
the locally defined class \lstinline{f o (p2b'base,CommanderState b)}:
It sends a \lstinline{preempted} message if it receives an input with
an acceptance for some ballot number other than \lstinline{b};
broadcasts a \lstinline{decision} message if it has received messages
accepting ballot \lstinline{b} from a majority of the acceptors; and
otherwise makes no output.  Events falling through to the last case
are \lstinline{CommanderState}-events but not
\lstinline{CommanderOutput}-events.  By applying the \lstinline{Once}
combinator to this class (which corresponds to the \emph{exit}
statements in the pseudo-code) we guarantee that there can be at most
one \lstinline{CommanderOutput}-event.

\subsection{Scouts}

\begin{figure}%[!t]
  \begin{lstlisting}[basicstyle=\small]
class ScoutNotify b = Output(\ldr.p1a'broadcast accpts (ldr, b));;

class ScoutState b =
  let tr loc (loc,(b',r : PVlist)) (waitfor,pvalues) =
      if b = b'
      then let waitfor' = bag-remove (op =) waitfor loc in
           let pvalues' = append_news same_pvalue pvalues r in
             (waitfor',pvalues')
      else (waitfor,pvalues) in
   SM1-class (\_.{init_scout}) (tr, p1b'base) ;;

class ScoutOutput b =
  let f ldr (a,(b',r)) (waitfor,pvalues) =
    if b = b'
    then if bag-size waitfor < threshold
         then { adopted'send ldr (b,pvalues) }
         else {}
    else { preempted'send ldr b' }
  in
     Once(f o (p1b'base, ScoutState b));;

class Scout b = ScoutNotify b || ScoutOutput b ;;
  \end{lstlisting}
  \caption{Paxos Scout}
  \label{fig:Paxos-Scout}
\end{figure}

A Leader spawns a Scout to get a particular ballot number adopted (if
possible).  So
$\listinline{Scout}:\NUPRLarrow{\listinline{Ballot_Num}}{\NUPRLclass{\listinline{MSG}}}$.
Its definition is structured identically to that of
\lstinline{Commander}.  It consists of a ``notify'' component that
broadcasts \lstinline{p1a} messages and an ``output'' component that
tallies reponses to them.  It will either send an \lstinline{adopted}
message to all Leaders or send a \lstinline{preempted} message to the
Leader that spawned it.
\begin{lstlisting}
  class Scout b = ScoutNotify b || ScoutOutput b ;;
\end{lstlisting}

Following the previous pattern we first define the ``post'' Moore
machine \lstinline{ScoutState}.  The
(\lstinline{ScoutState}~$\NUPRL{b}$)-events are \lstinline{p1b}
messages.  The ``relevant'' messages, which cause state changes, are
those that concern ballot $\NUPRL{b}$.  The type of its state is
$\NUPRLprod{\NUPRLlist{\listinline{Loc}}}{\listinline{PVlist}}$.  The
first component is the list of all Acceptors from whom it has not yet
received a relevant message; the second is the list of all pvalues it
has received in relevant messages.

In the definition of \lstinline{ScoutOutput} from
\lstinline{ScoutState} the local function \lstinline{f} captures the
decision logic of Figure~3(b) of~\cite{VanRenesse:2011}, and also
described in section~\ref{sec:paxos-voting}.

\subsection{Leaders}

\begin{figure}%[!t]
  \begin{lstlisting}[basicstyle=\small]
let on_propose loc ((s,p) : Proposal) (ballot_num, active, proposals) =
  let proposals' =
    if in_domain (op =) s proposals
    then proposals
    else add_if_new same_proposal (s,p) proposals
  in (ballot_num,active,proposals') ;;

let when_adopted loc (bnum,pvals) (ballot_num, active, proposals) =
  if bnum = ballot_num
  then let proposals' = update_proposals proposals (pmax (pvals : PVlist))
       in (ballot_num, true, proposals')
  else (ballot_num,active,proposals) ;;

let when_preempted ldr bnum (ballot_num, active, proposals) =
  if isl bnum & lt_bnum ballot_num bnum
  then let (r',loc') = outl bnum in (inl (r' + 1,ldr), false, proposals)
  else (ballot_num, active, proposals) ;;

class LeaderState =
  Memory3 (\l.{init_leader l})
          on_propose  propose'base
          when_adopted  adopted'base
          when_preempted  preempted'base;;

class LeaderPropose =
  let f loc (slt, p) (ballot_num, active, proposals) =
    if active & !(in_domain (op =) slt proposals)
    then {(ballot_num,(slt,p))}
    else {} in
    f o (propose'base,LeaderState);;

class LeaderAdopted =
  let f loc _ (bnum, _, props) = (map (\sp. (bnum,sp)) props)/~ in
    f o (adopted'base,LeaderState);;

class LeaderPreempted =
  let f ldr bnum (ballot_num, _, _) =
    if isl bnum & lt_bnum ballot_num bnum
    then {inl(fst(outl bnum) + 1,ldr)}
    else {} in
    f o (preempted'base,LeaderState);;

class SpawnFirstScout = OnLoc(\ldr.Scout(inl(0,ldr)));;

class Leader = SpawnFirstScout
            || ((LeaderPropose || LeaderAdopted) >>= Commander)
            || (LeaderPreempted >>= Scout) ;;
  \end{lstlisting}
  \caption{Paxos Leader}
  \label{fig:Paxos-Leader}
\end{figure}

A \lstinline{Leader} spawns a \lstinline{Scout} and thereafter can
spawn a \lstinline{Commander} in response to a \lstinline{propose} or
\lstinline{adopted} message, or it can spawn a \lstinline{Scout} in
response to a \lstinline{preempted} message:

\newpage
\begin{lstlisting}
    class Leader = SpawnFirstScout
                || ((LeaderPropose || LeaderAdopted) >>= Commander)
                || (LeaderPreempted >>= Scout) ;;
\end{lstlisting}

At any location $\NUPRL{ldr}$, \lstinline{SpawnFirstScout} acts like
the class
$(\listinline{Scout}~\NUPRLinlSYMB(\NUPRLpair{0}{\NUPRL{ldr}}))$.
(Recall that $\NUPRLpair{0}{\NUPRL{ldr}}$ is the least ballot that the
Leader at $\NUPRL{ldr}$ owns.)  To install an appropriate class at
each location we use the primitive \lstinline{OnLoc} introduced in
section~\ref{OnLoc-defined}:
\begin{lstlisting}
        class SpawnFirstScout = OnLoc(\ldr.Scout(inl(0,ldr)));;
\end{lstlisting}

\vspace{1.0ex}
%
The state of a Leader, \lstinline{LeaderState}, is a ``pre'' Moore
machine defined with \lstinline{Memory3}.  The transition functions
corresponding to its three kinds of input messages are
\lstinline{on_propose}, \lstinline{when_adopted}, and
\lstinline{when_preempted}.  The type of its state is
\lstinline{Ballot_Num * Bool * (Proposal List)}.  As noted in
section~\ref{sec:Leaders-Acceptors}, the \lstinline{Bool} component of
a Leader's state indicates whether the current \lstinline{Ballot_Num}
component is active or not; the (\lstinline{Proposal List}) component is
a consistent list of proposals, the proposals that the Leader is
currently working on.

\begin{lstlisting}
class LeaderState =
  Memory3 (\l.{init_leader l})
          on_propose  propose'base
          when_adopted  adopted'base
          when_preempted  preempted'base;;
\end{lstlisting}

We define the Mealy machines \lstinline{LeaderPropose},
\lstinline{LeaderAdopted}, and \lstinline{LeaderPreempted} from
\lstinline{LeaderState}.  Consider the last of these:
\begin{lstlisting}
class LeaderPreempted =
  let f ldr bnum (ballot_num, _, _) =
    if isl bnum & lt_bnum ballot_num bnum
    then {inl(fst(outl bnum) + 1,ldr)}
    else {} in
    f o (preempted'base,LeaderState);;
\end{lstlisting}

By the definition of simple composition every
\lstinline{LeaderPreempted}-event must be both the arrival of a
\lstinline{preempted} message and a \lstinline{LeaderState}-event
(though the converse needn't be true, and in general won't be).  But
every event is a \lstinline{LeaderState}-event.

When applying the local function \lstinline{f},
\begin{itemize}
\item
\lstinline{ldr} matches the location of the Leader at which the
\lstinline{preempted} event occurs;

\item
\lstinline{bnum} matches the ballot number sent in the
\lstinline{preempted} message;

\item
\lstinline{(ballot_num, _, _)} matches the state of the Leader
when the message arrives; so, in particular,
\lstinline{ballot_num} matches the current ballot number.
\end{itemize}
Consider the condition in the conditional expression for
\lstinline{f}.  The conjunct (\lstinline{isl bnum}) is true when
\lstinline{bnum} is not \lstinline{dummy_ballot}.  In fact, an
invariant of the protocol guarantees that this will always be true,
but the test is included so that the declaration will typecheck
statically, without knowing that invariant.\footnote{It's needed so
  that the subterm \lstinline{outl bnum} will typecheck.}  Thus,
execution will take the \lstinline{then} branch (and
\lstinline{LeaderPreempted} will spawn a Scout) iff \lstinline{bnum}
is greater than the ballot number in the Leader's state.

The only important fact about \lstinline{inl(fst(outl bnum) + 1,ldr)},
the ballot number passed to the spawned Scout, is that it belongs to
the Leader at location \lstinline{ldr} and is greater than
\lstinline{bnum}.

\subsection{Replicas}\label{sec:Replicas}

\begin{figure}%[!t]
  \begin{lstlisting}[basicstyle=\small]
let out_tr tr loc x (s,_) = tr x s ;;

(* first_unoccupied ps = least positive integer that is *not* a member of ps *)
let first_unoccupied (ps : Slot_Num List) =
  list_accum (\a.\x. if x = a then a + 1 else a) 1 (quicksort-int ps)
;;

let propose p (rs, sn, prs, dcs)  =
  if in_range (op =) p dcs
  then ((rs, sn, prs, dcs), {})
  else let s' = first_unoccupied (domain (prs ++ dcs)) in
       let prs' = add_if_new (op =) prs (s',p) in
       let msgs = propose'broadcast ldrs (s',p) in
         ((rs, sn, prs', dcs), msgs) ;;

let perform (cmd : Command) ((rstate, slot_num, proposals, decisions) : ReplicaState) =
  let (client,cid,ope) = cmd in
    if bl-exists decisions (\ (s,c) . s < slot_num & c = cmd)
    then ((rstate,slot_num + 1,proposals,decisions),{})
    else let (next, result) = apply_op ope rstate in
         let new_state = (next, slot_num + 1, proposals, decisions) in
           (new_state, {response'send client (cid,result)})
;;

let inner_tr p' state =  (* applied when (n,p') \in decided *)
  let (rstate, slot_num, proposals, decisions) = state in
  let to_repropose = mapfilter snd (\ (m,p'') . m = slot_num & !(p'' = p')) proposals in
  let (new_state, proposes) = iterate_tr propose state to_repropose in
  let (new_state', responses) = perform p' new_state in
    (new_state', bag-append proposes responses) ;;

(* Each iteration of inner_tr performs one operation and also finds
 * all elements of proposals sharing the slot number of the operation
 * performed and reproposes them.  It does the reproposing first *)

let replica_decision v ((rstate, slot_num, proposals, decisions) : ReplicaState) =
  let decisions' = add_if_new (op =) decisions v in
  let ready = mapfilter snd (\ (s,_) . s = slot_num) decisions' in
    iterate_tr inner_tr (rstate, slot_num, proposals, decisions') ready ;;

class ReplicaAux =
  SM2-class (\_.{(init_replica,{})})
               (out_tr propose,          request'base)
               (out_tr replica_decision, decision'base) ;;

class Replica = (\_.snd) o ReplicaAux ;;
  \end{lstlisting}
  \caption{Paxos Replica}
  \label{fig:Paxos-Replica}
\end{figure}

In order to define a class that is a state machine, we have repeatedly
used the strategy of defining a Mealy machine from a Moore machine.
We do that again, but in a way that may seem backwards.
\lstinline{ReplicaAux} is a Moore machine whose internal state has
type
%
\lstinline{ReplicaState * Message Bag}.  \lstinline{Replica} is the
projection of this onto the second component, returning only the
messages:
\begin{lstlisting}
  class Replica = (\_.snd) o ReplicaAux ;;
\end{lstlisting}

To derive a Mealy machine from a Moore machine we must be able to
compute the outputs from the input and the (resulting) state.
Consider how a Replica acts.  In response to an input it may take a
sequence of steps, each of which changes the internal state of the
Replica (by executing a command and by updating bookkeeping
information) and sends a message.  The pseudo-code
of~\cite{VanRenesse:2011} carries that out in a loop.  A
\lstinline{Replica} event class must respond to an input by making a
transition to the final state (at the end of the loop) and returning a
bag that contains all the messages produced by that entire sequence of
steps.  We cannot compute that bag of messages just from the input
value and the final state---at least, we cannot do so if the final
state is simply a value of type \lstinline{ReplicaState}.  That is why
the state type of \lstinline{ReplicaAux} is
%
\lstinline{ReplicaState * Message Bag}.

We use \lstinline{SM2-class} to factor the definition of
\lstinline{ReplicaAux} in terms of its response to \lstinline{propose}
messages and to \lstinline{decision} messages.

The auxiliary function \lstinline{out_tr} lifts a transition function
$\NUPRL{tr}$ for a Mealy machine with inputs $A$, outputs
\lstinline{Msgs}, and internal state \lstinline{ReplicaState}
\[
\NUPRL{tr}: \NUPRLarrow{I}
    {\NUPRLarrow{\listinline{ReplicaState}}
                {\NUPRLprod{\listinline{ReplicaState}}
                           {\NUPRLbag{\listinline{Msgs}}}}}
\]
to an equivalent transition function $\listinline{out_tr}~\NUPRL{tr}$
for a Moore machine with inputs $I$ and internal state
$\NUPRLprod{\listinline{ReplicaState}}
{\NUPRLbag{\listinline{Msgs}}}$:
\[
\listinline{out_tr}~\NUPRL{tr} :
\NUPRLarrow{\listinline{Loc}}
{\NUPRLarrow{I}
    {\NUPRLarrow{\NUPRLprod{\listinline{ReplicaState}}
                           {\NUPRLbag{\listinline{Msgs}}}}
                {\NUPRLprod{\listinline{ReplicaState}}
                           {\NUPRLbag{\listinline{Msgs}}}}}}
\]
The initial argument of type \lstinline{Loc} is ignored.  It's
included so that $\listinline{out_tr}~\NUPRL{tr}$ will have the type
required of an argument to \lstinline{SM2-class}.

The operation
\[
\listinline{propose} :
   \NUPRLarrow{\listinline{Proposal}}
              {\NUPRLarrow{\listinline{ReplicaState}}
                          {\NUPRLprod{\listinline{ReplicaState}}
                                     {\NUPRLbag{\listinline{Msgs}}}}}
\]
encodes the \emph{propose} operation of~\cite{VanRenesse:2011}, which
a Replica performs in response to a \lstinline{propose} message.  Thus
(\lstinline{out_tr propose}) lifts this to a transition function for
\lstinline{ReplicaAux}.  (Note: \lstinline{propose} invokes
\lstinline{first_unoccupied}, which finds the first empty slot in a
list of proposals by a logically correct, but woefully inefficient
procedure; it begins by sorting its input.  There's no point in
defining a more efficient one, because a real implementation would
implement \lstinline{propose} differently, to avoid accumulating an
unbounded list of proposals in the state of the Replica.)

The operation
\[
\listinline{perform} :
   \NUPRLarrow{\listinline{Command}}
              {\NUPRLarrow{\listinline{ReplicaState}}
                          {\NUPRLprod{\listinline{ReplicaState}}
                                     {\NUPRLbag{\listinline{Msgs}}}}}
\]
encodes the \emph{perform} operation of~\cite{VanRenesse:2011}.  In response to a
\lstinline{decision} message a Replica may invoke this repeatedly in a
loop: \lstinline{inner_tr} does one iteration of the loop;
(\lstinline{iterate_tr inner_tr}) executes the loop, accumulating all
the messages to be sent; and \lstinline{replica_decision} encodes the
entire response.  Thus (\lstinline{out_tr replica_decision}) lifts
this to the other transition function for \lstinline{ReplicaAux}.

\begin{lstlisting}
  class ReplicaAux =
    SM2-class (\_.{(init_replica,{})})
                 (out_tr propose,          request'base)
                 (out_tr replica_decision, decision'base) ;;
\end{lstlisting}

\begin{figure}%[!t]
  \begin{lstlisting}[basicstyle=\small]
main Leader @ ldrs || Acceptor @ accpts
  \end{lstlisting}
  \caption{Paxos main program}
  \label{fig:Paxos-main-program}
\end{figure}

\section{Definitions of combinators}
\label{sec:combinators}

\intitle{General simple composition}

Section~\ref{sec:ping-pong} introduces the simple composition
combinator.
Given $n$ classes $\NUPRL{X_1}$, \dots,
$\NUPRL{X_n}$, of types $\NUPRL{T_1}$, \dots, $\NUPRL{T_n}$
respectively, and given a function $\NUPRL{F}$ of type
%
$\NUPRLarrow
{\NUPRLloc}
{\NUPRLarrow
  {\NUPRL{T_1}}
  {\NUPRLarrow
    {\cdots}
    {\NUPRLarrow
      {\NUPRL{T_n}}
      {\NUPRLbag{\NUPRL{T}}}
    }
  }
}$,
%
one can define the class
$\NUPRLsimplecombn{\NUPRL{F}}{\NUPRL{X_1}}{\NUPRL{X_n}}$.
%
This combinator is defined in terms of one of the \logicE' primitive
combinators.
%
Given $n$ classes $\NUPRL{X_1}$, \dots,
$\NUPRL{X_n}$, of types $\NUPRL{T_1}$, \dots, $\NUPRL{T_n}$
respectively, and given a function $\NUPRL{F}$ of type
%
$\NUPRLarrow
{\NUPRLloc}
{\NUPRLarrow
  {\NUPRLbag{\NUPRL{T_1}}}
  {\NUPRLarrow
    {\cdots}
    {\NUPRLarrow
      {\NUPRLbag{\NUPRL{T_n}}}
      {\NUPRLbag{\NUPRL{T}}}
    }
  }
}$,
%
the class
$\NUPRLgensimplecombn{\NUPRL{F}}{\NUPRL{X_1}}{\NUPRL{X_n}}$
is one of the \logicE' primitive combinator.
%
The class $\NUPRLsimplecombn{\NUPRL{F}}{\NUPRL{X_1}}{\NUPRL{X_n}}$
is defined as:
$$\NUPRLgensimplecombn
{(\NUPRLlam
  {\NUPRL{loc}}
  {\NUPRLlamn
    {\NUPRL{b_1}}
    {\NUPRL{b_n}}
    {\NUPRLbagcombinen
      {\NUPRL{b_1}}
      {\NUPRL{x_1}}
      {\NUPRL{b_n}}
      {\NUPRL{x_n}}
      {\NUPRLappn
        {\NUPRLapp{\NUPRL{F}}{\NUPRL{loc}}}
        {\NUPRL{x_1}}
        {\NUPRL{x_n}}
      }
    }
  })
}
{\NUPRL{X_1}}
{\NUPRL{X_n}}$$

\intitle{Until}

The binary infix operator \lstinline{until} can then be defined in
terms of this more general simple composition combinator as follows:
\begin{emlcode}
\begin{lstlisting}
import bag-null;;

class until X Y =
  let F loc b1 b2 = if bag-null b2 then b1 else {}
  in F o (X,Prior(Y)) ;;

infix until;;
\end{lstlisting}
\end{emlcode}
The \lstinline{bag-null} function is a function that returns true iff
its argument is the empty bag.
%
Note that using an \lstinline{infix} declaration, one can declare infix
operators in \eml.

\intitle{Once}

The \lstinline{Once} operator can be defined in terms of the
\lstinline{until} operator as follows:
\begin{emlcode}
\begin{lstlisting}
class Once X = (X until X) ;;
\end{lstlisting}
\end{emlcode}

\intitle{Output}

The \lstinline{Output} operator can be defined in terms of the
\lstinline{Once} operator as follows:
\begin{emlcode}
\begin{lstlisting}
class Output b = Once(b o ());;
\end{lstlisting}
\end{emlcode}


\intitle{The ``at'' combinator}

The binary infix operator \lstinline{@} can be defined in terms of the
simple combinator as follows:
\begin{emlcode}
\begin{lstlisting}
import bag-deq-member ;;
class @ X locs =
  let F loc x = if bag-deq-member (op =) loc locs then {x} else {}
  in F o X ;;
infix @ ;;
\end{lstlisting}
\end{emlcode}
(Note that this code is not valid \eml\ code because \lstinline{@} is
not a valid identifier.)


\intitle{Parallel combination}

The parallel combinator can be defined in terms of the more general
simple combinator as follows:
\begin{emlcode}
\begin{lstlisting}
class || X Y = (\loc.\b1.\b2.b1++b2) o (X,Y) ;;
infix || ;;
\end{lstlisting}
\end{emlcode}
(Note that this code is not valid \eml\ code because \lstinline{||} is
not a valid identifier.)

\intitle{Disjoint union}

The \emph{disjoint union}%
%
\index{class combinators!disjoint union}%
%
class combinator.
%
\lstinline{X (+) Y} is a class of type \lstinline{A + B} that
recognizes both \lstinline{X}-events and \lstinline{Y}-events.  The
observations made by \lstinline{X} are tagged with \lstinline{inl} and
the observations made by \lstinline{Y} are tagged with \lstinline{inr}:
\begin{emlcode}
\begin{lstlisting}
  class X (+) Y = ((\_.\x.{inl(x)}) o X) || ((\_.\x.{inr(x)}) o Y) ;;
\end{lstlisting}
\end{emlcode}
If (and only if) $\NUPRLevent$ is both an \lstinline{X}-event and a
\lstinline{Y}-event, \lstinline{X (+) Y}$(\NUPRLevent)$ is a bag with
two elements.

\intitle{SM1-class, \ldots, Memory1, \ldots}

For any $n$, the combinators \lstinline{SM}$n$\lstinline{class} and
\lstinline{Memory}$n$ are defined in section~\ref{sec:state-machine}.

%\clearpage

\section{Configuration files}
\label{sec:configuration}

Parameters to our specifications are of two kinds.  Some are
``abstract''---e.g., the integer parameters \lstinline{threshold} (see
section~\ref{sec:ping-pong-mem}) and \lstinline{flrs} (see
section~\ref{sec:simple-consensus}).  We can instantiate these by
providing a \nuprl\ term of type integer.  Others are ``real
world''---e.g., the parameter \lstinline{client} of type location.
Their meanings are specific to a particular installation of \eml: the
messaging system determines what must be supplied to instantiate a
location parameter.  Our prototype assumes that messaging is by
TCP/IP, and a location is a pair consisting of an IP address and a
port.\footnote{Note that TCP/IP provides stronger guarantees---namely,
  FIFO delivery---than our examples have assumed.}

The parameter declarations
\begin{lstlisting}
    parameter nodes  : Loc Bag ;;
    parameter client : Loc ;;
    parameter uid    : Loc -> Int ;;
\end{lstlisting}
illustrate the open-ended nature of real world parameters.

Suppose that we supply an (IP address,~port) pair for
\lstinline{client} and a list of such pairs for
\lstinline{nodes}.\footnote{Computationally, a bag is just a list in
  which we ignore the order.}  How do we instantiate \lstinline{uid}?
Knowing the locations, we could simply define a function that assigns
integers to them.  If we wanted a more flexible implementation, we
might want to base \lstinline{uid} on the MAC address of a node's
network card; in that case the configuration file would provide some
reference to a piece of code that does the computation.  For now, the
only primitive real-world type that we allow is \lstinline{Loc}.  All
other parameter types must be intepretable from \lstinline{Loc} and
abstract types.

Here is what a configuration file looks like:
\begin{emlcode}
\begin{lstlisting}
%locations
 n1: 192.168.0.12 19777
 n2: 192.168.0.13 19778
 n3: 192.168.0.14 19779

%parameters
 nodes:  {LOC(n1);LOC(n2);LOC(n3)}
 client: LOC(client)
 uid:    \l.if l = LOC(n1) then 1 else if l = LOC(n2) then 2 else 3

%messages
 n1: (``config``, Int * Loc, (1, LOC(n2)))
 n2: (``config``, Int * Loc, (1, LOC(n3)))
 n3: (``config``, Int * Loc, (1, LOC(n1)))
 n2: (``choose``, Int, 1)
\end{lstlisting}
\end{emlcode}
This is an example of a configuration file for the leader election in
a ring protocol presented in section~\ref{sec:leader-ring}.  A
configuration file is divided into three parts: the
\lstinline{locations} part declares the machines on which one wishes
to install the specified protocol (\lstinline{n1} is a location name
which is specified by the IP address \lstinline{192.168.0.12} and the
port number \lstinline{1977}); the \lstinline{parameters} part
instantiates the parameters declared in the given specification (the
leader election in a ring specification presented in
section~\ref{sec:leader-ring} declares three parameters:
\lstinline{nodes}, \lstinline{client}, and \lstinline{uid}); the
\lstinline{messages} part declares a bag of messages initially in
transit.  One has to declare at least one message in transit because
\eml\ allows on to define reactive agents that can only react on
receipt of messages.  Therefore nothing happens as long as no message
is received.


\section{\eml's syntax}

\begin{figure}[t]
\begin{small}
\begin{center}
  \begin{tabular}{lllrl}
    $\METAnatnum$
    & $\in$
    & $\SETnatnum$
    &
    & (natural numbers)
    \\

    %% $\METAvid$
    %% & $\in$
    %% & $\SETvid$
    %% &
    %% & (infinite countable set of value identifiers)
    %% \\

    %% $\METAtyvar$
    %% & $\in$
    %% & $\SETtyvar$
    %% &
    %% & (infinite countable set of type variables)
    %% \\

    %% $\METAcharseq$
    %% & $\in$
    %% & $\SETcharseq$
    %% &
    %% & (set of character sequences)
    %% \\

    $\METAtycon$
    & $\in$
    & $\SETtycon$
    & $::=$
    & $\CONSintty
    \mid\CONSlistty
    \mid\CONSboolty
    \mid\CONSunitty
    \mid\CONSbagty
    \mid\CONSclassty
    \mid\CONSmsgty
    \mid\CONSlocty
    \mid\CONSatomty$
    \\

    $\METAinftycon$
    & $\in$
    & $\SETinftycon$
    & $::=$
    & $\CONStuptySYMB\mid\CONSarrowtySYMB\mid\CONSdisjutySYMB$
    \\

    $\METAbool$
    & $\in$
    & $\SETbool$
    & $=$
    & $\CONStrue\mid\CONSfalse$
    \\

    $\METAop$
    & $\in$
    & $\SETop$
    & $::=$
    & $\CONSopplus
    \mid\CONSopminus
    \mid\CONSopmult
    \mid\CONSopdiv
    \mid\CONSopequal
    \mid\CONSoplistcons
    \mid\CONSoplistappend
    \mid\CONSoplt
    \mid\CONSopgt
    \mid\CONSopor
    \mid\CONSopand
    \mid\CONSmonbindSYMB
    \mid\CONSparallelSYMB
    \mid\CONSopatclass$
    \\

    $\METAatexp$
    & $\in$
    & $\SETatexp$
    & $::=$
    & $\METAvid
    \mid\METAnatnum
    \mid\METAbool
    \mid\CONSminus{\METAatexp}
    \mid\CONSinl{\METAexp}
    \mid\CONSinr{\METAexp}$\\
    &&& $\mid$
    & $\CONStupn{\METAexp_1}{\METAexp_n}$\\
    &&& $\mid$
    & $\CONSbagn{\METAexp_1}{\METAexp_n}$\\
    &&& $\mid$
    & $\CONSprior{\METAexp}$\\
    &&& $\mid$
    & $\CONSonce{\METAexp}$\\
    &&& $\mid$
    & $\CONSoutput{\METAexp}$\\
    &&& $\mid$
    & $\CONSonloc{\METAexp}$\\
    &&& $\mid$
    & $\CONSparen{\METAexp}$
    \\

    $\METAexp$
    & $\in$
    & $\SETexp$
    & $::=$
    & $\METAatexp$\\
    &&& $\mid$
    & $\CONSquotient{\METAatexp}$\\
    &&& $\mid$
    & $\CONSreccombinitopn{\METAexp}{\METAexp_1}{\METAexp_n}{\METAexp'}$\\
    &&& $\mid$
    & $\CONSopexp{\METAexp_1}{\METAop}{\METAexp_2}$\\
    &&& $\mid$
    & $\CONStypexp{\METAexp}{\METAty}$\\
    &&& $\mid$
    & $\CONSappexp{\METAexp}{\METAatexp}$\\
    &&& $\mid$
    & $\CONSlamexp{\METApat}{\METAexp}$\\
    &&& $\mid$
    & $\CONSiteexp{\METAexp_1}{\METAexp_2}{\METAexp_3}$\\
    &&& $\mid$
    & $\CONSlet{\METAbind}{\METAexp}$\\
    &&& $\mid$
    & $\CONSletrec{\METAbind}{\METAexp}$\\
    &&& $\mid$
    & $\CONSclass{\METAbind}{\METAexp}$\\
    &&& $\mid$
    & $\CONSwhere{\METAatexp}{\METAbind}$
    \\

%% + case

    $\METApat$
    & $\in$
    & $\SETpat$
    & $::=$
    & $\METAvid$\\
    &&& $\mid$
    & $\CONSwild$\\
    &&& $\mid$
    & $\CONStupn{\METApat_1}{\METApat_n}$\\
    &&& $\mid$
    & $\CONStyppat{\METApat}{\METAty}$
    \\

    $\METAtypseq$
    & $\in$
    & $\SETtypseq$
    & $::=$
    & $\CONSvoid$\\
    &&& $\mid$
    & $\METAty$\\
    &&& $\mid$
    & $(\METAty_0,\dots,\METAty_n)$
    \\

    $\METAty$
    & $\in$
    & $\SETty$
    & $::=$
    & $\METAtyvar$\\
    &&& $\mid$
    & $\CONSconsty{\METAtypseq}{\METAtycon}$\\
    &&& $\mid$
    & $\CONSinfconsty{\METAty_1}{\METAty_2}{\METAinftycon}$\\\
    &&& $\mid$
    & $(\METAty)$
  \end{tabular}
\end{center}
\caption{\eml\ syntax -- expression}
\label{fig:emlsyntax1}
\end{small}
\end{figure}

\begin{figure}[t]
\begin{small}
\begin{center}
  \begin{tabular}{lllrl}
    $\METAatom$
    & $\in$
    & $\SETatom$
    & $::=$
    & $\CONSatom{\METAcharseq}$
    \\

    $\METAatoms$
    & $\in$
    & $\SETatoms$
    & $::=$
    & $\CONSlistn{\METAatom_0}{\METAatom_n}$
    \\

    $\METAhdrstatus$
    & $\in$
    & $\SEThdrstatus$
    & $::=$
    & $\CONShdrinternal$\\
    &&& $\mid$
    & $\CONShdrinput$\\
    &&& $\mid$
    & $\CONShdroutput$
    \\

    $\METAhdropt$
    & $\in$
    & $\SEThdropt$
    & $::=$
    & $\CONSbasehdropt{\METAvid}$\\
    &&& $\mid$
    & $\CONSsendhdropt{\METAvid}$\\
    &&& $\mid$
    & $\CONSbroadcasthdropt{\METAvid}$
    \\

    $\METAhdropts$
    & $\in$
    & $\SEThdropts$
    & $::=$
    & $\METAhdropt\CONSop{\CONScomma\METAhdropts}$
    \\

    $\METAheader$
    & $\in$
    & $\SETheader$
    & $::=$
    & $\CONShdrgen{\METAhdrstatus}{\METAatoms}{\METAty}{\METAhdropts}$
    \\

    $\METAbind$
    & $\in$
    & $\SETbind$
    & $::=$
    & $\CONSbindapp{\METAvid}{\CONSparamn{\METAatpat_1}{\METAatpat_n}}{\METAexp}$
    \\

    $\METAdec$
    & $\in$
    & $\SETdec$
    & $::=$
    & $\CONSletdec{\METAbind}$\\
    &&& $\mid$
    & $\CONSletrecdec{\METAbind}$\\
    &&& $\mid$
    & $\CONSclassdec{\METAbind}$\\
    &&& $\mid$
    & $\CONSparameter{\METAvid}{\METAty}$\\
    &&& $\mid$
    & $\CONSimportn{\METAvid_0}{\METAvid_n}$\\
    &&& $\mid$
    & $\CONSmsgsdecn{\METAheader_0}{\METAheader_n}$\\
    &&& $\mid$
    & $\CONSmaindec{\METAexp}$\\
    &&& $\mid$
    & $\CONSspecdec{\METAvid}$
    \\

%% + type declarations

    $\METAprog$
    & $\in$
    & $\SETprog$
    & $::=$
    & $\CONSprog{\METAdec}{\METAprog}$
  \end{tabular}
\end{center}
\caption{\eml\ syntax -- declarations}
\label{fig:emlsyntax2}
\end{small}
\end{figure}


\intitle{Identifiers}

An identifier can either be \emph{alphanumeric} or \emph{symbolic}.
An alphanumeric identifier is a sequence of letters, digits, primes
(quotes), dashes and underscores starting with a letter.  For example,
\lstinline{bag_map}, \lstinline{bag-map}, \lstinline{bag-map'}, and
\lstinline{bag-map1} are identifiers, but \lstinline{1bag-map} is not.
A symbolic identifier is a sequence of the following symbols:
\lstinline{!}, \lstinline{%},
\lstinline{&}, \lstinline{#}, \lstinline{/}, \lstinline{<},
\lstinline{=}, \lstinline{?}, \lstinline{\}, \lstinline{~},
\lstinline{^}, \lstinline{|}, \lstinline{>}, \lstinline{-},
\lstinline{:}, \lstinline{+}, \lstinline{@}, \lstinline{*}.
Some alphanumerics as well as some symbolic identifiers are disallowed
because they are reserved keywords.  They are described in
Figures~\ref{fig:emlsyntax1} and~\ref{fig:emlsyntax2} bellow.
%% They symbolic keywords are as follows:
%% \lstinline{++} (list concatenation); \lstinline{>=}, \lstinline{>},
%% \lstinline{<}, \lstinline{<=} (comparator on integers); \lstinline{+},
%% \lstinline{-}, \lstinline{~}, \lstinline{/}, \lstinline{*} (operations
%% on integers);  \lstinline{?} (class combinator); \lstinline{>>=}
%% (delegation); \lstinline{||} (parallel composition)

Let $\SETvid$ be the set of identifiers and let $\METAvid$ range over
identifiers.


\intitle{Type variables}

A type variable is an alphanumeric identifier preceded by primes
(quotes).  For example, \lstinline{'a} and \lstinline{''a} are type
variables

Let $\SETtyvar$ be the set of type variable and let $\METAtyvar$ range
over type variables.


\intitle{Character sequences}

Let $\SETcharseq$ be the set of sequences of characters other than
backquotes ($\char18$) and let $\METAcharseq$ range over
$\SETcharseq$.

\intitle{Other syntactic forms}

Figures~\ref{fig:emlsyntax1} and~\ref{fig:emlsyntax2} defines \eml's syntax.
%
In this figure we write $\CONSop{x}$ to indicate that $x$ is optional.
These brackets are not part of \eml's syntax.  For example, a program
$\METAprog$ can either be a declaration followed by two semicolons, or
a declaration followed by two semicolons followed by another program
(it allows us to define recursive production rules).

We also impose the following syntactic restrictions:
\begin{itemize}
\item In a program, a declaration of the form $\CONSspecdec{\METAvid}$
  has to be the first declaration and there can only be one.
\item In a program, a declaration of the form $\CONSmaindec{\METAexp}$
  has to be the last declaration and there can only be one.
\item In an expression of the form
  $\CONSletrec{\METAbind}{\METAexp'}$, where $\METAbind$ is of the
  form
  $\CONSbindapp{\METAvid}{\CONSparamn{\METAatpat_1}{\METAatpat_n}}{\METAexp}$,
  either $n>=1$ or $\METAexp$ is a lambda expression the form
  $\CONSlamexp{\METApat}{\METAexp''}$ (i.e., a recursive declaration
  can only bind a function).
\item In a declaration of the form $\CONSletrecdec{\METAbind}$, where
  $\METAbind$ is of the form
  $\CONSbindapp{\METAvid}{\CONSparamn{\METAatpat_1}{\METAatpat_n}}{\METAexp}$,
  either $n>=1$ or $\METAexp$ is a lambda expression (i.e., of the
  form $\CONSlamexp{\METApat}{\METAexp'}$).
\end{itemize}

%% ***  INCLUDE A BNF for \eml


\bibliography{../../tex/biblio}

\printindex


\end{document}

%%% This is not how we define the disjoint union class combinator but
%%% this definition is nicer.

%% \subsection{\lstinline{Threshold-Combinator}.}

%% \lstinline{Threshold-Combinator}%
%% %
%% \index{class combinators!Threshold combinator}%
%% %
%% provides a way to define a Mealy machine directly.  The setting: we're
%% given an event class \lstinline{X} of type \lstinline{A} that
%% recognizes input events and want to define a state machine that
%% maintains an internal state of some type \lstinline{S} and, computes
%% outputs of type \lstinline{B} based on the inputs and its current
%% state.

%% So we will have to supply an output function in addition to a state
%% transition function.  We do not supply those directly as inputs to
%% \lstinline{Threshold-Combinator}; rather, we supply inputs from which
%% they can be determined in a slightly indirect way:
%% \begin{emlcode}
%% \begin{lstlisting}
%% class Threshold-Combinator R X init_state accum f =
%%   let state_function v state =
%%      if R v state then accum v state else state in
%%   let output_function loc v state =
%%      if R v state then f loc v state else {} in
%%   let CurrentState = Accum-class state_function init_state X in
%%   let PriorState = Prior(CurrentState)?init_state in
%%     output_function o (X,PriorState)
%% \end{lstlisting}
%% \end{emlcode}

%% The locally defined operations have the following meanings:
%% \begin{itemize}
%% \item
%% \lstinline{CurrentState} is a state machine that accumulates, and
%% allows us to observe, its state: \lstinline{X} recognizes inputs;
%% \lstinline{init_state} defines initial states; and the transition
%% function \lstinline{state_function} is a \emph{variant} of the
%% parameter \lstinline{accum}.
%% \item
%% \lstinline{PriorState}, according to our
%% standard idiom, remembers the most recent value of
%% \lstinline{CurrentState}.
%% \item
%% \lstinline{output_function}, a
%% \emph{variant} of the parameter \lstinline{f}, computes an output from
%% the input and the value of \lstinline{PriorState}.
%% \end{itemize}

%% To understand the meanings of \lstinline{state_function} and
%% \lstinline{output_function}, note the expected types of the
%% parameters:
%% \begin{itemize}
%% \item \lstinline{R : A -> S -> Bool}
%% \item \lstinline{accum: A -> S -> S}
%% \item \lstinline{f: Id -> A -> S -> B Bag}
%% \end{itemize}

%% \lstinline{R} is a decidable relation between input values and
%% values of the state used to filter inputs.  When input \lstinline{v}
%% arrives in state \lstinline{s}, then: if \lstinline{R} holds, the
%% state transition and output are given by \lstinline{accum} and
%% \lstinline{f}; otherwise, there is no state change and no output.


%% \subsection{No repeat requests}


%% \begin{figure}[!t]
%%   \begin{lstlisting}[basicstyle=\small]
%% specification norep

%% (* ------ Parameters ------ *)
%% parameter ldr    : Loc;;
%% parameter store1 : Loc;;
%% parameter store2 : Loc;;

%% (* ------  Messages  ------ *)
%% input    (``nr req``      : Int * Loc, base Req)
%% internal (``nr handle``   : Int, base Handle, broadcast handle)
%% internal (``nr ok``       : Int, base Ok, send ok)
%% output   (``nr accepted`` : Int, send sendAcc)

%% (* ------ Imported constants ------ *)
%% import Threshold-Combinator deq-member ;;

%% (* ------ The Stores ------ *)
%% let isOk @ (n:Int) l = {ok ldr n};;
%% let not_member (n : Int) l = !(deq-member (op =) n l);;
%% class Store = Threshold-Combinator not_member Handle (\_.{[]}) (op .) isOk;;

%% (* ------ Handler for n ------ *)
%% let okfor (n:Int) @ m = if m = n then {n} else {};;
%% class OkFor n = (okfor n)|Ok|;;
%% let accept client @ n _ = {sendAcc client n};;
%% class Handler (n,client) =
%%      Output(\_.handle {store1;store2} n)
%%   || Once((accept client)|OkFor n; Prior(OkFor n)|);;

%% (* ------- The Leader ------- *)
%% class Leader = Req >>= Handler;;

%% (* ------- Protocol ------ *)
%% main Leader @ {ldr} || Store @ {store1;store2} ;;
%%   \end{lstlisting}
%%   \caption{No repeat requests}
%%   \label{fig:no-repeat-requests}
%% \end{figure}

%% This section presents a simple protocol called \emph{no repeat
%%   requests}.  Fig.~\ref{fig:no-repeat-requests} presents the full
%% protocol.  Here is the situation: A leader, at location
%% \lstinline{ldr}, receives requests from clients and notifies a client
%% if its request has been \emph{accepted}.  Each request is an integer;
%% the leader may not accept any request more than once.  In addition,
%% the requests received are stored in two locations--\lstinline{store1}
%% and \lstinline{store2})--and the leader will not accept a request
%% until it knows that both locations have stored it.

%% This protocol uses four kinds of messages:
%% \begin{emlcode}
%% \begin{lstlisting}
%% input    (``nr req``      : Int * Loc, base Req)
%% internal (``nr handle``   : Int, base Handle, broadcast handle)
%% internal (``nr ok``       : Int, base Ok, send : ok)
%% output   (``nr accepted`` : Int, send sendAcc)
%% \end{lstlisting}
%% \end{emlcode}

%% *** START HERE: THERE'S SOMETHING WRONG WITH THIS ***

%% It proceeds as follows:
%% \begin{enumerate}
%% \item
%% A \lstinline{Leader} request $\NUPRL{n}$ from client $\NUPRL{l}$, and
%% spawns \lstinlin{Handler}~$\NUPRL{(n,l)}$ to process it.

%% \item
%% \lstinlin{Handler}~$\NUPRL{(n,l)}$ sends
%% $(\CONSatoms{handle},\NUPRL{n})$ to both stores waits for their
%% replies.

%% \item
%% Class \lstinline{Store} is a state machine that reacts to
%% $(\CONSatoms{handle},\NUPRL{n})$: its state is a list of all the request
%% numbers it has seen; if
%% \end{enumerate}


%% Requests are messages with header \lstinline{nr req}.  A request
%% message contains a request number (an integer) and the client
%% location.  This location is used to send back a notification to the
%% client when necessary (i.e., if the request is accepted).
%% %
%% The leader sends \lstinline{nr handle} messages to the stores to
%% check whether requests have already been accepted in the past.  We saw
%% above that one can declare, in a message declaration, a function to
%% send a specific kind of message to a single location using the
%% \lstinline{send} keyword.  A function defined using the
%% \lstinline{broadcast} keyword is similar but allows one to send a
%% message to multiple locations (a location bag) instead of a single
%% one.
%% %
%% A \lstinline{nr ok} is sent by a store when it has received a
%% request (in a \lstinline{nr handle} message) that is not already in
%% the store.
%% %
%% Finally, a \lstinline{nr accepted} message is sent by the leader to
%% a client if the client has sent a request that has not been sent
%% before.

%% \intitle{A store}.

%% A store is specified by the class \lstinline{Store}.  It makes use of
%% \emph{Threshold-Combinator} (see Section~\ref{sec:state-machine}) which
%% maintains an internal state that is updated when
%% %
%% \lstinline{nr handle} messages are received.
%% %
%% We use \lstinline{Threshold-Combinator} as follows:
%% \begin{emlcode}
%% \begin{lstlisting}
%% class Store =
%%   Threshold-Combinator not_member Handle (\_.{[]}) (op .) isOk;;
%% \end{lstlisting}
%% \end{emlcode}
%% It maintains a state which is a list of integers (request numbers).  The
%% initial state is the empty list (given by the function
%% \lstinline!(\_.{[]})!).  Inputs to this class are \lstinline{nr
%%   handle} messages (observed by the class \lstinline{Handle}).  The
%% \lstinline{not_member} function specifies that we filter out the
%% requests that are already in the state.  Therefore, the state is only
%% updated when receiving a \lstinline{nr handle} message containing a
%% request that is not already in the state.  If such a message arrive we
%% use the list constructor (\lstinline{(op .)}) to update the state,
%% i.e., given a new request \lstinline{n} that is not in the current
%% state, and given the current state \lstinline{l}, then the new state
%% is the list \lstinline{n . l}.  The \lstinline{isOk} function
%% specifies when the threshold is crossed and what to do when that
%% happens.  Here the threshold is crossed each time a new request is
%% received (as specified by \lstinline{not_member}).  Therefore,
%% \lstinline{isOk} is only responsible for outputting information.  Each
%% time a request, that has not been received before, is received,
%% \lstinline{isOk} sends a \lstinline{nr ok} message to the leader.

%% \intitle{A request handler}.

%% As it is often the case in \eml\ a handler for request \lstinline{n}
%% (\lstinline{Handler (n,client)}) sends messages and then waits for
%% replies before doing some action.  More precisely, a request handler
%% for request \lstinline{n} starts by forwarding the request to the
%% two stores:
%% \begin{emlcode}
%% \begin{lstlisting}
%% Output(\_.handle {store1;store2} n)
%% \end{lstlisting}
%% \end{emlcode}
%% Note that if we unfold \lstinline{handle}, this becomes:
%% \begin{emlcode}
%% \begin{lstlisting}
%% Output(\_.{(store1,n);(store2,n)})
%% \end{lstlisting}
%% \end{emlcode}

%% It then waits for two \lstinline{nr ok} messages.  This is achieved
%% by:
%% \begin{emlcode}
%% \begin{lstlisting}
%% Once((accept client)|OkFor n; Prior(OkFor n)|)
%% \end{lstlisting}
%% \end{emlcode}
%% First of all, the class \lstinline{OkFor n} observes the request
%% number \lstinline{n} contained in incoming \lstinline{ok} messages:
%% \begin{emlcode}
%% \begin{lstlisting}
%% let okfor (n:Int) @ m = if m = n then {n} else {};;
%% class OkFor n = (okfor n)|Ok|;;
%% \end{lstlisting}
%% \end{emlcode}
%% If we observe such a request number, it means that it has been sent by
%% one of the two stores.  The class \lstinline{Prior(OkFor n)} observes
%% the request number \lstinline{n} contained in a \lstinline{ok}
%% message received in the past.
%% %
%% Therefore, if we receive a \lstinline{ok} message that contains
%% \lstinline{n} (i.e., \lstinline{OkFor n} observes \lstinline{n}) and
%% we have already received in the past a \lstinline{ok} message that
%% contains \lstinline{n} (i.e., \lstinline{Prior(OkFor n)} observes
%% \lstinline{n}) then it means that both the stores accepted
%% \lstinline{n}, because a store cannot accept twice the same request
%% number (this is a property we want to prove about this
%% specification).  In that case, the we use \lstinline{accept} to send a
%% notification to the client:
%% \begin{emlcode}
%% \begin{lstlisting}
%% let accept client @ n _ = {sendAcc client n};;
%% \end{lstlisting}
%% \end{emlcode}
%% where the parameter \lstinline{n} is an observation made by
%% \lstinline{OkFor n} and \lstinline{_} is an observation made by an
%% \lstinline{Prior(OkFor n)}.  We do not care about the observation made
%% by \lstinline{Prior(OkFor n)} because we know it is \lstinline{n}.



%% \intitle{The leader}.

%% A leader is really simple: when it receives a request \lstinline{n},
%% it spawns a \lstinline{Handler} for \lstinline{n} using the
%% delegation combinator:
%% \begin{emlcode}
%% \begin{lstlisting}
%% class Leader = Req >>= Handler;;
%% \end{lstlisting}
%% \end{emlcode}

%% Finally, the main program is the parallel combination of the \lstinline{Leader}
%% installed at location \lstinline{ldr} and the \lstinline{Store}
%% installed at locations \lstinline{store1} and \lstinline{store2}:
%% \begin{emlcode}
%% \begin{lstlisting}
%% main Leader @ {ldr} || Store @ {store1;store2} ;;
%% \end{lstlisting}
%% \end{emlcode}


%\subsection{Mutual exclusion}


====

\item
\lstinline{domain} $[(x_1,y_1); (x_2,y_2); ...] = [x_1; x_2; ...]$
\item
\lstinline{range} $[(x_1,y_1); (x_2,y_2); ...] = [y_1; y_2; ...]$
\item
\lstinline{in_domain} $\NUPRL{deq}~z~[(x_1,y_1); (x_2,y_2); ...]$ is a
boolean value that is \lstinline{true} iff $z$ is one of the $x_i$.

The argument $\NUPRL{deq}$ denotes an operation that decides
equality among the $x$'s.

===

