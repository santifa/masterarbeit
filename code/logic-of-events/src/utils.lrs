This module defines some basic helper constructs for the logic of events.
Defined modules: FIFO Queue

Eine FIFO Queue ist eine Warteschlangenstruktur bei der zuerst eingegebene Nachrichten
auch zuerst wieder ausgegeben werden. In diesem Fall wird sie mit dynamischer Länge
über einen Vektor abgebildet. 

Die beiden wichtigsten Funktionen der Queue sind enqueue() und dequeue(),
die ein Element hinten anhängen oder vorne entnehmen.
Der Einfachheit halber wird eine veränderbare Queue genommen, damit nicht unnötig kopiert werden muss,
beim verstauen und holen von der Queue.

> #![allow(dead_code)]
> pub mod fifo {
    Die Queue kann einen generischen Typen aufnehmen
>    #[derive(Debug, Clone)]
>    pub struct FifoQueue<T> {
>        inner: Vec<T>,
>    }

     Implementierung von enqueue und dequeue sowie zwei Hilfsfunktionen.
>    impl<T: Clone> FifoQueue<T> {

     Der generische Typ muss klonbar sein, damit er bei einer Vergrößerung
     des inneren Vektors kopiert werden kann.
>    pub fn new() -> Self {
>        FifoQueue { inner: Vec::new() }
>    }

    Add an item to the end of the `Queue`. Returns `Ok(usize)` with the new
    length of the `Queue`, or `Err(())` if there is no more room.
    Die Funktion enqueue() hängt ein neues Element hinten an die Queue an. enqueue: Q -> T -> Q
>    pub fn enqueue(&mut self, item: T) {
>        self.inner.push(item)
>    }


     Die Funktion dequeue() entfernt das erste Element im Vektor und gibt es zurück.
     Wenn kein Element in der Queue verbleibt dann wird None zurück gegeben.
     dequeue: Q -> (Q*(T+None))
>    pub fn dequeue(&mut self) -> Option<T> {
>        if !self.inner.is_empty() {
>            Some(self.inner.remove(0))
>        } else {
>            None
>        }
>    }

     Hilfsfunktion die die Länge der Queue zurück gibt. len: Q -> i32
>    pub fn len(&self) -> usize {
>        self.inner.len()
>    }

     Hilfsfunktion um zu testen ob die `Queue` leer ist. is_empty: Q -> bool
>    pub fn is_empty(&self) -> bool {
>        self.inner.is_empty()
>    }
>  }
    Einige Testfunktionen um die Korrektheit der Implementierung fest zustellen
#CODE
    #[cfg(test)]
    mod test {
        use super::*;
        #[test]
        fn test_fifo() {
            let mut fifo: FifoQueue<i32> = FifoQueue::new();
            fifo.enqueue(0);
            fifo.enqueue(1);
            assert_eq!(0, fifo.dequeue().unwrap());
            assert_eq!(1, fifo.dequeue().unwrap());
            assert!(fifo.dequeue().is_none());
        }
    }
}
#CODE


